<h1 id="🧠-카피-온-라이트copy-on-write-진짜-복사는-나중에">🧠 카피 온 라이트(Copy-on-Write): 진짜 복사는 나중에!</h1>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/338ad71f-9e40-4a78-92a7-480e3d0f03fc/image.png" /></p>
<h2 id="1-fork의-오해와-진실">1) fork()의 오해와 진실</h2>
<h3 id="📌-기본-동작">📌 기본 동작</h3>
<p>리눅스에서 <code>fork()</code> 함수는 부모 프로세스를 그대로 복사해 자식 프로세스를 만듭니다. 그런데 정말로 <strong>&quot;모든 메모리&quot;</strong>를 복사할까요?</p>
<blockquote>
<p>❌ 아니요! fork()는 실제 메모리를 바로 복사하지 않습니다.<br />✅ 대신, <strong>페이지 테이블만 복사</strong>하고, 물리 메모리는 <strong>공유</strong>합니다.</p>
</blockquote>
<p>리눅스에서 <strong><code>fork()</code> 함수</strong>는 부모 프로세스를 복제하여 자식 프로세스를 생성합니다. 하지만 메모리까지 전부 복사하면 <strong>너무 느리고 메모리 낭비</strong>겠죠? 그래서 리눅스는 <strong>카피 온 라이트(Copy-on-Write, CoW)</strong> 기법을 활용합니다.</p>
<h3 id="🧩-페이지-테이블만-복사된-상태-예시">🧩 페이지 테이블만 복사된 상태 예시</h3>
<table>
<thead>
<tr>
<th>프로세스</th>
<th>가상 주소</th>
<th>물리 주소</th>
<th>쓰기 권한</th>
</tr>
</thead>
<tbody><tr>
<td>부모</td>
<td>0~100</td>
<td>500~600</td>
<td>❌</td>
</tr>
<tr>
<td>부모</td>
<td>100~200</td>
<td>600~700</td>
<td>❌</td>
</tr>
<tr>
<td>자식</td>
<td>0~100</td>
<td>500~600</td>
<td>❌</td>
</tr>
<tr>
<td>자식</td>
<td>100~200</td>
<td>600~700</td>
<td>❌</td>
</tr>
</tbody></table>
<blockquote>
<p>부모와 자식 모두 <strong>같은 물리 주소</strong>를 참조하지만, 쓰기 권한은 제거된 상태입니다.</p>
</blockquote>
<p>이 방식 덕분에:</p>
<ul>
<li><code>fork()</code> 실행이 매우 빠릅니다 ✅</li>
<li>메모리도 많이 절약됩니다 ✅</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/b808d7f9-f5d6-406c-95d6-23c3121b80fc/image.png" /></p>
<h2 id="2-쓰려고-하면-생기는-일-진짜-복사-등장">2) 쓰려고 하면 생기는 일: 진짜 복사, 등장!</h2>
<h3 id="✨-copy-on-writecow란">✨ Copy-on-Write(CoW)란?</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/a84a7908-90f3-4b18-a7c3-19b071b0db65/image.png" /></p>
<p><code>fork()</code> 직후 부모와 자식은 물리 메모리를 공유하지만, <strong>쓰기</strong> 시도 순간 복사가 발생합니다. 이게 바로 <strong>Copy-on-Write</strong>입니다.</p>
<blockquote>
<p>페이지 테이블 엔트리 내부에는 페이지에 쓰기 권한을 관리하는 필드가 있는데, 이때 <strong>부모와 자식 양쪽을 대상으로 모든 페이지에 쓰기 권한을 무효화</strong>합니다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/0f50e947-d9e5-4606-a383-ff54c87acc6e/image.png" /></p>
<pre><code class="language-plaintext">부모와 자식: &quot;우린 같은 책을 읽고 있어요(읽기 전용)&quot;
자식: &quot;여기 좀 고쳐야겠어!&quot; ➜ 페이지 폴트 발생!
커널: &quot;자, 새 책 줄게. 거기다 써!&quot;</code></pre>
<h3 id="🔐-페이지-테이블에서-쓰기-권한을-무효화하는-이유">🔐 페이지 테이블에서 쓰기 권한을 무효화하는 이유</h3>
<h4 id="1-페이지-테이블page-table과-권한-필드">1) 페이지 테이블(Page Table)과 권한 필드</h4>
<p>운영체제는 <strong>페이지 테이블(Page Table)</strong>을 통해 가상 주소를 물리 주소로 변환할 뿐 아니라, 각 페이지에 대한 <strong>접근 권한(읽기/쓰기/실행 등)</strong>도 함께 관리합니다.</p>
<p>페이지 테이블의 각 항목을 <strong>Page Table Entry(PTE)</strong>라고 부르는데, 여기에 다음과 같은 정보가 포함되어 있어요:</p>
<table>
<thead>
<tr>
<th>필드명</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Physical Address</td>
<td>매핑된 물리 주소</td>
</tr>
<tr>
<td>R (Read)</td>
<td>읽기 권한</td>
</tr>
<tr>
<td>W (Write)</td>
<td>쓰기 권한</td>
</tr>
<tr>
<td>X (Execute)</td>
<td>실행 권한</td>
</tr>
<tr>
<td>...</td>
<td>기타 캐시, 접근 여부 등</td>
</tr>
</tbody></table>
<h4 id="2-왜-fork-후에-쓰기-권한을-없앨까">2) 왜 fork() 후에 쓰기 권한을 없앨까?</h4>
<p><code>fork()</code>를 호출하면 자식은 부모의 복사본이 되지만, 진짜 메모리를 복사하지는 않아요.</p>
<p>대신 부모와 자식 모두 같은 물리 메모리를 공유하게 됩니다.</p>
<p>하지만 <strong>이 상태에서 누군가 그 메모리를 수정해버리면?</strong>
→ 공유 중이던 메모리가 망가질 수 있어요.</p>
<p>그래서!</p>
<blockquote>
<p>✅ 부모와 자식의 페이지 테이블 모두에서 &quot;쓰기 권한&quot;을 제거해버립니다.
즉, <strong>읽기 전용(read-only)</strong>으로 만들어버리는 거죠.</p>
</blockquote>
<h3 id="🧠-내부-동작-요약">🧠 내부 동작 요약</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/5859aa3c-3160-43d7-83fc-b19f6915ee34/image.png" /></p>
<p>이후에 메모리를 읽을 때 부모와 자식 사이에 공유된 물리 페이지에 접근 가능합니다. </p>
<p>한편, 부모와 자식 중 <strong>어느 쪽이 데이터를 갱신하려고 하면 페이지 공유를 해제</strong>하고, 프로세스마다 <code>전용 페이지</code>를 만듭니다. 자식 프로세스가 페이지 데이터를 갱신하면 아래와 같은 일이 일어납니다.</p>
<ol>
<li>자식이 어떤 페이지에 <strong>쓰기 시도</strong>  </li>
<li><strong>쓰기 권한 없음</strong> → CPU에서 <strong>페이지 폴트(Page Fault)</strong> 발생  </li>
<li>CPU가 커널 모드로 바뀌고 커널의 페이지 폴트 핸들러가 동작</li>
<li>페이지 폴트 핸들러는 접속한 페이지를 <strong>별도의 물리 메모리에 복사</strong></li>
<li>자식의 페이지 테이블을 해당 메모리로 <strong>업데이트</strong>  </li>
<li>이제부터 부모와 자식은 <strong>각자의 메모리</strong> 사용  </li>
</ol>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/db81d792-e6c8-4dff-a2ec-15bee6d8ac6a/image.png" /></p>
<blockquote>
<p>✅ 즉, <strong>처음 쓰는 순간에만</strong> 복사하고, 그전까지는 공유로 처리합니다.</p>
</blockquote>
<blockquote>
<p><strong>fork() 직후 부모-자식 모두 쓰기 권한을 제거하는 이유는, 쓰기 시도 시점까지 메모리를 공유하게 하기 위해서예요!</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>시점</th>
<th>상태</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>fork() 직후</td>
<td>부모와 자식의 페이지에 모두 쓰기 권한 ❌</td>
<td>메모리는 공유 중</td>
</tr>
<tr>
<td>자식이 쓰기 시도</td>
<td>페이지 폴트 발생 → 복사 발생</td>
<td>이제부터 자식은 독립된 메모리</td>
</tr>
<tr>
<td>부모는 그대로</td>
<td>아직 쓰기 안 하면 여전히 공유 중</td>
<td>효율적 메모리 사용 가능</td>
</tr>
</tbody></table>
<h2 id="3-실험-코드-cow-실제-확인해보기-cowpy">3) 실험 코드: CoW 실제 확인해보기 (cow.py)</h2>
<h3 id="📜-실험-개요">📜 실험 개요</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/3ebc1ad0-ae95-4b86-a635-07d283ecf777/image.png" /></p>
<ol>
<li><p>100MiB 메모리 확보 후 <code>fork()</code></p>
</li>
<li><p><strong>fork 직후 자식 메모리 사용량 확인</strong></p>
</li>
</ol>
<ul>
<li>시스템 전체의 물리 메모리 사용량, 프로세스의 물리 메모리 사용량, 메이저 폴트 횟수, 마이너 폴트 횟수를 출력</li>
</ul>
<ol start="3">
<li><p>fork() 함수를 호출</p>
</li>
<li><p>자식이 메모리 접근(쓰기) → <strong>다시 확인</strong></p>
</li>
</ol>
<ul>
<li>자식 프로세스 종료를 대기. </li>
<li>자식 프로세스를 대상으로 2와 동일한 정보를 출력</li>
<li>1에서 확보한 영역의 <strong>모든 페이지에 접근</strong></li>
<li>자식 프로세스를 대상으로 2와 동일한 정보를 출력</li>
</ul>
<h3 id="📦-핵심-코드">📦 핵심 코드</h3>
<pre><code class="language-python">import mmap, os, subprocess, sys

ALLOC_SIZE = 100*1024*1024
PAGE_SIZE = 4096

def access(data):
    for i in range(0, ALLOC_SIZE, PAGE_SIZE):
        data[i] = 0

def show_meminfo(msg, who):
    print(msg)
    subprocess.run(&quot;free&quot;)
    subprocess.run([&quot;ps&quot;, &quot;-orss,maj_flt,min_flt&quot;, str(os.getpid())])
    print()

data = mmap.mmap(-1, ALLOC_SIZE, flags=mmap.MAP_PRIVATE)
access(data)

show_meminfo(&quot;*** 자식 생성 전 ***&quot;, &quot;부모&quot;)
pid = os.fork()

if pid == 0:
    show_meminfo(&quot;*** 자식 생성 직후 ***&quot;, &quot;자식&quot;)
    access(data)
    show_meminfo(&quot;*** 자식 메모리 접근 후 ***&quot;, &quot;자식&quot;)
    sys.exit(0)

os.wait()</code></pre>
<h2 id="4-실험-결과-해석">4) 실험 결과 해석</h2>
<table>
<thead>
<tr>
<th>시점</th>
<th>시스템 전체 메모리 변화</th>
<th>RSS 변화</th>
<th>마이너 폴트 수</th>
</tr>
</thead>
<tbody><tr>
<td>자식 생성 직후</td>
<td>약 1MiB 증가</td>
<td>거의 동일</td>
<td>적음</td>
</tr>
<tr>
<td>자식 메모리 접근 후</td>
<td>약 100MiB 증가</td>
<td>유사</td>
<td>매우 많음</td>
</tr>
</tbody></table>
<ul>
<li>카피 온 라이트를 이용하면 프로세스가 fork() 함수를 호출한 순간에는 메모리를 전부 복사하지 않아도 되므로 <strong>fork() 함수 처리가 빨라지고 메모리 사용량도 줄어듭니다.</strong></li>
<li>프로세스를 생성해도 모든 메모리에 쓰기 작업이 발생하는 건 극히 드문 일이므로 <strong>시스템 전체 메모리
사용량도 줄어듭니다.</strong></li>
</ul>
<h3 id="📌-요점-정리">📌 <strong>요점 정리</strong>:</h3>
<ul>
<li>자식 생성만으로는 <strong>메모리 거의 사용 안 함</strong></li>
<li>쓰기 이후에만 실제 <strong>RAM 복사</strong> 발생</li>
<li><strong>RSS는 공유 여부 무관하게 물리 메모리 할당된 총합을 보여줌</strong></li>
</ul>
<h3 id="rss-참고">RSS 참고</h3>
<blockquote>
<p>참고 : RSS(Resident Set Size) 는 프로세스가 실제 물리 메모리(RAM)에서 차지하고 있는 크기를 말합니다.</p>
</blockquote>
<p>그렇기에 RSS는 ‘실제 점유 중인 메모리'이라기보다는 RSS는 실제 메모리 점유량을 보여주는 것처럼 보이지만, <strong>공유된 메모리도 포함</strong>되어 있어서, 여러 프로세스가 같은 메모리(예: 공유 라이브러리)를 쓰고 있어도 <strong>각자 따로따로 계산</strong>해요.</p>
<blockquote>
<p>📌 그래서 여러 프로세스의 RSS 값을 다 더하면 실제 물리 메모리 총합보다 <strong>훨씬 클 수도 있어요!</strong></p>
</blockquote>
<p>즉, RSS 값은 물리 메모리의 &quot;공유 상태&quot;는 고려하지 않기 때문입니다.</p>
<p><strong>예시로 이해하기</strong></p>
<pre><code class="language-bash">$ ps -o pid,rss,cmd -p 1234
  PID   RSS CMD
1234  20480 /usr/bin/python3 myscript.py</code></pre>
<p>→ 이건 <strong>1234번 프로세스가 약 20MB의 RAM을 점유 중</strong>이라는 뜻이지만,<br />그 중 일부는 다른 프로세스와 공유하고 있을 수도 있다는 점을 잊지 마세요!</p>
<p><strong>다른 메모리 지표들과 비교</strong></p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/6f37ff82-ddb4-4c21-8d18-3c0aa7145569/image.png" /></p>
<blockquote>
<p>출처 : <a href="https://blog.naver.com/ya3344/221599131853?viewType=pc">https://blog.naver.com/ya3344/221599131853?viewType=pc</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>지표</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>VSZ (Virtual Set Size)</strong></td>
<td>프로세스가 사용할 수 있도록 예약된 가상 메모리 전체 크기</td>
</tr>
<tr>
<td><strong>RSS (Resident Set Size)</strong></td>
<td>실제 메모리에 올라간 크기 (공유 포함)</td>
</tr>
<tr>
<td><strong>PSS (Proportional Set Size)</strong></td>
<td>공유 메모리를 각 프로세스에 비례해서 나눠 계산한 값 (정확함)</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 <code>ps</code> 명령어는 기본적으로 <strong>RSS만 보여주지만</strong>, 더 정확한 값을 원하면 <code>smem</code>이나 <code>procfs</code>에서 <strong>PSS</strong>를 확인하는 것이 좋아요!</p>
</blockquote>
<h2 id="5-시각-자료-copy-on-write-시나리오">5) 시각 자료: Copy-on-Write 시나리오</h2>
<pre><code class="language-plaintext">[부모 &amp; 자식 프로세스]
   👨 ➡️ fork() ➡️ 👶

[초기 상태]
  가상 주소: 동일
  물리 주소: 동일
  쓰기 권한: ❌

[자식이 쓰기를 시도]
  ⛔ 페이지 폴트 발생
  🔁 커널: 메모리 복사
  ✅ 자식 전용 메모리로 업데이트</code></pre>
<h2 id="✅-한-줄-요약">✅ 한 줄 요약</h2>
<blockquote>
<p><strong>Copy-on-Write는 쓰기할 때만 진짜 복사를 하는 똑똑한 전략이다.</strong></p>
</blockquote>
<h2 id="메모리-참고-사진">메모리 참고 사진</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/5cced394-bbe7-46d8-a258-b7faf1c6d8fa/image.png" /></p>
<blockquote>
<p>출처 : <a href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.alibabacloud.com%2Fhelp%2Fen%2Farms%2Fapplication-monitoring%2Fdeveloper-reference%2Fmemory-metrics&amp;psig=AOvVaw2-VxYDaw7nN9hnu9SW34rT&amp;ust=1744677892712000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CBcQjhxqFwoTCNimluKl1owDFQAAAAAdAAAAABAT">https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.alibabacloud.com%2Fhelp%2Fen%2Farms%2Fapplication-monitoring%2Fdeveloper-reference%2Fmemory-metrics&amp;psig=AOvVaw2-VxYDaw7nN9hnu9SW34rT&amp;ust=1744677892712000&amp;source=images&amp;cd=vfe&amp;opi=89978449&amp;ved=0CBcQjhxqFwoTCNimluKl1owDFQAAAAAdAAAAABAT</a></p>
</blockquote>
<h1 id="🚀-execve와-demand-paging-메모리는-진짜-쓸-때-주는-거야">🚀 execve()와 Demand Paging: 메모리는 ‘진짜’ 쓸 때 주는 거야</h1>
<h2 id="1-demand-paging이-뭐였더라">1) Demand Paging이 뭐였더라?</h2>
<blockquote>
<p>💡 <strong>Demand Paging</strong>은 <strong>필요할 때만</strong> 메모리를 물리 메모리에 로딩하는 기법이에요.<br />처음부터 다 올리는 게 아니라, <strong>접근할 때 페이지 폴트(Page Fault)</strong>가 발생하면 그때 메모리를 할당해요.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/ebaa53b0-f133-448f-a996-8578221741d2/image.png" /></p>
<blockquote>
<p>출처 : <a href="https://www.sitesbay.com/os/os-what-is-demand-paging-in-operating-system">https://www.sitesbay.com/os/os-what-is-demand-paging-in-operating-system</a></p>
</blockquote>
<ul>
<li>페이지에 접근을 시도합니다.</li>
<li><strong>페이지가 유효하다면(메모리에 있다면) 정상적으로 명령어 처리를 계속</strong>합니다.</li>
<li>페이지가 유효하지 않으면 <code>페이지 오류 트랩</code>이 발생합니다.</li>
<li>메모리 참조가 보조 메모리의 특정 위치에 대한 유효한 참조인지 확인합니다. 유효하지 않으면 프로세스가 종료됩니다(불법적인 메모리 접근). 유효하지 않으면 필요한 페이지를 페이지 인해야 합니다.</li>
<li>원하는 페이지를 <strong>주 메모리로 읽어들이도록 디스크 작업을 예약</strong>합니다.</li>
<li>운영 체제 트랩으로 인해 중단된 명령어를 다시 시작합니다.</li>
</ul>
<p>예를 들어, 큰 책을 빌렸는데 처음 몇 장만 읽을 거면 굳이 전체를 복사할 필요가 없겠죠? 필요한 쪽만 복사해도 충분하니까요.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/74564ffa-ea79-448c-a6b7-73605740f076/image.png" /></p>
<h2 id="2-execve에서-demand-paging은-어떻게-작동할까">2) execve()에서 Demand Paging은 어떻게 작동할까?</h2>
<p><code>execve()</code> 함수는 새로운 프로그램을 로딩할 때 사용돼요. 이 함수가 호출되면:</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/6b0745c1-5532-4d70-8048-02a7ce5ff65f/image.png" /></p>
<ol>
<li>기존 프로세스의 메모리는 전부 <strong>초기화</strong>됩니다.</li>
<li>실행할 프로그램의 <strong>메모리 구조만 설정</strong>되고, <strong>물리 메모리는 할당되지 않아요!</strong>  </li>
<li>이후 <strong>코드가 실행되며 페이지에 접근</strong>할 때, 그제서야 메모리가 할당됩니다.</li>
</ol>
<blockquote>
<p>즉, &quot;코드를 읽는 순간까지도 물리 메모리는 할당되지 않은 상태&quot;라는 뜻입니다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/f59d03ad-0238-4dbe-9225-9207c019aebf/image.png" /></p>
<blockquote>
<p>출처 : <a href="http://www.hexainclude.com/demand-paging/">http://www.hexainclude.com/demand-paging/</a></p>
</blockquote>
<p>프로세스가 <strong>메모리에 존재하지 않는 페이지에 접근하려고 할 때</strong>, 유효하지 않은 것으로 표시된 페이지에 접근하면 <code>페이지 폴트 또는 페이지 누락 인터럽트</code>가 발생합니다. OS는 <code>인터럽트 처리기</code>로 제어권을 넘깁니다. 페이지 폴트 인터럽트임을 확인하면 가상 메모리 처리기를 호출합니다.</p>
<p><code>인터럽트 핸들러</code>는 <strong>페이지 폴트(pi)를 발생시킨 페이지 번호를 가상 핸들러에 전달</strong>합니다. 가상 메모리는 사용 가능한 프레임 목록을 확인하고 해당 페이지를 스왑 공간에서 메모리로 로드합니다. <code>커널</code>은 <strong>해당 항목으로 페이지 테이블을 수정하여 해당 페이지가 유효해지도록 합니다.</strong></p>
<blockquote>
<p>참고로 인터럽트 핸들러(영어: interrupt handler) 또는 인터럽트 서비스 루틴(영어: interrupt Service Routine, ISR)은 인터럽트 접수에 의해 발생되는 인터럽트에 대응하여 특정 기능을 처리하는 기계어 코드 루틴입니다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/eb865a5d-e3d7-4824-837a-3856c93d23f3/image.png" /></p>
<blockquote>
<p>출처 : <a href="https://mns010.tistory.com/12">https://mns010.tistory.com/12</a></p>
</blockquote>
<h2 id="3-단계별-흐름-정리">3) 단계별 흐름 정리</h2>
<h3 id="🖼-그림-05-03-execve-호출-직후">🖼 그림 05-03: execve() 호출 직후</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/3a0ad9e0-fa5c-4e7c-9438-5cd5ee29c73a/image.png" /></p>
<ul>
<li>가상 주소만 존재하고, 물리 주소 연결은 없음  </li>
<li>아직 페이지에 <strong>접근하지 않았으므로 페이지 폴트도 없음</strong></li>
</ul>
<h3 id="🖼-그림-05-04-엔트리-포인트-접근-→-페이지-폴트-발생">🖼 그림 05-04: 엔트리 포인트 접근 → 페이지 폴트 발생</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/71f846f1-832f-4225-bb3f-93e15eef248c/image.png" /></p>
<ul>
<li>실행 지점 진입  </li>
<li>해당 페이지가 물리 메모리에 없으므로 <strong>페이지 폴트 발생!</strong></li>
</ul>
<h3 id="🖼-그림-05-05-페이지-폴트-처리-후-메모리-할당">🖼 그림 05-05: 페이지 폴트 처리 후 메모리 할당</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/60f70935-e310-42ba-993e-3b14bd41716a/image.png" /></p>
<ul>
<li>커널이 페이지 폴트를 감지하고</li>
<li>필요한 페이지를 <strong>RAM에 복사</strong></li>
<li>가상 주소 ↔ 물리 주소 연결 완료</li>
</ul>
<h3 id="🖼-그림-05-06-다른-페이지-접근-→-반복-처리">🖼 그림 05-06: 다른 페이지 접근 → 반복 처리</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/91de63f7-771c-4552-97ab-671dc09f755a/image.png" /></p>
<ul>
<li>그 이후 다른 페이지 접근할 때도 <strong>동일한 방식</strong>으로 페이지 폴트가 발생  </li>
<li>해당 페이지마다 물리 메모리 할당이 이루어짐</li>
</ul>
<h2 id="4-demand-paging의-장점은">4) Demand Paging의 장점은?</h2>
<table>
<thead>
<tr>
<th>항목</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>🔄 지연 로딩</td>
<td>실제로 쓰기 전까지 메모리를 로딩하지 않음</td>
</tr>
<tr>
<td>💾 메모리 절약</td>
<td>필요 없는 페이지는 끝까지 로딩되지 않을 수 있음</td>
</tr>
<tr>
<td>🚀 실행 속도 개선</td>
<td>프로그램 실행 시점에서 필요한 부분만 로딩해서 빠르게 시작 가능</td>
</tr>
<tr>
<td>📉 캐시 효율</td>
<td>자주 접근하는 페이지만 유지하면 캐시 히트율 향상 가능</td>
</tr>
</tbody></table>
<h2 id="5-execve--demand-paging-흐름-요약">5) execve() + Demand Paging 흐름 요약</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/3360ea24-d6b8-4444-84b0-4b7bebcfcddb/image.png" /></p>
<pre><code class="language-plaintext">[1] execve() 호출
      ↓
[2] 프로그램 메모리 맵 구성 (물리 메모리는 아직 없음)
      ↓
[3] 코드 실행 시작 → 첫 페이지 접근 시 페이지 폴트 발생
      ↓
[4] 해당 페이지만 물리 메모리에 로딩 (나머지는 아직 없음)
      ↓
[5] 이후 필요한 페이지마다 on-demand로 메모리 로딩</code></pre>
<h2 id="💭-비유">💭 비유</h2>
<p> <strong>execve()는 가상 주소만 준비해놓고, 실제 메모리는 ‘접근할 때’ 하나씩 받아오는 효율적인 시스템!</strong></p>
<blockquote>
<p>&quot;책을 한꺼번에 다 읽지 않고, 필요한 페이지부터 넘기기 시작하는 것과 같아요!&quot;</p>
</blockquote>
<h1 id="🧠-공유-메모리를-통한-프로세스-통신-자식과-부모가-같은-종이를-본다면">🧠 공유 메모리를 통한 프로세스 통신: 자식과 부모가 같은 종이를 본다면?</h1>
<h2 id="1-프로세스끼리-대화하려면">1) 프로세스끼리 대화하려면?</h2>
<p>컴퓨터에서 여러 프로그램이 함께 일하려면 <strong>서로 데이터를 주고받는 통신 수단</strong>이 필요합니다. 이를 <strong>IPC (Inter-Process Communication, 프로세스 간 통신)</strong>이라고 해요.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/6121c3c3-144f-478f-a4fc-a7b9924d640d/image.png" /></p>
<blockquote>
<p>출처: <a href="https://heeonii.tistory.com/13">https://heeonii.tistory.com/13</a> [우당탕탕 히온이네:티스토리]</p>
</blockquote>
<p>위 그림처럼 <code>프로세스</code>는 완전히 독립된 실행객체로써 다른 프로세스의 영향을 받지 않습니다. 독립되어 있는 만큼 별도의 설비가 없이 서로간의 통신이 어려워, 커널 영역에서 IPC라는 내부 프로세스 간 통신을 제공하여 *<em>프로세스는 커널이 제공하는 IPC설비를 이용해서 프로세스 간 통신을 가능하게 합니다. *</em></p>
<p>리눅스는 다양한 IPC 방식을 지원하는데, 그중에서도 <strong>“공유 메모리(shared memory)”</strong>는 <strong>가장 빠른 방식</strong> 중 하나입니다.</p>
<h2 id="2-공유하지-않을-때-어떤-일이-벌어질까">2) 공유하지 않을 때 어떤 일이 벌어질까?</h2>
<p>먼저, 일반적인 <code>fork()</code> 이후 데이터 공유 없이 자식이 값을 바꿨을 때를 보겠습니다.</p>
<h3 id="💻-코드-예시-non-shared-memorypy">💻 코드 예시: <code>non-shared-memory.py</code></h3>
<pre><code class="language-python">#!/usr/bin/python3
import os
import sys

data = 1000
print(&quot;자식 프로세스 생성 전 데이터 값: {}&quot;.format(data))
pid = os.fork()

if pid == 0:
    data = 2  # 자식이 값을 바꿈
    sys.exit(0)

os.wait()
print(&quot;자식 프로세스 종료 후 데이터 값: {}&quot;.format(data))</code></pre>
<h3 id="🧪-결과">🧪 결과</h3>
<pre><code>자식 프로세스 생성 전 데이터 값: 1000  
자식 프로세스 종료 후 데이터 값: 1000</code></pre><h3 id="❓-왜-값이-안-바뀌었을까">❓ 왜 값이 안 바뀌었을까?</h3>
<blockquote>
<p> <code>fork() 함수</code>를 호출한 이후의 부모와 자식 프로세스는 <strong>데이터를 공유하지 않기 때문에</strong> 어떤 한쪽의 데이터를 갱신하더라도 다른 쪽 프로세스에 있는 데이터에는 영향을 주지 않습니다.</p>
</blockquote>
<ul>
<li><code>fork()</code>는 부모의 메모리를 복사하지만, <strong>Copy-on-Write(CoW)</strong> 때문에 <strong>쓰기 시도 시 복제</strong>됩니다.</li>
<li>자식이 데이터를 바꾸면 <strong>자신만의 사본</strong>을 갖게 되어, 부모 입장에서는 변경 사항을 모르게 되는 거죠.</li>
</ul>
<h2 id="3-그럼-진짜-공유하려면-→-공유-메모리mmap--map_shared">3) 그럼 진짜 공유하려면? → <strong>공유 메모리(mmap + MAP_SHARED)</strong></h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/6bc25a22-e7e4-415a-90f5-e32cf7b542b9/image.png" /></p>
<p>이번엔 자식과 부모가 <strong>같은 메모리 공간</strong>을 바라보도록 설정해볼게요.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/456f24d0-1cb0-4513-b903-f0afcbe143c9/image.png" /></p>
<blockquote>
<p>출처: <a href="https://heeonii.tistory.com/13">https://heeonii.tistory.com/13</a> [우당탕탕 히온이네:티스토리]</p>
</blockquote>
<h3 id="📦-공유-메모리란-무엇인가요">📦 공유 메모리란 무엇인가요?</h3>
<h4 id="1-기본-개념">1) 기본 개념</h4>
<blockquote>
<p><strong>공유 메모리(shared memory)</strong>는 <strong>여러 프로세스가 동일한 메모리 공간에 접근할 수 있도록 해주는 설비</strong>입니다.</p>
</blockquote>
<p>기본적으로 프로세스는 <strong>자기만의 독립된 메모리 공간</strong>을 가지고 있어요. 커널은 이를 보호해서 <strong>다른 프로세스가 접근하거나 간섭하지 못하게</strong> 합니다. 하지만 때때로, <strong>서로 협력해야 하는 상황</strong>에서는 데이터를 함께 사용해야 할 필요가 생기죠.</p>
<h4 id="2-왜-공유-메모리가-필요할까">2) 왜 공유 메모리가 필요할까?</h4>
<blockquote>
<p>❓ 프로세스끼리 데이터를 주고받고 싶다면?</p>
</blockquote>
<ul>
<li>파이프(PIPE), 메시지 큐 등의 <strong>전통적인 IPC 방식</strong>은 데이터를 주고받는 데 <strong>중개자 역할</strong>을 필요로 합니다.</li>
<li>반면, 공유 메모리는 <strong>중개 없이 곧바로 메모리에 접근</strong>하게 만들어줍니다.</li>
<li>이는 <strong>스레드(Thread)</strong>처럼 <strong>공통 메모리 공간을 공유</strong>하는 방식과 유사해요.</li>
</ul>
<h4 id="3-어떻게-동작하나요">3) 어떻게 동작하나요?</h4>
<p><strong>🧠 작동 흐름</strong></p>
<ol>
<li><strong>프로세스 A가 커널에 공유 메모리를 요청</strong>합니다.</li>
<li>커널은 해당 프로세스에 <strong>공유 가능한 메모리 공간</strong>을 할당합니다.</li>
<li><strong>프로세스 B도 같은 공유 메모리 공간을 매핑</strong>받으면,</li>
<li>이제 A와 B는 <strong>동일한 메모리 공간을 읽고 쓸 수 있게 됩니다.</strong></li>
</ol>
<h4 id="4-특징과-장점">4) 특징과 장점</h4>
<table>
<thead>
<tr>
<th>항목</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>🧭 직접 접근</td>
<td>커널의 중재 없이 메모리에 곧바로 접근 가능</td>
</tr>
<tr>
<td>⚡ 매우 빠름</td>
<td>모든 IPC 중에서 <strong>가장 빠른 방식</strong></td>
</tr>
<tr>
<td>📈 메모리 증가 없음</td>
<td>단순히 포인터로 접근하므로 물리적 메모리 사용량은 증가하지 않음</td>
</tr>
<tr>
<td>🔄 양방향 통신 가능</td>
<td><strong>읽기 + 쓰기</strong> 모두 가능한 구조</td>
</tr>
</tbody></table>
<h4 id="5-언제-사용하면-좋을까">5) 언제 사용하면 좋을까?</h4>
<ul>
<li><strong>프로세스 간에 실시간으로 데이터를 주고받아야 할 때</strong></li>
<li><strong>양방향 통신이 필요할 때</strong></li>
<li><strong>속도가 매우 중요한 시스템(예: 게임 엔진, DB 공유 캐시 등)</strong></li>
</ul>
<blockquote>
<p><strong>공유 메모리는 여러 프로세스가 하나의 메모리 공간을 함께 사용함으로써, 빠르고 효율적인 데이터 교환을 가능하게 해주는 IPC 방식입니다.</strong>
 </p>
</blockquote>
<h3 id="💻-코드-예시-shared-memorypy">💻 코드 예시: <code>shared-memory.py</code></h3>
<pre><code class="language-python">#!/usr/bin/python3
import os, sys, mmap
from sys import byteorder

PAGE_SIZE = 4096
data = 1000
print(&quot;자식 프로세스 생성 전 데이터 값: {}&quot;.format(data))

# 공유 메모리 생성
shared_memory = mmap.mmap(-1, PAGE_SIZE, flags=mmap.MAP_SHARED)

# 초기값 저장
shared_memory[0:8] = data.to_bytes(8, byteorder)

pid = os.fork()

if pid == 0:
    # 자식이 메모리 읽고 2배로 만들기
    data = int.from_bytes(shared_memory[0:8], byteorder)
    data *= 2
    shared_memory[0:8] = data.to_bytes(8, byteorder)
    sys.exit(0)

os.wait()
# 부모가 값 확인
data = int.from_bytes(shared_memory[0:8], byteorder)
print(&quot;자식 프로세스 종료 후 데이터 값: {}&quot;.format(data))</code></pre>
<h3 id="동작-방식">동작 방식</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/a5ef99ae-3d32-4475-8e68-bf73518df423/image.png" /></p>
<ol>
<li>정수 데이터 1000을 만들어서 데이터 값을 출력합니다.</li>
<li>공유 메모리 영역을 작성해서 1 데이터 값을 <strong>영역 첫 부분에 저장</strong>합니다.</li>
<li>자식 프로세스를 만듭니다.</li>
<li>부모 프로세스는 자식 프로세스 종료를 기다립니다. 자식 프로세스는 2에서 만든 데이터 값을 읽고 2배로 만들어서 공유 메모리 영역에 다시 기록합니다. 그러고 나서 자식 프로세스는 종료합니다.</li>
<li>부모 프로세스는 데이터 값을 출력합니다.</li>
</ol>
<h2 id="4-실험-결과">4) 실험 결과</h2>
<pre><code>자식 프로세스 생성 전 데이터 값: 1000  
자식 프로세스 종료 후 데이터 값: 2000</code></pre><h3 id="✅-이번엔-변경된-값이-반영됨">✅ 이번엔 변경된 값이 반영됨!</h3>
<ul>
<li>이유는 간단해요. <strong>부모와 자식이 같은 메모리 공간</strong>을 사용하고 있기 때문이죠.</li>
<li><code>mmap()</code>을 <code>MAP_SHARED</code> 플래그와 함께 쓰면, 메모리 영역이 <strong>프로세스 간 공유</strong>됩니다.</li>
</ul>
<h2 id="5-공유-메모리의-구조-이해">5) 공유 메모리의 구조 이해</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/dfe4e4eb-4757-4f93-9edf-115b80ac520b/image.png" /></p>
<h2 id="6-실생활-비유로-이해하기">6) 실생활 비유로 이해하기</h2>
<p>마치 부모와 자식이 <strong>같은 칠판을 보고 글씨를 쓰는 것과 같아요.</strong><br />자식이 1000을 2000으로 바꿔 쓰면, 부모가 그걸 고스란히 볼 수 있겠죠?</p>
<blockquote>
<p><strong>공유 메모리는 부모와 자식이 같은 메모리 공간을 보게 해서, 데이터가 정말로 '공유'되도록 만들어줍니다!</strong></p>
</blockquote>
<h1 id="🔔-시그널로-통신한다고요--프로세스끼리-신호-주고받기">🔔 시그널로 통신한다고요? – 프로세스끼리 '신호' 주고받기</h1>
<h2 id="1-시그널signal이란">1) 시그널(Signal)이란?</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/cfae1a41-2b80-4001-98f3-c0e1a159285f/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/49428143-9495-4885-ad62-7684aede34b2/image.png" /></p>
<blockquote>
<p>출처 : <a href="https://hasumang.tistory.com/11">https://hasumang.tistory.com/11</a></p>
</blockquote>
<blockquote>
<p><strong>시그널(Signal)</strong>은 리눅스에서 <strong>프로세스 간에 비동기적으로 신호를 주고받는 방법</strong>입니다.<br />프로세스에게 어떤 사건이 발생했음을 알려주는 <strong>간단한 메시지</strong> 역할을 해요.</p>
</blockquote>
<h3 id="예시로-자주-쓰는-시그널들">예시로 자주 쓰는 시그널들:</h3>
<table>
<thead>
<tr>
<th>시그널 이름</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td><code>SIGINT</code></td>
<td>인터럽트 (Ctrl+C)</td>
</tr>
<tr>
<td><code>SIGTERM</code></td>
<td>종료 요청</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>강제 종료 (kill -9)</td>
</tr>
</tbody></table>
<p>이 시그널들은 <strong>용도가 정해진 시스템 시그널</strong>이에요. 사용자 프로그램이 임의로 해석하지 않고, 시스템이 자동 처리하는 경우가 많습니다.</p>
<h2 id="2-자유롭게-사용할-수-있는-시그널-sigusr1-sigusr2">2) 자유롭게 사용할 수 있는 시그널: <code>SIGUSR1</code>, <code>SIGUSR2</code></h2>
<blockquote>
<p>사용자가 직접 정의해서 쓸 수 있는 시그널도 있어요!</p>
</blockquote>
<ul>
<li><code>SIGUSR1</code>, <code>SIGUSR2</code>는 <strong>사용자 정의 시그널</strong>입니다.</li>
<li>개발자가 원하는 의미를 부여해서, <strong>두 프로세스가 서로 통신하거나 진행 상태를 전달</strong>하는 데 사용할 수 있습니다.</li>
</ul>
<p>예를 들면, 프로세스 A가 B에게 <strong>“지금 데이터 처리 중이야”</strong>, 또는 <strong>“다음 단계로 넘어가”</strong>라는 신호를 보내는 식이죠.</p>
<h2 id="3-하지만-시그널에는-한계가-있어요">3) 하지만... 시그널에는 한계가 있어요</h2>
<table>
<thead>
<tr>
<th>특징</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>⚠ 단순함</td>
<td>시그널은 오직 &quot;왔다&quot;는 사실만 알림</td>
</tr>
<tr>
<td>⛔ 데이터 전달 불가</td>
<td>시그널만으로는 수치나 문자열 등 <strong>실제 데이터는 전송 불가</strong></td>
</tr>
<tr>
<td>➕ 별도 수단 필요</td>
<td>따라서 실제 데이터를 주고받으려면 공유 메모리, 파이프 등 <strong>다른 IPC 방식과 함께 사용</strong>해야 함</td>
</tr>
</tbody></table>
<h2 id="4-💡-실전-예제-dd-명령어에-시그널-보내기">4) 💡 실전 예제: <code>dd</code> 명령어에 시그널 보내기</h2>
<p>리눅스의 <code>dd</code> 명령어는 <strong>SIGUSR1 시그널</strong>을 받으면 <strong>복사 진행 상태를 출력</strong>하는 숨은 기능이 있어요.</p>
<h3 id="▶️-사용-예시">▶️ 사용 예시</h3>
<pre><code class="language-bash">$ dd if=/dev/zero of=test bs=1 count=1G &amp;
[1] 2992194        # 백그라운드 PID

$ DDPID=$!         # 최근 백그라운드 PID 저장

$ kill -SIGUSR1 $DDPID
# 출력:
8067496+8 records in  
8067496+0 records out  
8067496 bytes (8.1 MB, 7.7 MiB) copied, 15.3716 s, 525 kB/s</code></pre>
<h3 id="📌-해석">📌 해석:</h3>
<ul>
<li><code>kill -SIGUSR1</code>은 dd 프로세스에 &quot;상태 출력해줘!&quot;라고 신호를 보낸 거예요.</li>
<li>그 결과, 현재까지 몇 바이트를 복사했는지 실시간으로 보여줍니다.</li>
<li><code>SIGUSR1</code>을 여러 번 보내면 중간중간 진행 상황을 계속 알 수 있죠!</li>
</ul>
<blockquote>
<p><strong>시그널은 프로세스에게 '무언가 일어났어!'라고 알려주는 단순한 알림 도구</strong>이며,<br />복잡한 통신보다는 간단한 트리거용으로 사용하는 것이 좋습니다.</p>
</blockquote>
<p>좋습니다! 위 내용을 바탕으로 <strong>익명 파이프(Anonymous Pipe)</strong>와 <strong>명명된 파이프(Named Pipe)</strong>의 개념과 차이를 중심으로, 발표나 블로그용으로 보기 좋고 이해하기 쉬운 방식으로 정리해드릴게요.</p>
<hr />
<h1 id="🔄-파이프pipe로-하는-프로세스-간-통신">🔄 파이프(PIPE)로 하는 프로세스 간 통신</h1>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/3a100bc8-f937-4a77-a2d9-3d68a092c5e4/image.png" /></p>
<h2 id="1-파이프란">1) 파이프란?</h2>
<blockquote>
<p><strong>파이프(pipe)</strong>는 <strong>한 프로세스의 출력 데이터를 다른 프로세스의 입력으로 전달하는 통신 수단</strong>입니다.</p>
</blockquote>
<p>리눅스에서는 쉘에서 다음과 같은 명령어를 자주 사용하죠:</p>
<pre><code class="language-bash">$ free | awk '(NR==2){print $2}'</code></pre>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/8e5d77d9-dde9-494f-b655-ac90653a532a/image.png" /></p>
<ul>
<li><code>free</code>: 메모리 정보를 출력</li>
<li><code>|</code>: 파이프 → <code>free</code>의 출력을 <code>awk</code>의 입력으로 전달</li>
<li><code>awk</code>: 전달받은 입력에서 특정 필드만 추출</li>
</ul>
<blockquote>
<p>파이프를 사용하는 가장 친숙한 예를 들자면
bash 같은 셸에서 문자로 프로그램끼리 처리 결과를 연계하는 것</p>
</blockquote>
<p>이처럼 파이프는 <strong>간단하고 직관적인 단방향 통신 수단</strong>으로 시작했지만, <strong>프로세스 간 통신(IPC)</strong>에서도 중요한 역할을 합니다.</p>
<blockquote>
<p>쌍방통신을 위해서는 <strong>Write용 PIPE하나 Read PIPE하나를 따로 만들어야 합니다.</strong> read()와write()가 기본적으로 block 모드로 작동하기 때문에 프로세스가 read가 대기중이라면 read가 끝나기 전에는 write를 할 수가 없게 됩니다.</p>
</blockquote>
<h2 id="2-익명-파이프-anonymous-pipe">2) 익명 파이프 (Anonymous Pipe)</h2>
<h3 id="✅-개요">✅ 개요</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>특징</td>
<td>이름이 없는 임시적인 파이프</td>
</tr>
<tr>
<td>통신 방식</td>
<td>단방향</td>
</tr>
<tr>
<td>사용 조건</td>
<td><strong>공통 부모를 가진 프로세스</strong> 간 (ex. 부모-자식)</td>
</tr>
<tr>
<td>생성 함수</td>
<td><code>pipe()</code> 시스템 콜</td>
</tr>
<tr>
<td>데이터 흐름</td>
<td>FIFO (먼저 쓴 게 먼저 읽힘)</td>
</tr>
<tr>
<td>제한</td>
<td>같은 부모를 가진 프로세스 간에만 사용 가능</td>
</tr>
</tbody></table>
<h3 id="💡-예시">💡 예시</h3>
<pre><code class="language-python">r, w = os.pipe()
os.write(w, b'hello')
print(os.read(r, 5))  # b'hello'</code></pre>
<h3 id="⚠-단점">⚠ 단점</h3>
<ul>
<li><strong>쌍방향 통신이 어려움</strong>: write용, read용 파이프 <strong>2개 필요</strong></li>
<li><strong>block 모드</strong>: <code>read()</code>가 대기 중이면 <code>write()</code>도 막힙니다</li>
</ul>
<h2 id="3-명명된-파이프-named-pipe-fifo">3) 명명된 파이프 (Named Pipe, FIFO)</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/a824da1f-bf0b-4060-b78b-b91a93d5cfd3/image.png" /></p>
<h3 id="1-named-pipe의-개념">1) Named Pipe의 개념</h3>
<blockquote>
<p><strong>Named Pipe(명명된 파이프)</strong>는 이름이 부여된 파일을 통해 <strong>전혀 관련 없는 프로세스끼리도 통신</strong>할 수 있도록 해주는 리눅스 IPC(프로세스 간 통신) 방식입니다.</p>
</blockquote>
<ul>
<li><strong>단방향 통신</strong>을 지원합니다.</li>
<li><strong>FIFO (First-In-First-Out)</strong> 구조를 따릅니다.</li>
<li><strong>파일 시스템에 등록된 이름</strong>을 통해 프로세스들이 이 파이프를 공유할 수 있습니다.</li>
</ul>
<table>
<thead>
<tr>
<th>항목</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>특징</td>
<td><strong>이름이 있는 파이프 파일을 통해 통신</strong></td>
</tr>
<tr>
<td>통신 방식</td>
<td>단방향</td>
</tr>
<tr>
<td>사용 조건</td>
<td><strong>완전히 독립적인 프로세스</strong> 간에도 사용 가능</td>
</tr>
<tr>
<td>생성 방법</td>
<td><code>mkfifo()</code> 시스템 콜 또는 <code>mkfifo</code> 명령어</td>
</tr>
<tr>
<td>데이터 흐름</td>
<td>FIFO 구조</td>
</tr>
<tr>
<td>파일 시스템 상 존재</td>
<td>✔ (ex. <code>/tmp/mypipe</code>)</td>
</tr>
</tbody></table>
<h3 id="2-익명-파이프와의-차이점">2) 익명 파이프와의 차이점</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>익명 파이프 (Anonymous)</th>
<th>명명된 파이프 (Named)</th>
</tr>
</thead>
<tbody><tr>
<td>이름</td>
<td>없음</td>
<td>있음 (<code>/tmp/mypipe</code> 등)</td>
</tr>
<tr>
<td>사용 범위</td>
<td>부모-자식 관계의 프로세스만 사용 가능</td>
<td><strong>완전히 별개의 프로세스</strong>도 사용 가능</td>
</tr>
<tr>
<td>생성 방식</td>
<td><code>pipe()</code> 함수</td>
<td><code>mkfifo</code> 명령어 또는 <code>mkfifo()</code> 함수</td>
</tr>
<tr>
<td>존재 위치</td>
<td>메모리 내부</td>
<td><strong>파일 시스템 상의 파일로 생성됨</strong></td>
</tr>
</tbody></table>
<h3 id="3-named-pipe의-생성과-사용-흐름">3) Named Pipe의 생성과 사용 흐름</h3>
<h4 id="▶-생성">▶ 생성</h4>
<pre><code class="language-bash">$ mkfifo /tmp/mypipe</code></pre>
<ul>
<li>이 명령을 실행하면 <code>/tmp/mypipe</code> 라는 이름을 가진 파이프 파일이 생성됩니다.</li>
</ul>
<h4 id="▶-사용">▶ 사용</h4>
<p><strong>터미널 1 (쓰기 측)</strong></p>
<pre><code class="language-bash">$ echo &quot;안녕 프로세스 B!&quot; &gt; /tmp/mypipe</code></pre>
<p><strong>터미널 2 (읽기 측)</strong></p>
<pre><code class="language-bash">$ cat &lt; /tmp/mypipe
안녕 프로세스 B!</code></pre>
<h4 id="⚠-주의할-점">⚠ 주의할 점</h4>
<ul>
<li><code>read()</code>와 <code>write()</code>는 기본적으로 <strong>blocking 모드</strong>입니다.<br />즉, 한쪽이 준비되지 않으면 다른 쪽도 멈춘 상태가 됩니다.</li>
<li><strong>쌍방향 통신</strong>이 필요하다면 <strong>2개의 파이프</strong>를 따로 만들어야 합니다.<ul>
<li>예: <code>pipeAtoB</code>, <code>pipeBtoA</code></li>
</ul>
</li>
</ul>
<h4 id="✅-named-pipe의-핵심-요약">✅ Named Pipe의 핵심 요약</h4>
<ul>
<li><strong>이름 있는 파일을 이용한 단방향 통신 수단</strong></li>
<li><strong>전혀 다른 프로세스 간 통신 가능</strong></li>
<li><strong>빠르고 단순하지만</strong> 데이터를 전달하려면 읽기/쓰기 블로킹을 고려해야 함</li>
</ul>
<p>출처: <a href="https://heeonii.tistory.com/13">https://heeonii.tistory.com/13</a> [우당탕탕 히온이네:티스토리]</p>
<h3 id="💡-예시-1">💡 예시</h3>
<pre><code class="language-bash"># 파이프 생성
$ mkfifo mypipe

# 터미널 1
$ echo &quot;Hello&quot; &gt; mypipe

# 터미널 2
$ cat &lt; mypipe
Hello</code></pre>
<h3 id="⚠-단점-1">⚠ 단점</h3>
<ul>
<li>익명 파이프와 마찬가지로 <strong>쌍방향 통신을 위해 2개 필요</strong></li>
<li><strong>블로킹(blocking)</strong> 특성: 읽기/쓰기가 서로 기다림</li>
</ul>
<h2 id="4-두-파이프-비교-정리">4) 두 파이프 비교 정리</h2>
<table>
<thead>
<tr>
<th>항목</th>
<th>익명 파이프 (Anonymous Pipe)</th>
<th>명명된 파이프 (Named Pipe)</th>
</tr>
</thead>
<tbody><tr>
<td>이름</td>
<td>없음</td>
<td>있음 (파일 시스템에 생성)</td>
</tr>
<tr>
<td>생성 방식</td>
<td><code>pipe()</code></td>
<td><code>mkfifo()</code> 또는 명령어 <code>mkfifo</code></td>
</tr>
<tr>
<td>사용 범위</td>
<td><strong>부모-자식 등 관련된 프로세스</strong></td>
<td><strong>전혀 다른 프로세스 간에도 사용 가능</strong></td>
</tr>
<tr>
<td>방향성</td>
<td>단방향 (쌍방향은 2개 필요)</td>
<td>단방향 (쌍방향은 2개 필요)</td>
</tr>
<tr>
<td>연결</td>
<td>파일 기술자(File Descriptor) 기반</td>
<td>파일 경로(Path) 기반</td>
</tr>
</tbody></table>
<p><strong>익명 파이프는 관련된 프로세스끼리, 명명된 파이프는 이름만 알면 누구나 통신 가능!</strong></p>
<p>출처 : <a href="https://heeonii.tistory.com/13">https://heeonii.tistory.com/13</a></p>
<blockquote>
<p>그렇다면 쌍방향 통신이 가능한 구조는? 소켓</p>
</blockquote>
<h1 id="보충-정리--🔁-파이프에서-쌍방향-통신-가능한가요">보충 정리 : 🔁 파이프에서 쌍방향 통신 가능한가요?</h1>
<h2 id="1-기본-파이프익명명명된-파이프">1) 기본 파이프(익명/명명된 파이프)</h2>
<table>
<thead>
<tr>
<th>항목</th>
<th>기본 특징</th>
</tr>
</thead>
<tbody><tr>
<td>통신 방향</td>
<td><strong>단방향</strong> (한쪽은 쓰기, 한쪽은 읽기만 가능)</td>
</tr>
<tr>
<td>쌍방향 구현</td>
<td><code>읽기용 파이프</code> + <code>쓰기용 파이프</code> <strong>2개 만들어야 함</strong></td>
</tr>
<tr>
<td>차단 특성</td>
<td>기본적으로 <code>read()</code> / <code>write()</code>는 <strong>블로킹 I/O</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>✅ 그래서 기본 <code>pipe()</code> 또는 <code>mkfifo()</code>만 사용하면 진정한 쌍방향 통신은 <strong>불가능</strong>합니다.</p>
</blockquote>
<h2 id="2-진짜-쌍방향-통신이-가능한-구조는">2) 진짜 쌍방향 통신이 가능한 구조는?</h2>
<h3 id="✅-유닉스-도메인-소켓unix-domain-socket">✅ 유닉스 도메인 소켓(Unix Domain Socket)</h3>
<blockquote>
<p>파이프보다 한 단계 진화한 구조로, <strong>하나의 연결만으로 양방향 통신이 가능</strong>합니다.</p>
</blockquote>
<table>
<thead>
<tr>
<th>항목</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>양방향 통신</td>
<td>O (한 개의 소켓으로 read/write 모두 가능)</td>
</tr>
<tr>
<td>프로세스 관계</td>
<td>관계 없는 프로세스끼리도 사용 가능</td>
</tr>
<tr>
<td>구현 방식</td>
<td><code>socketpair()</code> 또는 <code>AF_UNIX</code> 소켓</td>
</tr>
<tr>
<td>성능</td>
<td>빠르고, 메모리 복사도 효율적</td>
</tr>
</tbody></table>
<p>📌 리눅스의 <strong><code>socketpair(AF_UNIX, SOCK_STREAM)</code></strong> 함수는 실제로 <strong>양방향 파이프를 구현한 것</strong>으로 보시면 됩니다.</p>
<h2 id="3-socketpair가-구현된-예-c-예시">3) socketpair()가 구현된 예 (C 예시)</h2>
<pre><code class="language-c">int fd[2];
socketpair(AF_UNIX, SOCK_STREAM, 0, fd);

// fd[0]과 fd[1] 모두 읽기/쓰기 가능!</code></pre>
<blockquote>
<p>위와 같은 구조는 파이프처럼 동작하지만, 양방향 통신이 기본입니다.</p>
</blockquote>
<h2 id="✅-결론">✅ 결론</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/20139078-ebe8-4ef5-af52-038893a7e719/image.png" /></p>
<blockquote>
<p><strong>기본 PIPE는 단방향이지만</strong>,  
<strong>쌍방향이 필요하다면</strong> 다음 2가지 방법 중 하나를 써야 해요:</p>
</blockquote>
<ol>
<li><strong>PIPE를 2개 만들어서</strong> 각각 읽기/쓰기에 사용  </li>
<li><strong>Unix Domain Socket을 사용해서</strong> 양방향으로 처리</li>
</ol>
<h1 id="🧵-리눅스에서의-소켓socket은">🧵 리눅스에서의 소켓(Socket)은?</h1>
<h2 id="1-소켓이란">1) 소켓이란?</h2>
<blockquote>
<p>소켓은 <strong>프로세스 간 통신(IPC)</strong> 또는 <strong>네트워크 통신</strong>을 가능하게 해주는 <strong>양방향 통신 인터페이스</strong>입니다.</p>
</blockquote>
<h3 id="소켓은-크게-2가지로-나뉩니다">소켓은 크게 2가지로 나뉩니다:</h3>
<table>
<thead>
<tr>
<th>종류</th>
<th>용도</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>네트워크 소켓</strong></td>
<td>원격 통신</td>
<td>TCP/UDP를 이용한 <strong>IP 기반 통신</strong></td>
</tr>
<tr>
<td><strong>유닉스 도메인 소켓</strong></td>
<td>로컬 통신</td>
<td>같은 머신 내의 <strong>프로세스 간 통신</strong></td>
</tr>
</tbody></table>
<h2 id="2-리눅스에서-지원하는-대표-소켓들">2) 리눅스에서 지원하는 대표 소켓들</h2>
<table>
<thead>
<tr>
<th>소켓 종류</th>
<th>프로토콜</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>AF_INET</code></td>
<td>TCP/UDP</td>
<td><strong>IPv4 네트워크 통신</strong></td>
</tr>
<tr>
<td><code>AF_INET6</code></td>
<td>TCP/UDP</td>
<td><strong>IPv6 네트워크 통신</strong></td>
</tr>
<tr>
<td><code>AF_UNIX</code></td>
<td>local</td>
<td><strong>유닉스 도메인 소켓</strong> (같은 머신 내 프로세스 간 통신)</td>
</tr>
<tr>
<td><code>AF_NETLINK</code></td>
<td>커널 ↔ 사용자 공간</td>
<td>주로 리눅스 커널과 사용자 공간 간 메시지 전달</td>
</tr>
<tr>
<td><code>AF_PACKET</code></td>
<td>저수준 패킷 접근</td>
<td>네트워크 인터페이스 수준의 패킷 통신</td>
</tr>
</tbody></table>
<h2 id="3-리눅스에서-소켓-사용하는-방식은">3) 리눅스에서 소켓 사용하는 방식은?</h2>
<blockquote>
<p>C, Python, Go, Java 등 대부분의 언어에서 리눅스 소켓 API를 사용할 수 있어요!</p>
</blockquote>
<pre><code class="language-c">// C에서 소켓 생성 예시
int sockfd = socket(AF_INET, SOCK_STREAM, 0);</code></pre>
<pre><code class="language-python"># Python에서 TCP 클라이언트 예시
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&quot;127.0.0.1&quot;, 8080))</code></pre>
<p>리눅스는 이와 같은 소켓을 <strong>시스템 콜로 관리</strong>하며, <code>/proc</code> 시스템에서도 <strong>소켓 정보</strong>를 확인할 수 있습니다.</p>
<h2 id="4-유닉스-도메인-소켓도-리눅스에서-완벽-지원">4) 유닉스 도메인 소켓도 리눅스에서 완벽 지원</h2>
<ul>
<li><code>AF_UNIX</code>, <code>AF_LOCAL</code>로 정의</li>
<li><strong><code>/tmp/mysocket</code></strong> 같은 <strong>실제 파일 경로</strong>를 사용해서 프로세스 간 통신 가능</li>
<li><code>socketpair()</code>로 <strong>양방향 파이프 대체</strong> 가능</li>
</ul>
<pre><code class="language-c">int fds[2];
socketpair(AF_UNIX, SOCK_STREAM, 0, fds);
// fds[0], fds[1] → 서로 읽고 쓰기 가능</code></pre>
<blockquote>
<p><strong>리눅스는 네트워크든 로컬이든, 다양한 종류의 소켓 통신을 완벽하게 지원합니다.</strong><br />파이프보다 강력하고 유연한 IPC 수단으로 자주 사용돼요!</p>
</blockquote>
<h1 id="그-외-ipc">그 외 IPC</h1>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/03ac11bf-a157-404a-b572-d226ad2d8f09/image.png" />
물론입니다! 요청하신 <strong>Message Queue</strong>, <strong>Shared Memory</strong>, <strong>Memory Map</strong> 세 가지는 모두 <strong>리눅스에서 지원되는 IPC (Inter-Process Communication, 프로세스 간 통신)</strong> 방식입니다. 각각의 개념을 명확히 정리하고, 리눅스에서 어떻게 활용되는지도 함께 설명드릴게요.</p>
<hr />
<h1 id="📬-리눅스-ipc-메시지-큐-공유-메모리-메모리-맵-정리">📬 리눅스 IPC: 메시지 큐, 공유 메모리, 메모리 맵 정리</h1>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/80e64f3b-5ad9-418c-a4cd-b56886d96304/image.png" /></p>
<blockquote>
<p>출처 : <a href="https://heeonii.tistory.com/13">https://heeonii.tistory.com/13</a></p>
</blockquote>
<h2 id="message-queue-메시지-큐">Message Queue (메시지 큐)</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/0e67d8de-e826-4506-b487-14f4bc4fe745/image.png" /></p>
<h3 id="✅-개념">✅ 개념</h3>
<ul>
<li>파이프가 단순히 데이터를 흘려보내는 통로라면, <strong>메시지 큐는 '라벨이 붙은 컨베이어 벨트'</strong>처럼 동작합니다.</li>
<li>각 메시지는 <strong><code>msgtype</code>이라는 ID 값</strong>을 가지고 있어, 여러 프로세스가 동시에 메시지를 주고받을 수 있어요.</li>
<li>구조체 단위로 데이터를 전송하며, <strong>FIFO 방식</strong>으로 처리됩니다.</li>
</ul>
<blockquote>
<p>입출력 방식으로는 익명 PIPE와 동일하지만, 커널에서 관리하며 메모리를 사용한 PIPE 입니다. 구조체 기반으로 통신을 합니다.</p>
</blockquote>
<h3 id="✅-리눅스에서-어떻게-쓰이나요">✅ 리눅스에서 어떻게 쓰이나요?</h3>
<ul>
<li>리눅스에서는 <code>msgget()</code>, <code>msgsnd()</code>, <code>msgrcv()</code>, <code>msgctl()</code> 등의 <strong>시스템 콜</strong>을 통해 메시지 큐를 생성하고 관리합니다.</li>
<li>커널이 메시지 큐를 관리하며, <strong>한계(크기 제한)</strong>가 있기 때문에 메시지 큐가 꽉 차면 <code>msgsnd()</code>가 블로킹됩니다.</li>
</ul>
<h3 id="✅-특징-요약">✅ 특징 요약</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>통신 방향</td>
<td>단방향 (일반적으로)</td>
</tr>
<tr>
<td>데이터 단위</td>
<td>구조체 기반 메시지</td>
</tr>
<tr>
<td>관리 주체</td>
<td>커널</td>
</tr>
<tr>
<td>특징</td>
<td>msgtype 기반으로 다양한 데이터 분기 처리 가능</td>
</tr>
</tbody></table>
<h2 id="memory-map-메모리-맵">Memory Map (메모리 맵)</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/d722dd55-ada8-428d-b99a-c56423a75cbc/image.png" /></p>
<h3 id="✅-개념-1">✅ 개념</h3>
<ul>
<li>Memory Map은 공유 메모리와 유사하지만, <strong>파일을 메모리에 매핑해서 공유</strong>한다는 점에서 다릅니다.</li>
<li>예를 들어, 두 프로세스가 <strong>같은 파일을 mmap()</strong>해서 메모리에 올리면, <strong>서로 같은 파일 내용을 공유</strong>하게 됩니다.</li>
<li>커널이 내부적으로 <strong>페이지 단위로 메모리-파일 매핑</strong>을 효율적으로 관리합니다.</li>
</ul>
<h3 id="✅-리눅스에서-어떻게-쓰이나요-1">✅ 리눅스에서 어떻게 쓰이나요?</h3>
<p>=<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/e6328caa-cc29-417b-a7a2-e6bd410c28ff/image.png" /></p>
<ul>
<li><code>mmap()</code> 시스템 콜을 이용해서 파일을 특정 가상 주소 영역에 맵핑합니다.</li>
<li>대부분의 운영체제는 <strong>실행 파일도 메모리 맵 방식으로 로딩</strong>합니다. (<code>execve()</code> 내부적으로 사용됨)</li>
<li>공유 모드(<code>MAP_SHARED</code>)와 개인 모드(<code>MAP_PRIVATE</code>)를 선택할 수 있어요.</li>
</ul>
<h3 id="✅-특징-요약-1">✅ 특징 요약</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>통신 방향</td>
<td>양방향 (MAP_SHARED 사용 시)</td>
</tr>
<tr>
<td>데이터 단위</td>
<td>파일 기반</td>
</tr>
<tr>
<td>관리 주체</td>
<td>커널 (파일 시스템 + 메모리 매핑)</td>
</tr>
<tr>
<td>특징</td>
<td>대용량 데이터 공유에 적합, 파일 기반</td>
</tr>
</tbody></table>
<h2 id="🔐-세마포어-semaphore">🔐 세마포어 (Semaphore)</h2>
<p><strong>세마포어</strong>는 리눅스에서 <strong>프로세스 간 동기화</strong>를 위해 사용되는 IPC 메커니즘입니다. 특히, <strong>공유 자원에 대한 접근을 제어</strong>하여 <strong>동시성 문제</strong>를 방지하는 데 유용합니다.</p>
<h3 id="✅-리눅스에서의-세마포어-사용">✅ 리눅스에서의 세마포어 사용</h3>
<p>리눅스에서는 두 가지 유형의 세마포어를 지원합니다:</p>
<ol>
<li><strong>System V 세마포어</strong>: <code>semget()</code>, <code>semop()</code>, <code>semctl()</code> 등의 시스템 콜을 사용합니다.</li>
<li><strong>POSIX 세마포어</strong>:<ul>
<li><strong>Unnamed 세마포어</strong>: <code>sem_init()</code>, <code>sem_wait()</code>, <code>sem_post()</code>, <code>sem_destroy()</code> 등을 사용하며, 주로 <strong>스레드 간 동기화</strong>에 활용됩니다.</li>
<li><strong>Named 세마포어</strong>: <code>sem_open()</code>, <code>sem_close()</code>, <code>sem_unlink()</code> 등을 사용하며, <strong>프로세스 간 동기화</strong>에 적합합니다.</li>
</ul>
</li>
</ol>
<h3 id="🔧-예제">🔧 예제</h3>
<pre><code class="language-c">#include &lt;semaphore.h&gt;
#include &lt;pthread.h&gt;

sem_t sem;

void* thread_func(void* arg) {
    sem_wait(&amp;sem);
    // 임계 영역
    sem_post(&amp;sem);
    return NULL;
}

int main() {
    sem_init(&amp;sem, 0, 1);
    pthread_t t1, t2;
    pthread_create(&amp;t1, NULL, thread_func, NULL);
    pthread_create(&amp;t2, NULL, thread_func, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    sem_destroy(&amp;sem);
    return 0;
}</code></pre>
<p>이 예제는 두 개의 스레드가 세마포어를 사용하여 임계 영역에 대한 접근을 제어하는 모습을 보여줍니다.</p>
<h2 id="📡-원격-프로시저-호출-rpc">📡 원격 프로시저 호출 (RPC)</h2>
<p><strong>RPC(Remote Procedure Call)</strong>는 <strong>다른 주소 공간에 있는 프로시저나 함수를 호출</strong>할 수 있게 해주는 통신 메커니즘입니다. 이를 통해 <strong>분산 시스템</strong>에서 <strong>프로세스 간 통신</strong>을 간편하게 구현할 수 있습니다.</p>
<h3 id="✅-리눅스에서의-rpc-사용">✅ 리눅스에서의 RPC 사용</h3>
<p>리눅스에서는 다양한 RPC 구현체를 사용할 수 있습니다:</p>
<ul>
<li><strong>ONC RPC</strong>: 리눅스에서 기본적으로 제공하는 RPC 구현체로, <code>rpcgen</code> 도구를 사용하여 인터페이스를 정의하고 코드를 생성합니다.</li>
<li><strong>gRPC</strong>: Google에서 개발한 고성능, 범용 오픈 소스 RPC 프레임워크로, HTTP/2와 Protocol Buffers를 기반으로 합니다.</li>
</ul>
<h3 id="🔧-예제-onc-rpc">🔧 예제 (ONC RPC)</h3>
<ol>
<li><strong>인터페이스 정의 (<code>example.x</code>)</strong>:</li>
</ol>
<pre><code class="language-c">program EXAMPLE_PROG {
    version EXAMPLE_VERS {
        int add(int, int) = 1;
    } = 1;
} = 0x20000001;</code></pre>
<ol start="2">
<li><strong>코드 생성</strong>:</li>
</ol>
<pre><code class="language-bash">rpcgen example.x</code></pre>
<ol start="3">
<li><strong>서버 및 클라이언트 구현</strong>: 생성된 스텁 코드를 기반으로 서버와 클라이언트 코드를 작성합니다.</li>
</ol>
<p>이러한 방식으로 리눅스에서 RPC를 구현하여 프로세스 간 통신을 수행할 수 있습니다.</p>
<h2 id="📋-ipc-방식-요약표">📋 IPC 방식 요약표</h2>
<table>
<thead>
<tr>
<th>IPC 종류</th>
<th>PIPE</th>
<th>Named PIPE</th>
<th>Message Queue</th>
<th>Shared Memory</th>
<th>Memory Map</th>
<th>Socket</th>
<th>Semaphore</th>
<th>RPC</th>
</tr>
</thead>
<tbody><tr>
<td><strong>용도</strong></td>
<td>부모 자식 간 단방향 통신</td>
<td>다른 프로세스와 단방향 통신</td>
<td>다른 프로세스와 단방향 통신</td>
<td>다른 프로세스와 <strong>양방향 통신</strong></td>
<td>다른 프로세스와 <strong>양방향 통신</strong></td>
<td>다른 시스템 간 <strong>양방향 통신</strong></td>
<td><strong>공유 자원 접근 제어 및 동기화</strong></td>
<td><strong>다른 시스템 함수 원격 호출</strong></td>
</tr>
<tr>
<td><strong>공유 매개체</strong></td>
<td>파일</td>
<td>파일</td>
<td>메모리</td>
<td>메모리</td>
<td>파일 + 메모리</td>
<td>소켓</td>
<td>메모리 (카운터 기반)</td>
<td>네트워크 (TCP/IP, gRPC 등)</td>
</tr>
<tr>
<td><strong>통신단위</strong></td>
<td>stream</td>
<td>stream</td>
<td>구조체</td>
<td>구조체</td>
<td>페이지</td>
<td>stream</td>
<td>정수 (카운터, 플래그)</td>
<td>함수 호출 (요청/응답 메시지)</td>
</tr>
<tr>
<td><strong>통신방향</strong></td>
<td>단방향</td>
<td>단방향</td>
<td>단방향</td>
<td><strong>양방향</strong></td>
<td><strong>양방향</strong></td>
<td><strong>양방향</strong></td>
<td><strong>제어 중심 (데이터 전달 X)</strong></td>
<td><strong>양방향</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>Semaphore</strong>는 데이터를 직접 전달하지 않지만, <strong>임계 영역 보호</strong>와 <strong>동기화</strong>에 핵심적인 IPC 방식입니다.</li>
<li><strong>RPC</strong>는 다른 컴퓨터나 프로세스에서 실행 중인 함수를 마치 <strong>내 함수처럼 호출</strong>할 수 있게 해주는 IPC입니다. <strong>분산 시스템에서 매우 중요</strong>하게 사용됩니다.</li>
</ul>
<h1 id="🔒-리눅스에서의-배타적-제어mutual-exclusion">🔒 리눅스에서의 배타적 제어(Mutual Exclusion)</h1>
<h2 id="✅-배경-설명">✅ 배경 설명</h2>
<p>운영체제에서 <strong>동시에 하나 이상의 프로세스가 자원에 접근</strong>하려 할 때, 충돌이 발생할 수 있습니다.</p>
<p>예시로, 우분투에서 사용하는 <strong>APT 패키지 시스템</strong>이 있어요:</p>
<ul>
<li>두 개 이상의 <code>apt</code> 명령이 <strong>동시에 실행되면 데이터베이스 손상</strong>이 발생할 수 있음</li>
<li>이를 막기 위해 시스템은 <strong>한 번에 하나의 <code>apt</code>만 실행되도록 강제</strong>합니다</li>
</ul>
<p>이러한 메커니즘을 우리는 <strong>배타적 제어(Exclusive Control)</strong> 또는 <strong>상호 배제(Mutual Exclusion)</strong> 라고 부릅니다.</p>
<h2 id="🧪-실험-파일-증가-스크립트-incsh">🧪 실험: 파일 증가 스크립트 <code>inc.sh</code></h2>
<pre><code class="language-bash">#!/bin/bash
TMP=$(cat count)
echo $((TMP + 1)) &gt; count</code></pre>
<ul>
<li>이 스크립트는 <code>count</code> 파일을 읽고 값에 1을 더합니다.</li>
<li>1000번 순차 실행 → <strong>정상적으로 1000이 됨</strong></li>
<li>그러나 <strong>병렬(&amp;)로 실행하면 예상치 못한 결과 (예: 18)</strong> 가 출력됨</li>
</ul>
<h3 id="왜-이런-문제가-발생할까요">왜 이런 문제가 발생할까요?</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/030acabb-f449-4fb1-8ebb-cf3ef32378d5/image.png" /></p>
<pre><code class="language-plaintext">A 프로세스가 count 파일에서 읽음 → 값 0
B 프로세스도 count 파일에서 읽음 → 값 0
A가 count 파일에 1 씀
B도 count 파일에 1 씀
→ 최종 결과는 '1' (둘 다 1씩 더했지만 실제 증가는 1)</code></pre>
<p>이처럼 파일 입출력이 <strong>아토믹하지 않아서 중간에 끼어드는 경우가 생깁니다.</strong></p>
<h3 id="💥-아토믹하지-않아서가-뭘까">💥 아토믹하지 않아서가 뭘까?</h3>
<p><strong>아토믹(Atomic)</strong>이란 말은 원자처럼 <strong>쪼갤 수 없는 단위의 동작</strong>이라는 뜻이에요.</p>
<blockquote>
<p>즉, <strong>중간에 끊기거나 다른 작업이 끼어들 수 없는</strong> 연산을 말해요.</p>
</blockquote>
<p><strong>📦 비유해볼게요</strong></p>
<ul>
<li>어떤 사람이 <strong>문을 열고 들어가서 닫는다</strong>는 작업을 한다고 해봐요.</li>
<li>그런데 <strong>문 열기</strong> → <strong>들어가기</strong> → <strong>문 닫기</strong>가 <strong>하나의 완전한 일(아토믹)</strong>이어야 안전하죠?</li>
</ul>
<p>그런데 <strong>중간에 다른 사람이 끼어들 수 있다면</strong> 문제가 생기겠죠:</p>
<blockquote>
<p>A가 문을 열었는데 B가 먼저 들어와버림<br />→ A, B 둘 다 들어가게 됨 → 충돌 발생</p>
</blockquote>
<p><strong>💻 그럼 파일 입출력에서 왜 문제가 되나요?</strong></p>
<p>자, <code>inc.sh</code> 예시를 다시 보면:</p>
<pre><code class="language-bash">TMP=$(cat count)       # 1️⃣ 파일 읽기
echo $((TMP + 1)) &gt; count   # 2️⃣ 1 더해서 다시 쓰기</code></pre>
<p>이 작업은 <strong>겉보기엔 하나처럼 보이지만</strong>, 내부적으로는 <strong>두 개의 독립된 작업</strong>이에요.</p>
<blockquote>
<p>즉, <strong>읽고(cat)</strong> → <strong>계산</strong> → <strong>쓰고(echo)</strong> 이 3단계가 <strong>하나의 아토믹 작업이 아닌 거예요</strong>.</p>
</blockquote>
<p>그래서 중간에 다른 프로세스가 <strong>끼어들 수 있습니다!</strong></p>
<p><strong>🧪 실제 문제 상황</strong></p>
<pre><code class="language-bash"># 두 개의 프로세스가 동시에 실행될 때

A: cat count  # count = 0 읽음
B: cat count  # count = 0 읽음
A: echo 1 &gt; count
B: echo 1 &gt; count</code></pre>
<blockquote>
<p>💥 실제로는 두 번 증가했어야 하는데,
→ 결과는 <code>1</code>만 반영됨 (B가 A를 덮어씀)</p>
</blockquote>
<blockquote>
<p>파일 입출력은 기본적으로 <strong>&quot;아토믹하지 않다&quot;</strong><br />→ 즉, <strong>중간에 다른 프로세스가 끼어들 수 있어서 충돌이 생길 수 있음</strong><br />→ 그래서 <code>flock</code>, <code>semaphore</code>, <code>mutex</code> 같은 <strong>락 도구</strong>로 보호해야 함</p>
</blockquote>
<h2 id="🚫-잘못된-배타적-제어-예시-inc-wrong-locksh">🚫 잘못된 배타적 제어 예시: <code>inc-wrong-lock.sh</code></h2>
<pre><code class="language-bash">#!/bin/bash
while; do
  if [ ! -e lock ]; then  # 1) 락 없네?
    break                 # 2) 들어가자!
  fi
done

touch lock               # 3) 락 걸기 (늦었어요!)
TMP=$(cat count)
echo $((TMP + 1)) &gt; count
rm -f lock
</code></pre>
<ul>
<li>이 방식은 <code>lock</code> 파일 존재 여부를 검사한 뒤 생성하는 방식</li>
<li>하지만 <strong><code>touch lock</code> 전까지 다른 프로세스가 끼어들 수 있음</strong></li>
<li>결국 <strong>동시 접근 방지에 실패</strong></li>
</ul>
<table>
<thead>
<tr>
<th>순서</th>
<th>A 프로세스</th>
<th>B 프로세스</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>lock 파일 존재 여부 확인 → 없음</td>
<td>lock 파일 존재 여부 확인 → 없음</td>
</tr>
<tr>
<td>2</td>
<td>&quot;좋아, 들어간다!&quot;</td>
<td>&quot;좋아, 나도 들어간다!&quot;</td>
</tr>
<tr>
<td>3</td>
<td><code>touch lock</code></td>
<td><code>touch lock</code></td>
</tr>
<tr>
<td>4</td>
<td>count 읽고 1 더함</td>
<td>count 읽고 1 더함</td>
</tr>
<tr>
<td>5</td>
<td>같은 값을 count에 씀</td>
<td>같은 값을 count에 씀</td>
</tr>
</tbody></table>
<blockquote>
<p>결국 <strong>둘 중 하나의 결과만 반영되고, 나머지는 덮어쓰기 당함!</strong></p>
</blockquote>
<p>이런 문제를 피하려면 count 값을 읽어서 1을 더하고 그 값을 count 파일에 다시 쓰는 처리가 *<em>한 번에 하나의 inc.sh 프로그램에서만 실행되도록 해야 합니다. *</em></p>
<blockquote>
<p>이걸 실제로 구현하는 방법이 상호 배제입니다</p>
</blockquote>
<h2 id="✅-올바른-배타적-제어-flock-사용-예시">✅ 올바른 배타적 제어: <code>flock</code> 사용 예시</h2>
<h3 id="✔-flock을-이용한-inc-locksh">✔ <code>flock</code>을 이용한 <code>inc-lock.sh</code></h3>
<pre><code class="language-bash">#!/bin/bash
flock lock ./inc.sh</code></pre>
<ul>
<li><code>flock</code> 명령은 <strong>파일에 락을 설정</strong>해서 중복 실행을 막아줌</li>
<li>여러 프로세스가 동시에 접근해도 <strong>자동으로 순서대로 실행됨</strong></li>
<li>결국 실행 결과는 <strong>정확히 1000</strong></li>
</ul>
<h2 id="🧠-개념-정리">🧠 개념 정리</h2>
<table>
<thead>
<tr>
<th>용어</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td><strong>크리티컬 섹션</strong>(임계구역)</td>
<td>동시에 실행되면 안 되는 코드 구간</td>
</tr>
<tr>
<td><strong>아토믹 처리</strong></td>
<td>외부에서 봤을 때 <strong>하나의 처리처럼 보이는 연산</strong></td>
</tr>
<tr>
<td><strong>File Lock</strong></td>
<td>특정 파일에 락을 걸어 <strong>다른 프로세스의 접근을 제어</strong></td>
</tr>
</tbody></table>
<ul>
<li>크리티컬 섹션 : inc.sh 프로그램이라면 count 값을 읽어서 1을 더하고 count 파일에 다시 쓰는 처리에 해당합니다.</li>
</ul>
<h2 id="📌-리눅스에서-배타적-제어를-구현하는-방법들">📌 리눅스에서 배타적 제어를 구현하는 방법들</h2>
<table>
<thead>
<tr>
<th>방식</th>
<th>리눅스 지원 여부</th>
<th>특징</th>
</tr>
</thead>
<tbody><tr>
<td><code>flock()</code></td>
<td>✅ 지원</td>
<td>가장 간단한 파일 기반 락</td>
</tr>
<tr>
<td><code>fcntl()</code></td>
<td>✅ 지원</td>
<td>좀 더 정밀한 락 제어 가능</td>
</tr>
<tr>
<td><code>semaphore</code></td>
<td>✅ 지원</td>
<td>메모리 동기화 기반 락</td>
</tr>
<tr>
<td><code>pthread_mutex</code></td>
<td>✅ (스레드 전용)</td>
<td>스레드 간 락을 위한 구조체</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>리눅스에서는 <code>flock</code> 같은 도구를 사용하여 중요한 작업을 &quot;한 번에 하나&quot;만 처리되도록 배타적 제어를 구현할 수 있습니다.</strong></p>
</blockquote>
<h1 id="🧠-파일-락file-lock은-어떻게-구현될까">🧠 파일 락(File Lock)은 어떻게 구현될까?</h1>
<h2 id="1-고급-언어-수준의-파일-락-vs-cpu-수준-락">1) 고급 언어 수준의 파일 락 vs CPU 수준 락</h2>
<p>일반적으로 우리는 <strong><code>flock()</code></strong>, <strong><code>fcntl()</code></strong>, <strong><code>pthread_mutex_lock()</code></strong> 등을 사용해 파일이나 메모리를 락으로 보호합니다. 하지만 <strong>이러한 함수들 내부적으로는 CPU가 제공하는 락 명령어</strong>를 사용합니다.</p>
<p>즉, <strong>진짜 락은 기계어 수준에서 구현</strong>되며, 우리가 사용하는 고급 API는 <strong>그 위에 만들어진 추상화 계층</strong>일 뿐이에요.</p>
<h2 id="2-락을-기계어로-구현하면">2) 락을 기계어로 구현하면?</h2>
<p>책에서는 가상의 어셈블리 언어를 통해 간단한 락 메커니즘을 설명합니다. 이 예시를 통해 <strong>아토믹(atomic)하지 않으면 어떤 문제가 생기는지</strong> 보여줍니다.</p>
<h3 id="🧾-가상-어셈블리-코드-코드-05-07">🧾 가상 어셈블리 코드 (코드 05-07)</h3>
<pre><code class="language-asm">start:
  load r0, mem       ; mem에서 값을 r0에 로드
  test r0            ; r0이 0인지 확인
  jmpz enter         ; 0이면 (lock 안 걸림) → enter
  jmp start          ; 그렇지 않으면 → 다시 시작

enter:
  store mem, 1       ; lock 걸기
  &lt;크리티컬 섹션 실행&gt;
  store mem, 0       ; lock 해제</code></pre>
<blockquote>
<p>이 방식은 <code>mem</code>이 0인지 읽고(lock 상태 확인), 1로 바꾸고(lock 설정), 크리티컬 섹션 실행 후 0으로 돌리는 구조입니다.</p>
</blockquote>
<h2 id="3-⚠-문제점-이-방식은-안전하지-않다">3) ⚠ 문제점: 이 방식은 안전하지 않다!</h2>
<p>위 코드는 겉보기에 잘 동작할 것 같지만, 실제로는 문제가 많습니다. 왜일까요?</p>
<ul>
<li><code>load</code> → <code>test</code> → <code>store</code> 과정이 <strong>분리되어 있어서 중간에 끼어들 수 있음</strong></li>
<li>예를 들어 두 개의 스레드가 거의 동시에 <code>load</code>를 실행하면, <strong>둘 다 mem = 0으로 판단</strong>하고 락을 획득하려고 할 수 있음</li>
<li>결과적으로 <strong>두 스레드가 동시에 크리티컬 섹션에 진입하는 문제 발생</strong> → <strong>락 실패!</strong></li>
</ul>
<h2 id="4-해결책-아토믹-명령어-사용">4) 해결책: 아토믹 명령어 사용</h2>
<p>대부분의 현대 CPU는 이런 문제를 방지하기 위해 <strong>&quot;아토믹 연산(Atomic Instruction)&quot;</strong>을 제공합니다.</p>
<p>대표적인 예:</p>
<table>
<thead>
<tr>
<th>명령어 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>Test and Set</code></td>
<td>값을 확인한 후 변경</td>
</tr>
<tr>
<td><code>Compare and Swap</code></td>
<td>조건에 맞으면 값을 변경</td>
</tr>
<tr>
<td><code>Exchange</code> (<code>XCHG</code>)</td>
<td>두 값을 교환 (락 구현에 자주 사용)</td>
</tr>
</tbody></table>
<p>이러한 명령어들은 <strong>중간에 끼어들 수 없도록 CPU 수준에서 완전한 원자성 보장</strong>을 제공합니다.</p>
<h2 id="5-참고-알고리즘-피터슨의-알고리즘-petersons-algorithm">5) 참고 알고리즘: 피터슨의 알고리즘 (Peterson’s Algorithm)</h2>
<ul>
<li>공유 메모리 기반에서 <strong>두 개의 프로세스 간 락을 구현하는 고전적 알고리즘</strong></li>
<li>현대 CPU 아토믹 명령이 등장하기 전까지 이론적으로 중요한 기초였어요</li>
<li>지금도 <strong>동기화의 개념적 이해</strong>에 매우 유용한 자료입니다</li>
</ul>
<blockquote>
<p><code>Peterson's algorithm</code>은 <strong>busy waiting</strong>을 기반으로 하며, 교육적 목적에서 주로 사용됩니다.</p>
</blockquote>
<blockquote>
<p><strong>진짜 락은 CPU 내부에서 아토믹 명령어로 구현되며, 고급 언어의 락 함수들은 이 아토믹 연산 위에 만들어진 추상화 도구입니다.</strong></p>
</blockquote>
<h1 id="🧠-멀티프로세스와-멀티스레드-그리고-커널-스레드-vs-사용자-스레드">🧠 멀티프로세스와 멀티스레드, 그리고 커널 스레드 vs 사용자 스레드</h1>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/1cb3112f-c27b-43ae-ad51-0cf7477db6de/image.png" /></p>
<h2 id="1️⃣-병렬-프로그래밍의-두-가지-방식">1️⃣ 병렬 프로그래밍의 두 가지 방식</h2>
<p>현대 CPU는 멀티코어로 구성되어 있어, <strong>여러 작업을 동시에 수행할 수 있는 환경</strong>이 마련되어 있습니다.</p>
<p>이를 활용하기 위해 프로그램을 병렬로 실행하는 방법은 다음 두 가지입니다:</p>
<table>
<thead>
<tr>
<th>방식</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>멀티프로세스 (Multi-process)</strong></td>
<td>여러 개의 <strong>독립적인 프로그램</strong>을 동시에 실행</td>
</tr>
<tr>
<td><strong>멀티스레드 (Multi-thread)</strong></td>
<td>하나의 프로그램을 <strong>여러 흐름(스레드)</strong>으로 나누어 실행</td>
</tr>
</tbody></table>
<h2 id="2️⃣-멀티프로세스-프로세스를-나눠서-실행">2️⃣ 멀티프로세스: 프로세스를 나눠서 실행</h2>
<ul>
<li><code>fork()</code> 또는 <code>execve()</code>를 통해 <strong>독립된 자식 프로세스 생성</strong></li>
<li>각 프로세스는 자신만의 <strong>가상 주소 공간</strong>을 갖고 있으며, <strong>자원 공유가 어려움</strong></li>
<li><strong>프로세스 간 통신(IPC)</strong>이 필요함 (예: Pipe, Message Queue 등)</li>
</ul>
<p>예: 웹 서버가 요청마다 프로세스를 새로 생성</p>
<h2 id="3️⃣-멀티스레드-같은-프로세스-내에서-흐름을-나눔">3️⃣ 멀티스레드: 같은 프로세스 내에서 흐름을 나눔</h2>
<ul>
<li><code>pthread_create()</code> 등으로 <strong>프로세스 내에 여러 흐름 생성</strong></li>
<li>모든 스레드는 <strong>공유된 메모리 공간(가상 주소)</strong>에서 실행됨</li>
<li>스레드 간 통신이 간편하지만, <strong>동기화 문제</strong>가 존재 (mutex 등 필요)</li>
</ul>
<p>예: 하나의 서버 프로세스가 여러 클라이언트를 처리하기 위해 스레드 사용</p>
<h2 id="4️⃣-사용자-스레드-vs-커널-스레드">4️⃣ 사용자 스레드 vs 커널 스레드</h2>
<table>
<thead>
<tr>
<th>구분</th>
<th>사용자 스레드 (User-level)</th>
<th>커널 스레드 (Kernel-level)</th>
</tr>
</thead>
<tbody><tr>
<td>관리 주체</td>
<td>사용자 공간의 스레드 라이브러리</td>
<td>커널</td>
</tr>
<tr>
<td>생성/전환 비용</td>
<td>낮음</td>
<td>높음</td>
</tr>
<tr>
<td>커널에서의 인식</td>
<td><strong>모든 사용자 스레드 = 하나의 커널 스레드</strong></td>
<td>각각 커널 스레드로 인식</td>
</tr>
<tr>
<td>병렬성</td>
<td>제한적 (한 번에 하나만 실행)</td>
<td><strong>실제 병렬 실행 가능</strong></td>
</tr>
<tr>
<td>예시</td>
<td><code>goroutine</code> (Go), green thread</td>
<td>리눅스 스레드, Java thread (OS 연동됨)</td>
</tr>
</tbody></table>
<h2 id="5️⃣-스케줄링에서의-차이점">5️⃣ 스케줄링에서의 차이점</h2>
<h3 id="커널-스레드">커널 스레드</h3>
<ul>
<li>커널은 <strong>각 스레드를 개별적으로 인식</strong></li>
<li>A의 스레드 0, 1도 각각 독립적으로 CPU를 할당받을 수 있음</li>
</ul>
<h3 id="사용자-스레드">사용자 스레드</h3>
<ul>
<li>커널 입장에서는 <strong>프로세스 A의 스레드 0, 1을 구분하지 못함</strong></li>
<li>CPU는 프로세스 A 전체에 할당되고, <strong>스레드 간 스케줄링은 라이브러리 내부에서 처리</strong></li>
</ul>
<h2 id="6️⃣-기타-참고-정보">6️⃣ 기타 참고 정보</h2>
<ul>
<li><strong>커널이 직접 생성하는 커널 스레드</strong>도 존재함  <ul>
<li><code>ps aux</code>에서 <code>[kthreadd]</code>, <code>[rcu_gp]</code> 등 <code>[]</code>로 감싸진 이름은 커널 스레드</li>
<li>PID=2인 <code>kthreadd</code>가 루트이며, 다양한 커널 스레드를 자식으로 생성함</li>
</ul>
</li>
</ul>
<blockquote>
<p>멀티프로세스는 <strong>독립적인 실행 단위</strong>, 멀티스레드는 <strong>하나의 공간 안에서의 병렬 흐름</strong>이며, 사용자 스레드는 가볍지만 병렬성이 낮고, 커널 스레드는 무겁지만 진짜 병렬 실행이 가능합니다.</p>
</blockquote>