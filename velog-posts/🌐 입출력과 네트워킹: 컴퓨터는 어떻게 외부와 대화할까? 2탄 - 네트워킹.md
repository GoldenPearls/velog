<h1 id="🌐-컴퓨터는-어떻게-세상과-연결됐을까">🌐 컴퓨터는 어떻게 세상과 연결됐을까?</h1>
<blockquote>
<p>회선에서 패킷까지, 네트워크의 진화 이야기</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/fc89227f-9118-4bd1-b770-b79b308a6122/image.png" /></p>
<h2 id="🧒-아빠-와이파이가-안-돼요">🧒 “아빠, 와이파이가 안 돼요!”</h2>
<p>언젠가 딸아이가 무심코 던진 한마디.<br />“와이파이가 안 돼요.”<br />그 말을 들은 나는 잠시 고민에 빠졌어요.</p>
<blockquote>
<p>“정확히 말하면, 네 와이파이는 연결됐을 수 있어.<br />근데 그게 인터넷까지 연결되었냐는 건 또 다른 문제지.”</p>
</blockquote>
<p>즉, 인터넷과 와이파이는 같지 않습니다.</p>
<h2 id="🔌-1-전화선에서-시작된-연결">🔌 1. 전화선에서 시작된 연결</h2>
<p>처음부터 네트워크가 컴퓨터를 위한 건 아니었어요.<br />전신, 전화—모두 <strong>사람과 사람을 연결하기 위한 도구</strong>였지.</p>
<blockquote>
<p>“할머니가 쓰시던 다이얼 전화기를 생각해봐.<br />두 사람이 통화하려면 진짜 전선이 서로 이어졌어야 했단다.”</p>
</blockquote>
<p>이런 방식을 우리는 <strong>회선 교환 방식</strong>이라고 불러요.<br />통화 중에는 그 회선을 독점하니까, 효율이 썩 좋진 않았죠..</p>
<p>발신자와 수신자 또는 통신 쌍방이 통신을 시작하기 전에 미리 전용 연결(회선 또는 채널)을 설정해야만 하는 네트워크를 말하죠..!</p>
<h2 id="💻-2-컴퓨터가-등장하면서-세상이-바뀌다">💻 2. 컴퓨터가 등장하면서 세상이 바뀌다</h2>
<p>컴퓨터가 생기면서 이야기는 조금 달라졌어요.</p>
<p>💬 “컴퓨터끼리도 대화를 하고 싶어졌지. 그런데 그걸 위해 전선을 하나씩 다 연결할 순 없잖아?”</p>
<p>그래서 등장한 게 바로 <strong>LAN과 WAN</strong>입니다!</p>
<ul>
<li>LAN(Local Area Network) → 가까운 컴퓨터끼리 연결  </li>
<li>WAN(Wide Area Network) → 멀리 떨어진 컴퓨터도 연결</li>
</ul>
<p>초기에는 전화선 + 모뎀으로 WAN을 구성했고,<br />부서 안에서는 LAN을 써서 각 기기를 연결했어요.</p>
<h2 id="🧭-3-uucp와-유즈넷-그리고-전화요금의-두려움">🧭 3. UUCP와 유즈넷, 그리고 전화요금의 두려움</h2>
<p>1979년, <strong>UUCP(Unix to Unix Copy)</strong>라는 멋진 도구가 등장해요.<br />이걸로 컴퓨터끼리 파일도 보내고, 명령도 내릴 수 있었어요!</p>
<p>💬 “그때는 인터넷이 없었거든. 그래서 메시지를 ‘hop-hop-hop’ 방식으로 전달했단다.<br />멀리 보내고 싶으면, 중간 중간 친구들에게 바톤터치 하듯 넘겼지.”</p>
<blockquote>
<p>그게 지금 <strong>라우팅</strong>, 즉 경로 설정의 초기 형태였어요.</p>
</blockquote>
<p>게다가 장거리 전화요금이 비싸던 시대였으니까,<br /><strong>가까운 친구에게 먼저 보내고, 나중에 천천히 도착해도 좋았던</strong> 시대의 지혜였지.</p>
<h2 id="🚀-4-arpanet-그리고-인터넷의-탄생">🚀 4. ARPANET, 그리고 인터넷의 탄생</h2>
<p>이쯤 되면 ‘인터넷’이라는 단어가 등장해야겠죠?</p>
<p>“미국 국방부의 ARPA는 새로운 통신 실험을 시작했어요. 
그 결과물이 바로 <strong>ARPANET</strong>이었죠.<br />그리고 이게 훗날 인터넷이 됐답니다.”</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/c01e3b93-0077-4888-9595-93117ba1633c/image.png" /></p>
<p>ARPANET의 핵심은 <strong>패킷 교환 방식</strong>이었는데요.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/9a23ea4b-8762-4c74-aeb0-c7079a86a4e4/image.gif" /></p>
<blockquote>
<p>출처 : <a href="https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%B7_%EA%B5%90%ED%99%98">https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%B7_%EA%B5%90%ED%99%98</a></p>
</blockquote>
<p>💬 “더 이상 선을 독점하지 않고, 데이터를 잘게 쪼개서 보내면 여러 명이 한 선을 공유할 수 있게 된 겁니다.”</p>
<p>통신 기간 동안 독점적인 사용을 위해 두 통신 노드 사이를 연결하는 <code>회선 교환 방식</code>과는 달리 짤막한 데이터 트래픽에 적합하게 된거죠!</p>
<blockquote>
<p>그 덕분에 속도도 빠르고, 비용도 줄고,<br />인터넷이라는 거대한 연결망이 가능해졌죠.</p>
</blockquote>
<h2 id="🌐-5-인터넷은-네트워크들의-네트워크">🌐 5. 인터넷은 ‘네트워크들의 네트워크’</h2>
<p>딸은 다시 물었어요.</p>
<p>💬 “그럼 와이파이랑 인터넷은 같은 거야?”</p>
<p>💬 “아니야. 와이파이는 네 방에서 공유기랑 연결된 무선 선이야. 근데 인터넷은 전 세계 네트워크끼리 연결된 거야.”</p>
<p>즉,  </p>
<ul>
<li><strong>와이파이 = 집 안의 무선 LAN</strong>  </li>
<li><strong>인터넷 = LAN끼리 이어진 거대한 WAN</strong></li>
</ul>
<h2 id="보충-정리--🌐-컴퓨터는-어떻게-외부와-대화하게-되었을까---패킷-교환-방식-회선-교환-방식">보충 정리 : 🌐 컴퓨터는 어떻게 외부와 대화하게 되었을까? - 패킷 교환 방식, 회선 교환 방식</h2>
<blockquote>
<p>― 길을 열고, 나누고, 바꿔온 데이터 전송의 여정</p>
</blockquote>
<h3 id="🧭-옛날-옛적-세상에-컴퓨터는-없었습니다">🧭 옛날 옛적, 세상에 컴퓨터는 없었습니다</h3>
<p>그 시절 세상에서 가장 빠른 정보 전송 방법은 <strong>전신</strong>이었어요. 모스 부호가 전류를 타고 철사를 따라 흘렀고, 그게 다시 <strong>전화선</strong>으로 바뀌면서 사람들은 목소리로도 소통할 수 있게 되었죠.</p>
<p>이 전화 시스템은 <strong>회선 교환</strong>이란 방식을 썼어요.  </p>
<blockquote>
<p>“헬로? 서울 연결해주세요!”<br />→ 전화국 직원이 진짜 선을 물리적으로 연결해줬죠.</p>
</blockquote>
<p><strong>두 사람이 통화하는 동안엔, 그 전선은 오직 그 둘만의 전용 도로였습니다.</strong><br />효율성은 별로였지만, 품질만큼은 꽤 괜찮았죠.</p>
<h3 id="💡-그리고-세상에-컴퓨터가-등장했습니다">💡 그리고 세상에 ‘컴퓨터’가 등장했습니다</h3>
<p>컴퓨터는 계산도 잘했지만, <strong>혼자서는 외롭고 무능한 존재</strong>였어요.<br />그래서 사람들은 컴퓨터들을 서로 연결해보기로 했어요.</p>
<h4 id="방법은">방법은?</h4>
<p>전화선에 <strong>모뎀</strong>을 달아 <strong>컴퓨터끼리 전화를 걸게</strong> 만든 거예요!</p>
<blockquote>
<p>“삐-삐비-삐익–📞 연결되었습니다!”<br />이게 바로 우리가 기억하는 다이얼업 인터넷의 원조입니다.</p>
</blockquote>
<p>하지만 회선 교환 방식은 컴퓨터한테는 맞지 않았어요.<br />컴퓨터는 <strong>말수가 적고, 갑자기 말하다 말고, 또 빠르게 말하고 싶어하는</strong> 존재였거든요.<br />이런 비효율을 극복하기 위해 등장한 게 바로…</p>
<h3 id="🚚-패킷-교환의-시대">🚚 패킷 교환의 시대!</h3>
<p>“한번 연결해서 계속 쓰는 건 비싸!  
그냥 짧게 끊어서 보내자!”</p>
<p>그래서 컴퓨터는 <strong>말하고 싶은 내용을 조각내기 시작</strong>했어요.<br />이 조각들을 <strong>패킷</strong>이라고 불렀고,<br />각 패킷에는 “누구에게 보낼지”라는 주소가 붙었죠.</p>
<blockquote>
<p>마치 택배 박스에 붙은 송장처럼요.<br />누구네 집인지 써놓고, 자기 길로 보내는 거예요.</p>
</blockquote>
<p>그래서 이 방식은 <strong>패킷 교환</strong>이라고 불렸고,<br /><strong>여러 컴퓨터가 선을 동시에 쓰면서도 충돌 없이 데이터를 주고받을 수 있게</strong> 해줬습니다.</p>
<h3 id="🧃-그리고-두-가지-패킷-교환-방식이-생겨났어요">🧃 그리고 두 가지 패킷 교환 방식이 생겨났어요</h3>
<h4 id="1-데이터그램">1. 데이터그램</h4>
<blockquote>
<p>“각자 자유롭게 가라! 순서야 나중에 정리하지 뭐”</p>
</blockquote>
<p>이건 <strong>각 패킷이 전혀 다른 경로로</strong> 목적지에 가는 방식이에요.<br />도착 순서를 보장하지 않지만, <strong>길이 막히면 다른 길로 돌아가는 유연함</strong>이 있었죠.<br />대표적인 예시: <strong>UDP</strong></p>
<h4 id="2-가상-회선">2. 가상 회선</h4>
<blockquote>
<p>“모든 패킷이 같은 길로 가야 돼! 줄 잘 서!”</p>
</blockquote>
<p>이 방식은 패킷이지만, <strong>전송 전에 가상의 길을 먼저 만들어놓고</strong><br />그 길을 따라 차례로 가는 방식입니다.<br />패킷이 순서를 어기지 않으니, <strong>영상을 재생할 때처럼 순서가 중요한 경우</strong> 유리해요.<br />대표적인 예시: <strong>TCP</strong></p>
<h3 id="📬-메시지-교환이라는-오래된-방식도-있었어요">📬 &quot;메시지 교환&quot;이라는 오래된 방식도 있었어요</h3>
<p>이건 마치 <strong>편지를 한 장 써서 다 읽은 후에야 전달하는 구조</strong>였어요.<br />보내는 입장에선 간단하지만, <strong>다음 사람이 받기까지 오래 기다려야 했죠.</strong></p>
<p>지금은 <strong>짧은 패킷 단위의 교환</strong>이 대세가 되면서 거의 사라졌지만,<br />그 당시엔 꽤 효율적인 방식이기도 했어요.</p>
<h3 id="🚀-속도가-더-중요해진-시대-프레임-릴레이와-셀-릴레이">🚀 속도가 더 중요해진 시대: 프레임 릴레이와 셀 릴레이</h3>
<p>컴퓨터가 점점 빨라지고, 영상 통화나 고속 인터넷 같은 <strong>실시간 서비스</strong>가 필요해지자<br />사람들은 <strong>빠르지만, 조금은 덜 꼼꼼한 방식</strong>을 원했어요.</p>
<p>그래서 나온 것이 바로…</p>
<h4 id="▶️-프레임-릴레이">▶️ 프레임 릴레이</h4>
<blockquote>
<p>“에러 체크? 나중에 하자! 지금은 속도가 중요해!”</p>
</blockquote>
<ul>
<li><strong>오류 제어를 생략하거나 최소화</strong>  </li>
<li>데이터를 큰 덩어리(프레임)로 신속하게 주고받음</li>
</ul>
<h4 id="▶️-셀-릴레이-atm">▶️ 셀 릴레이 (ATM)</h4>
<blockquote>
<p>“크기도 딱 정해놓고! 깔끔하게 보내자”</p>
</blockquote>
<ul>
<li><strong>모든 패킷을 딱딱 정해진 크기(셀)</strong>로 나눔  </li>
<li><strong>네트워크 전 구간에서 예측 가능한 속도</strong> 제공</li>
</ul>
<p>영상, 음성, 실시간 데이터 전송에서 <strong>지연을 최소화하는 데 최적화</strong>된 방식이었죠.</p>
<h3 id="🎯-결국-이-모든-길을-택한-건-컴퓨터입니다">🎯 결국, 이 모든 길을 택한 건 컴퓨터입니다</h3>
<ul>
<li>연결을 꼭 먼저 만들고 싶은 친구들은 <strong>회선 교환</strong></li>
<li>자유롭게 돌아다니고 싶은 친구들은 <strong>데이터그램</strong></li>
<li>안전하게, 줄 세워 가고 싶은 친구들은 <strong>가상 회선</strong></li>
<li>빠르게 도착하고 싶다면 <strong>프레임 릴레이</strong>나 <strong>ATM 셀 릴레이</strong></li>
</ul>
<h3 id="🧾-결론-요약">🧾 결론 요약</h3>
<table>
<thead>
<tr>
<th>방식</th>
<th>특징</th>
<th>언제 쓰나</th>
</tr>
</thead>
<tbody><tr>
<td>회선 교환</td>
<td>고정 연결 / 안정성 ↑</td>
<td>전화 통화, 고정 회선</td>
</tr>
<tr>
<td>패킷 교환</td>
<td>연결 없이 / 유연함</td>
<td>대부분의 인터넷 통신</td>
</tr>
<tr>
<td>데이터그램</td>
<td>빠름 / 순서 보장 X</td>
<td>스트리밍, 게임 등</td>
</tr>
<tr>
<td>가상 회선</td>
<td>순서 유지 / 안정적</td>
<td>파일 다운로드, 웹</td>
</tr>
<tr>
<td>프레임 릴레이</td>
<td>빠름 / 최소 오류 처리</td>
<td>기업 전용망, ATM 백본</td>
</tr>
<tr>
<td>셀 릴레이(ATM)</td>
<td>일정한 속도 / 셀 단위</td>
<td>음성/영상 실시간 통신</td>
</tr>
</tbody></table>
<blockquote>
<p>“컴퓨터는 수많은 방법으로 세상과 연결돼 왔습니다.<br />그리고 그 모든 교환 방식은 <strong>‘더 빠르고, 더 효율적인 소통’을 위한 진화의 결과</strong>입니다.”  </p>
</blockquote>
<blockquote>
<p>출처: <a href="https://bugoverdose.github.io/computer-science/network-switching-systems/">[네트워크] 교환 시스템: 전용 회선과 교환 회선, 회선 교환과 패킷 교환</a></p>
</blockquote>
<h2 id="보충정리--lan과-wan">보충정리 : LAN과 WAN</h2>
<h3 id="lan">LAN</h3>
<p><code>LAN</code>은 <strong>Local Area Network의 약자로 이름 그대로 가까운 지역을 연결한 근거리 통신망을 의미</strong>합니다. </p>
<p>예를 들어서 <strong>가정, 기업, 학교처럼 한정된 공간에서의 네트워크를 LAN</strong>이라고 부릅니다. </p>
<p>다음 그림을 통해서 이해해 볼까요?</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/3783c893-b33e-4861-84fd-38d68b4d8644/image.png" /></p>
<p>이때 A와 B 그리고 F와 G는 각각 가정이라는 한정된 공간에 구성된 네트워크이며, C, D, E 또한 회사라는 한정된 공간에 구성된 네트워크이므로 세 집합 모두 LAN이라고 볼 수 있습니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/49e8d62c-1b82-4849-9930-70f2d3671761/image.png" /></p>
<h3 id="wan">WAN</h3>
<p>WAN은 Wide Area Network의 약자로 이름 그대로 먼 지역을 연결하는 광역 통신망을 의미합니다. 멀리 떨어진 LAN을 연결할 수 있는 네트워크가 바로 WAN입니다. </p>
<p>인터넷은 ‘네트워크의 네트워크’라고 할 수 있는데요, 인터넷이 WAN으로 분류됩니다. </p>
<blockquote>
<p>같은 LAN에 속한 호스트끼리 메시지를 주고받아야 할 때는 인터넷 연결과 같은 WAN이 필요 없지만, 다른 LAN에 속한 호스트와 메시지를 주고받아야 할 때는 WAN이 필요합니다.</p>
</blockquote>
<p>우리가 인터넷을 사용하기 위해 접속하는 WAN은 ISP Internet Service Provider라는 인터넷 서비스 업체가 구축하고 관리합니다. </p>
<p><code>ISP</code>는 <strong>사용자에게 인터넷과 같은 WAN에 연결 가능한 회선을 임대하는 등 WAN과 관련한 다양한 서비스를 제공</strong>합니다. 인터넷을 사용하기 위해 ISP와 계약하여 인터넷 사용 요금을 내는 것은 이러한 이유 때문입니다. </p>
<p>국내의 대표적인 ISP에는 KT, LG유플러스, SK브로드밴드가 있습니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/fa61123a-3581-4ebf-8ddf-8d1d9de71b87/image.png" /></p>
<p>참고로 인터넷이 WAN의 전부는 아닙니다. 멀리 떨어진 LAN을 연결하기 위해 특정 조직에서 불특정 다수에게 공개되지 않은 WAN을 얼마든지 구축할 수도 있습니다.</p>
<blockquote>
<p>출처 : <a href="https://hongong.hanbit.co.kr/network-%EB%B2%94%EC%9C%84%EC%97%90-%EB%94%B0%EB%A5%B8-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%84%EB%A5%98lan-wan/">혼자 공부하는 네트워크</a></p>
</blockquote>
<h2 id="📦-정리하며-네트워크는-어떻게-자라났을까">📦 정리하며: 네트워크는 어떻게 자라났을까?</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/671270f2-08b4-4df3-a271-a0f23c687852/image.png" /></p>
<table>
<thead>
<tr>
<th>시대</th>
<th>핵심 기술</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>전신/전화기</td>
<td>회선 교환</td>
<td>물리 선 연결, 전용 회선 점유</td>
</tr>
<tr>
<td>초기 컴퓨터</td>
<td>LAN + 모뎀</td>
<td>가까운 곳 LAN, 먼 곳은 WAN</td>
</tr>
<tr>
<td>UUCP 시대</td>
<td>hop-by-hop</td>
<td>장거리 대신 단계별 전송</td>
</tr>
<tr>
<td>ARPANET</td>
<td>패킷 교환</td>
<td>데이터를 조각으로 나눠서 전송</td>
</tr>
<tr>
<td>오늘날 인터넷</td>
<td>네트워크 간 연결</td>
<td>전 세계 LAN/WAN이 묶인 구조</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>“인터넷은 단지 하나의 선이 아니라,<br />수많은 작은 네트워크들이 만나고 협력하는<br />거대한 ‘네트워크의 네트워크’예요.”</strong></p>
</blockquote>
<h1 id="🌐-컴퓨터-네트워크의-진짜-시작-이더넷-이야기">🌐 컴퓨터 네트워크의 진짜 시작: 이더넷 이야기</h1>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/e5911ab9-540e-42af-af17-dcd5358bf17d/image.png" /></p>
<h2 id="1️⃣-우리는-컴퓨터를-연결하고-싶었어요">1️⃣ “우리는 컴퓨터를 연결하고 싶었어요”</h2>
<p>1970년대, 미국 캘리포니아의 어느 연구소.<br /><strong>제록스의 PARC (Xerox Palo Alto Research Center)</strong> 연구소에서는 새로운 발상이 떠오르고 있었습니다.</p>
<blockquote>
<p>“한 사무실 안의 여러 컴퓨터들을 서로 연결할 수 없을까?”<br />“이제 혼자 일하던 컴퓨터도 <strong>네트워크</strong>라는 세계로 나아가야 하지 않을까?”</p>
</blockquote>
<p>이 질문에 답하며 등장한 기술이 있었죠.<br />바로 <strong>이더넷(Ethernet)</strong>입니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/9c5af970-18da-49c2-a7a8-1c3cf39e2a80/image.png" /></p>
<p>이더넷(Ethernet)은 컴퓨터 네트워크 기술의 하나로, 먼 거리를 연결할 수 있는 방식은 아니기 때문에 LAN이라고 합니다. </p>
<blockquote>
<p>출처 : <a href="https://bentist.tistory.com/33">https://bentist.tistory.com/33</a></p>
</blockquote>
<h2 id="2️⃣-밥-멧칼프-그리고-이더넷의-탄생">2️⃣ 밥 멧칼프, 그리고 이더넷의 탄생</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/fb746a44-f265-4489-b49e-24c688d8785e/image.png" /></p>
<p>그 아이디어의 중심에는 한 사람이 있었습니다.<br /><strong>밥 멧칼프(Bob Metcalfe)</strong>.</p>
<p>그는 <strong>‘LAN(Local Area Network)’</strong>, 즉 근거리 네트워크를 위한 프로토콜로 이더넷을 고안합니다.<br />이 기술의 핵심은 <strong>한 개의 선에 여러 장치를 연결해서 데이터를 주고받는 것</strong>이었어요.</p>
<blockquote>
<p>“모든 컴퓨터를 같은 선에 꽂고, 서로 알아서 대화하게 하자!”</p>
</blockquote>
<p>그 시절에는 무선도, 고속 라우터도 없었기 때문에<br /><strong>하나의 전송 선로를 공유</strong>하는 구조가 당연했습니다.</p>
<h2 id="3️⃣-이더넷의-규칙-누구든-말할-수-있지만-동시에-말하진-마라">3️⃣ 이더넷의 규칙: 누구든 말할 수 있지만, 동시에 말하진 마라</h2>
<p>이더넷의 초창기 버전은 <strong>반이중(Half-Duplex)</strong>이었습니다.<br />한 번에 한 사람만 말할 수 있었죠.</p>
<h3 id="통신방향">통신방향</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/96e8c1cd-248b-488b-b7b2-bfc187183335/image.png" /></p>
<p>통신방향은 단방향 통신 방법과 양방향 통신방법이 있었죠.</p>
<p>먼저.. 단방향 통신 방법을 봅시다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/692001fd-3b1c-423e-ae90-3ca704512f35/image.png" /></p>
<p><strong>📡 Simplex - 단방향 통신 방식</strong></p>
<p>통신에서 <strong>데이터나 신호의 흐름이 오직 한 방향으로만 진행</strong>되는 통신 방식을 <strong>Simplex(단방향 통신)</strong>이라고 합니다.<br />즉, 한쪽이 송신을 하고, 다른 쪽은 수신만 하는 구조입니다.<br />대표적인 예로는 <strong>Master/Slave</strong> 또는 <strong>Publisher/Subscriber</strong> 구조가 있습니다.</p>
<p><strong>🧭 예시 구조 설명</strong></p>
<p><strong>Publisher(Master)</strong> 는 정보를 일방적으로 전송하고,<br /><strong>Subscribers(Slaves)</strong> 는 정보를 수신만 합니다.</p>
<pre><code>Publisher:     Master
                  ↓
Subscribers:  Slave   Slave   Slave</code></pre><ul>
<li>이 구조에서는 Master가 정보를 발행(publish)하면<br />각 Slave(구독자)는 수신만 하고 응답은 하지 않습니다.</li>
<li>통신 흐름이 일방향이기 때문에 간단하지만,<br />상호작용이 필요한 경우에는 적합하지 않습니다.</li>
</ul>
<p><code>Duplex</code>는 양방향 통신 방법입니다.</p>
<p><strong>🔁 반이중(Half-Duplex) vs 전이중(Full-Duplex) 요약 비교</strong></p>
<table>
<thead>
<tr>
<th>구분</th>
<th><strong>반이중 (Half-Duplex)</strong></th>
<th><strong>전이중 (Full-Duplex)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>양방향 통신</strong></td>
<td>✅ 가능</td>
<td>✅ 가능</td>
</tr>
<tr>
<td><strong>동시에 양방향 가능?</strong></td>
<td>❌ <strong>한 번에 한 방향만 가능</strong></td>
<td>✅ <strong>양쪽에서 동시에 송수신 가능</strong></td>
</tr>
<tr>
<td><strong>예시</strong></td>
<td>무전기, 옛날 이더넷</td>
<td>전화, 최신 이더넷, 인터넷</td>
</tr>
<tr>
<td><strong>장점</strong></td>
<td>회로 단순, 비용 저렴</td>
<td>빠르고 자연스러운 통신</td>
</tr>
<tr>
<td><strong>단점</strong></td>
<td>동시에 말하면 충돌 발생</td>
<td>충돌 없이 통신 가능</td>
</tr>
<tr>
<td><strong>비유</strong></td>
<td><strong>무전기</strong>: “오버!”를 외쳐야 함</td>
<td><strong>전화기</strong>: 서로 말하고 듣는 게 가능</td>
</tr>
</tbody></table>
<p><strong>🎤 반이중: 무전기 스타일</strong></p>
<ul>
<li>A: “들리세요? 오버!”</li>
<li>B: “네 들려요, 오버!”</li>
</ul>
<p>→ A가 말하는 동안 B는 말하지 못하고 기다려야 해요.<br />→ <strong>같은 채널(길)을 번갈아 사용하는 구조</strong></p>
<p><strong>📞 전이중: 전화 스타일</strong></p>
<ul>
<li>A: “오늘 점심 뭐 먹을래?”</li>
<li>B: “음... 짬뽕 생각 중인데, 너는?”</li>
</ul>
<p>→ A와 B가 동시에 말하거나 듣는 게 가능<br />→ <strong>송신과 수신 회로가 따로 있어서 동시에 통신 가능</strong></p>
<p><strong>🧪 실제 네트워크 예시</strong></p>
<table>
<thead>
<tr>
<th>장치/환경</th>
<th>반이중 or 전이중</th>
</tr>
</thead>
<tbody><tr>
<td>무전기</td>
<td>반이중</td>
</tr>
<tr>
<td>전화기</td>
<td>전이중</td>
</tr>
<tr>
<td>초기 이더넷 (허브 기반)</td>
<td>반이중</td>
</tr>
<tr>
<td>스위치 기반 이더넷</td>
<td>전이중</td>
</tr>
<tr>
<td>UART 직렬 통신 (기본)</td>
<td>반이중</td>
</tr>
<tr>
<td>SPI 통신</td>
<td>전이중</td>
</tr>
<tr>
<td>USB</td>
<td>전이중</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>반이중</strong>은 ‘둘이 말할 수 있지만, 동시에 하면 안 돼!’<br /><strong>전이중</strong>은 ‘서로 마음껏 말하고 들어도 돼!’</p>
</blockquote>
<blockquote>
<p>출처 : <a href="https://datawizard.co.kr/55">https://datawizard.co.kr/55</a></p>
</blockquote>
<p>모든 장치는 같은 선에 연결되어 있었고, 누군가가 말을 시작하면 나머지는 조용히 들어야 했습니다.<br />그리고 이 말을 <strong>프레임(Frame)</strong>이라고 불렀죠.</p>
<h3 id="🎁-프레임이란">🎁 프레임이란?</h3>
<table>
<thead>
<tr>
<th>구성 요소</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>송신자 MAC 주소</td>
<td>보낸 사람 주소</td>
</tr>
<tr>
<td>수신자 MAC 주소</td>
<td>받을 사람 주소</td>
</tr>
<tr>
<td>오류 체크 값(CRC 등)</td>
<td>데이터가 깨졌는지 확인</td>
</tr>
<tr>
<td>페이로드</td>
<td>실제 전송할 내용</td>
</tr>
</tbody></table>
<p><strong>MAC 주소</strong>는 각 장치가 태어날 때 받는 고유 주소입니다.<br />지금도 스마트폰, 노트북, 라우터에 다 들어 있어요!</p>
<h2 id="4️⃣-하지만-충돌은-피할-수-없었어요">4️⃣ 하지만 충돌은 피할 수 없었어요</h2>
<p>컴퓨터 A가 말하려고 입을 여는 순간, 컴퓨터 B도 동시에 말하면 어떻게 될까요?</p>
<blockquote>
<p>“두 사람이 동시에 떠들면, 누구 말도 못 알아들어요.”</p>
</blockquote>
<p>이때 두 개의 프레임이 섞이면서 <strong>충돌(Collision)</strong>이 발생합니다.</p>
<p>여기서 멧칼프의 진짜 천재성이 나옵니다.<br />그는 이렇게 말하죠:</p>
<blockquote>
<p>“그럼 둘 다 잠깐 조용히 하자. 그리고 <strong>랜덤한 시간</strong>을 기다린 다음 다시 시도하자!”</p>
</blockquote>
<p>이게 바로 <strong>CSMA/CD (Carrier Sense Multiple Access with Collision Detection)</strong>,</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/8214192f-5e94-42ea-a2ec-d199fb6b3b1c/image.png" /></p>
<p>즉 <strong>‘듣고, 충돌 감지하고, 기다렸다가 다시 말하기’</strong> 전략입니다.</p>
<h2 id="5️⃣-그렇게-세상은-네트워크를-갖게-되었다">5️⃣ 그렇게 세상은 ‘네트워크’를 갖게 되었다</h2>
<p>이더넷은 이후 수많은 LAN의 표준이 되었습니다.<br />하지만 반이중의 시대는 오래가지 않았죠.</p>
<h3 id="오늘날의-이더넷은">오늘날의 이더넷은?</h3>
<ul>
<li>모든 장치는 <strong>라우터(Router)</strong> 또는 <strong>스위치(Switch)</strong>에 연결됩니다.</li>
<li>이제는 충돌이 없습니다.  <blockquote>
<p>라우터가 “어느 주소로 가야 하는지”를 정확히 기억하고,<br />패킷을 해당 장치로 <strong>직접 배달</strong>해주기 때문이죠.</p>
</blockquote>
</li>
</ul>
<h3 id="과거-모두-같은-선-→-충돌-있음">과거: 모두 같은 선 → 충돌 있음</h3>
<h3 id="현재-개별-선--라우터-→-충돌-없음-full-duplex">현재: 개별 선 + 라우터 → 충돌 없음 (Full Duplex)</h3>
<h2 id="6️⃣-그런데-왜-traceroute엔-hop이라는-단어가-나올까요">6️⃣ “그런데 왜 traceroute엔 hop이라는 단어가 나올까요?”</h2>
<p>여기서 잠깐, 재미있는 얘기 하나.<br />우리가 명령어 <code>traceroute www.naver.com</code>을 입력하면<br />중간에 <code>maximum 30 hops</code>라는 문구가 나와요.</p>
<p>여기서 <strong>hop</strong>은 바로 이더넷처럼<br /><strong>네트워크 장치 간에 데이터를 “몇 번 건너서” 가는지</strong>를 뜻합니다.</p>
<blockquote>
<p>인터넷이란, <strong>수많은 네트워크 장비와 노드를 건너서 가는</strong> 구조이기 때문에<br />각 장치를 한 번씩 “뛴다(hop)”고 표현하는 거예요.</p>
</blockquote>
<h2 id="보충-정리--publisher--subscriber-구조는-데이터베이스-시스템이나-메시징-시스템">보충 정리 : Publisher / Subscriber 구조는 데이터베이스 시스템이나 메시징 시스템</h2>
<p><strong>Publisher / Subscriber 구조</strong>는 <strong>데이터베이스 시스템이나 메시징 시스템</strong>에서 굉장히 많이 쓰입니다.  </p>
<blockquote>
<p>다만, 단순히 <strong>단방향 통신(SIMPLEX)</strong>으로만 보는 것보다, <strong>비동기적이고 느슨하게 결합된 아키텍처</strong>라는 점에서 더 확장된 의미로 사용되곤 합니다.</p>
</blockquote>
<h3 id="💾-db와-메시징에서의-pubsub-구조는-이렇게-쓰여요">💾 DB와 메시징에서의 Pub/Sub 구조는 이렇게 쓰여요</h3>
<h4 id="1-메시지-브로커-기반-시스템">1) <strong>메시지 브로커 기반 시스템</strong></h4>
<ul>
<li>예: <strong>Kafka, Redis Pub/Sub, RabbitMQ</strong></li>
<li><strong>Publisher</strong>는 어떤 이벤트나 데이터를 브로커에게 보냅니다.</li>
<li><strong>Subscriber</strong>는 자신이 관심 있는 주제를 브로커에게 등록해두고, 해당 주제의 메시지가 발행되면 수신합니다.</li>
<li>이 구조에서는 <strong>발행자와 구독자가 서로 몰라도</strong> 통신이 가능합니다.</li>
</ul>
<pre><code>Publisher → [Broker] → Subscriber 1
                            → Subscriber 2</code></pre><p>✅ 특징:</p>
<ul>
<li><strong>비동기</strong>, <strong>이벤트 기반</strong>, <strong>확장성 우수</strong></li>
<li>서비스 간 <strong>느슨한 결합(Loose Coupling)</strong> 가능</li>
</ul>
<h4 id="2-데이터베이스-트리거와-캐시-시스템">2) <strong>데이터베이스 트리거와 캐시 시스템</strong></h4>
<ul>
<li>예: DB에서 값이 변경될 때 → <strong>캐시 무효화</strong> 메시지를 Redis에 보내는 구조</li>
<li>이때도 DB는 Publisher, Redis는 중계자, 구독 서비스는 Subscriber처럼 작동</li>
</ul>
<h3 id="🔄-다만-통신-방식은-단순-단방향-그-이상">🔄 다만, 통신 방식은 단순 단방향 그 이상</h3>
<ul>
<li>Pub/Sub은 <strong>단방향 통신 구조를 기반으로 하지만</strong>,  
<strong>복수의 구독자와 분산처리, 피드백 없는 브로드캐스트</strong>가 핵심입니다.</li>
<li>따라서 단순한 <strong>Simplex(일방향 통신)</strong> 개념보다는<br /><strong>아키텍처 패턴</strong>으로 이해하는 것이 더 적절합니다.</li>
</ul>
<blockquote>
<p><strong>“이더넷은 단순한 케이블 기술이 아니라,<br />컴퓨터들이 서로를 존중하며 말하는 법을 배운 첫 번째 네트워크 언어입니다.”</strong></p>
</blockquote>
<hr />
<h1 id="ip-주소-dns-그리고-우리가-매일-보는-웹의-정체">IP 주소, DNS, 그리고 우리가 매일 보는 웹의 정체</h1>
<h2 id="🧠-핵심-메시지">🧠 핵심 메시지</h2>
<blockquote>
<p>&quot;우리가 매일 검색하는 그 한 줄 주소창 뒤에는<br />수십 년의 약속과 기술, 주소 체계가 숨어 있다.&quot;</p>
</blockquote>
<h2 id="🧱-1-인터넷은-프로토콜-계층-위에-세워진-약속이다">🧱 1. 인터넷은 ‘프로토콜 계층’ 위에 세워진 약속이다</h2>
<p>여러분, 인터넷은 <strong>선이 아닙니다.</strong><br />사실 인터넷은 선, 전파, 광섬유, 심지어 위성 기술 위에서도 잘 작동합니다. 그 이유는 바로?</p>
<blockquote>
<p><strong>인터넷은 프로토콜 계층 구조로 설계되었기 때문이에요.</strong></p>
</blockquote>
<p>즉, 아래 계층(물리적인 기술)이 바뀌어도,<br />위쪽 계층(웹, 메일, 채팅)은 <strong>영향을 받지 않도록 설계</strong>되었죠.<br />그래서 여러분이 와이파이에서 5G로 바뀌어도,<br />웹사이트는 끄떡없이 잘 뜨는 겁니다!</p>
<h2 id="🔀-2-충돌과-분산을-해결한-장치들">🔀 2. 충돌과 분산을 해결한 장치들</h2>
<p>우리가 같은 네트워크(예: 공유기)에 연결된 여러 기기들이<br />한꺼번에 데이터를 주고받으면 충돌이 일어날 수 있어요.</p>
<p>이걸 해결하기 위해 처음에는 ‘<strong>허브(Hub)</strong>’라는 장치가 등장했어요.<br />허브는 모든 장치가 <strong>같은 선을 나눠 쓰도록</strong> 만들었고,<br />이때 통신이 겹치면 ‘랜덤 백오프’로 기다렸다가 재시도했습니다.</p>
<p>하지만 이건 비효율적이었죠.<br />그래서 등장한 게 ‘<strong>스위치(Switch)</strong>’입니다.</p>
<blockquote>
<p>스위치는 각각의 장비에 독립된 경로를 연결해주기 때문에 충돌이 사라집니다!</p>
</blockquote>
<p>그리고 <strong>라우터(Router)</strong>는 이런 여러 스위치, 허브를 연결해주는 교통 경찰 역할을 합니다.</p>
<h2 id="🛣-3-인터넷의-두-핵심-프로토콜-tcpip">🛣 3. 인터넷의 두 핵심 프로토콜, TCP/IP</h2>
<p>인터넷은 <strong>TCP/IP</strong>라는 두 가지 핵심 프로토콜로 움직입니다.</p>
<table>
<thead>
<tr>
<th>프로토콜</th>
<th>역할</th>
</tr>
</thead>
<tbody><tr>
<td>IP</td>
<td>패킷을 목적지까지 보내는 ‘주소 배달부’</td>
</tr>
<tr>
<td>TCP</td>
<td>보냈던 패킷이 잘 도착했는지 확인하는 ‘배송 확인자’</td>
</tr>
</tbody></table>
<p>📦 IP는 데이터를 ‘패킷(packet)’이라는 작은 상자로 쪼개고,<br />🏠 TCP는 그 상자들이 <strong>모두 도착했는지, 순서대로 왔는지</strong> 꼼꼼히 확인해줍니다.</p>
<blockquote>
<p>📬 IP는 전신처럼 ‘보낸다’가 목적이라면,<br />📮 TCP는 택배처럼 ‘정확히 전달한다’가 목적이에요!</p>
</blockquote>
<h2 id="🧭-4-주소가-있어야-데이터를-보낸다---ip-주소">🧭 4. 주소가 있어야 데이터를 보낸다 - IP 주소</h2>
<p>모든 컴퓨터는 인터넷에서 고유한 이름, 즉 <strong>IP 주소</strong>를 가지고 있어요.<br />가장 흔한 IP 체계는 IPv4, 즉 <strong>32비트 주소</strong>입니다.</p>
<p>예를 들어:<br /><code>192.168.0.1</code> → 각 부분은 <strong>0~255 사이의 숫자 4개</strong>로 구성되어 있죠.<br />이걸 ‘옥텟(octet)’이라 부릅니다.</p>
<blockquote>
<p>문제는, 쓸 수 있는 주소가 <strong>40억 개뿐</strong>이라는 점이에요.<br />그래서 지금은 더 많은 주소를 만들 수 있는 <strong>IPv6 (128비트 주소)</strong>로 넘어가는 중입니다!</p>
</blockquote>
<h2 id="📓-5-그런데-주소를-어떻게-외워---dns의-등장">📓 5. 그런데 주소를 어떻게 외워? - DNS의 등장</h2>
<p>우리, 웹사이트 들어갈 때 IP 주소 치고 다니나요?</p>
<pre><code>223.130.195.200</code></pre><p>이걸 매번 외우는 건 불가능하죠. 그래서 생긴 게 <strong>DNS</strong>입니다!</p>
<blockquote>
<p>DNS(Domain Name System)는 이름을 숫자 주소로 바꿔주는 <strong>인터넷의 전화번호부</strong>예요.</p>
</blockquote>
<p>예를 들어:</p>
<pre><code>www.whitehouse.gov → 23.15.93.167</code></pre><p>DNS는 여러분이 <code>naver.com</code>을 치면,<br />그에 해당하는 IP 주소를 찾아주는 시스템입니다.</p>
<p>게다가, DNS는 우리가 주소를 몰라도 서버가 바뀌어도<br />항상 가장 최신 주소를 알려주기 때문에 정말 중요한 인프라예요.</p>
<h2 id="🌍-6-웹은-어떻게-우리에게-도달할까">🌍 6. 웹은 어떻게 우리에게 도달할까?</h2>
<p>인터넷에는 수많은 프로토콜이 있지만,<br />그중 우리가 매일 쓰는 건 바로 <strong>HTTP</strong>와 <strong>HTTPS</strong>입니다!</p>
<table>
<thead>
<tr>
<th>프로토콜</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td>웹 페이지를 주고받는 기본 통신 규약</td>
</tr>
<tr>
<td>HTTPS</td>
<td>보안을 강화한 HTTP (S = Secure)</td>
</tr>
</tbody></table>
<p>이 모든 웹 통신은 <strong>웹 브라우저(Chrome, Safari 등)</strong>와  
<strong>웹 서버(Apache, Nginx 등)</strong> 간의 대화를 통해 이루어집니다.</p>
<p>이때 사용하는 주소가 바로…</p>
<h2 id="🔗-7-우리가-매일-입력하는-url의-정체">🔗 7. 우리가 매일 입력하는 URL의 정체</h2>
<pre><code>https://www.example.com:80/path/to/page.html?key=value</code></pre><p>이 한 줄 안에 어마어마한 정보가 숨어 있어요!</p>
<table>
<thead>
<tr>
<th>구성 요소</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>https</td>
<td>어떤 프로토콜로 통신할지</td>
</tr>
<tr>
<td><a href="http://www.example.com">www.example.com</a></td>
<td>어느 서버에 갈지 (도메인)</td>
</tr>
<tr>
<td>:80</td>
<td>어느 포트로 들어갈지</td>
</tr>
<tr>
<td>/path/to/page.html</td>
<td>어떤 자원(파일)을 요청할지</td>
</tr>
<tr>
<td>?key=value</td>
<td>어떤 조건을 전달할지 (검색어 등)</td>
</tr>
</tbody></table>
<p>📌 그리고 이 URL이 실제 IP 주소로 바뀌는 과정이<br />바로 앞서 설명한 <strong>DNS</strong>를 통해 일어납니다.</p>
<blockquote>
<p>“우리가 입력하는 주소창 한 줄은,<br />계층 구조, 주소 체계, 네임 시스템, 패킷 통신의 결정체다.”</p>
</blockquote>
<h1 id="🎛-컴퓨터가-소리와-빛을-이해하는-법--dac와-adc로-배우는-디지털과-아날로그의-만남">🎛 컴퓨터가 소리와 빛을 이해하는 법 ― DAC와 ADC로 배우는 디지털과 아날로그의 만남</h1>
<h2 id="🧠-핵심-메시지-1">🧠 핵심 메시지</h2>
<blockquote>
<p>&quot;세상은 연속적(아날로그)인데,<br />컴퓨터는 모든 걸 조각(디지털)으로 본다.<br />그렇다면 둘은 어떻게 소통할까?&quot;</p>
</blockquote>
<h2 id="🎥-1-현실은-부드러운데-컴퓨터는-깨져-보이는-이유">🎥 1. 현실은 부드러운데, 컴퓨터는 깨져 보이는 이유</h2>
<p>여러분, 사진을 확대해보다가 <strong>픽셀이 깨져보였던 경험</strong> 있으시죠?</p>
<p>우리가 듣고 보는 <strong>소리와 빛은 연속적인(아날로그)</strong> 정보지만,<br />컴퓨터는 오직 <strong>0과 1</strong>, <strong>디지털</strong> 숫자만 이해합니다.</p>
<p>그래서 현실 세계의 소리나 빛을 <strong>컴퓨터가 이해하기 위해선</strong>,  
<strong>샘플링(Sampling)</strong>이라는 방법을 씁니다.</p>
<blockquote>
<p><strong>샘플링이란?</strong><br />아날로그 신호에서 일정 간격으로 데이터를 '조각내서' 추출하는 것</p>
</blockquote>
<p>🎞️ 예:  </p>
<ul>
<li>영화는 초당 16~30프레임을 샘플링  </li>
<li>음악은 CD에서 초당 44,100번 샘플링</li>
</ul>
<h2 id="🔁-2-그럼-컴퓨터는-어떻게-현실-세계로-정보를-다시-보여줄까">🔁 2. 그럼 컴퓨터는 어떻게 현실 세계로 정보를 다시 보여줄까?</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/a74ad72b-2979-43d2-8563-7e283e211cab/image.png" /></p>
<h3 id="🧯-디지털-→-아날로그-dacdigital-to-analog-converter">🧯 디지털 → 아날로그: <strong>DAC(Digital to Analog Converter)</strong></h3>
<blockquote>
<p><strong>컴퓨터가 기억하고 있던 디지털 데이터를<br />다시 부드러운 아날로그 신호로 바꾸는 장치</strong></p>
</blockquote>
<h3 id="🧪-가장-간단한-dac-led-실험">🧪 가장 간단한 DAC: LED 실험</h3>
<ul>
<li>LED 1개 = 비트 1개</li>
<li>8개의 LED → 8비트<br />→ 각 비트가 2배씩 더 밝은 빛을 내게 하면,  </li>
<li><em>0~255까지 256단계의 밝기를 표현할 수 있음*</em></li>
</ul>
<pre><code class="language-plaintext">Bit 위치:     [PB7] [PB6] [PB5] ... [PB0]
밝기 비율:     128   64   32  ...   1
총 밝기 = 모든 비트의 밝기 합</code></pre>
<p>🎛 실제로는 <strong>빛이 아니라 전압</strong>을 생성하는데,<br />이때 생성 가능한 단계 수를 <strong>해상도(Resolution)</strong>라고 부릅니다.</p>
<p>예)  </p>
<ul>
<li>10비트 DAC, 최대 5V → 1단계 = 0.005V</li>
</ul>
<h3 id="🎵-음악이-나오는-원리도-dac-덕분">🎵 음악이 나오는 원리도 DAC 덕분!</h3>
<ul>
<li>음원 데이터를 일정한 속도로 DAC에 흘려보냄</li>
<li>DAC가 그것을 아날로그 신호로 변환</li>
<li><strong>스피커</strong>는 그 아날로그 신호를 실제 '소리'로 바꿔줌</li>
</ul>
<blockquote>
<p>🎹 음악 신디사이저, 오디오 플레이어 모두 DAC의 힘!</p>
</blockquote>
<h3 id="🎵-dac와-fifo-컴퓨터가-소리를-만드는-법">🎵 DAC와 FIFO: 컴퓨터가 소리를 만드는 법</h3>
<h4 id="1️⃣-디지털-숫자로-음악을-만든다고">1️⃣ &quot;디지털 숫자로 음악을 만든다고?&quot;</h4>
<p>우리가 <strong>오디오 플레이어</strong>로 음악을 듣거나, <strong>전자 악기</strong>를 사용할 때 사실 그 뒤에서는 수많은 <strong>디지털 숫자들이 오디오 파형으로 변환</strong>되고 있습니다.<br />이때 핵심 역할을 하는 게 바로 <strong>DAC(Digital-to-Analog Converter)</strong>, 즉 <strong>디지털을 아날로그로 바꾸는 장치</strong>입니다.</p>
<blockquote>
<p>우리 주변의 소리를 내는 거의 모든 전자기기 안에 들어 있습니다.</p>
</blockquote>
<p>예를 들어 <code>PORTB = i++</code> 라는 단순한 반복문을 DAC에 입력한다고 상상해 보세요.<br />이 코드 하나로도 <strong>점점 전압이 올라가는 톱니파</strong>(Sawtooth Wave)가 만들어집니다!</p>
<h4 id="2️⃣-좀-더-멋진-소리를-만들고-싶다면">2️⃣ &quot;좀 더 멋진 소리를 만들고 싶다면?&quot;</h4>
<p>단순한 파형이 아니라 <strong>복잡한 멜로디</strong>나 <strong>악기 소리</strong>를 만들려면 어떻게 해야 할까요?</p>
<p>✅ 정답은 <strong>메모리</strong>입니다!</p>
<p>1) <strong>메모리에 오디오 데이터를 미리 저장</strong>해두고<br />2) 이를 <strong>DAC가 일정한 비율로 읽어</strong> 출력하면<br />3) 우리가 아는 부드럽고 리듬 있는 소리가 나옵니다!</p>
<p>하지만 여기서 <strong>CPU가 다른 일로 바쁘면?</strong><br />DAC가 데이터를 못 받아 음악이 끊길 수도 있겠죠.<br />그래서 등장하는 것이 바로 <strong>FIFO(선입선출 메모리)</strong>입니다.</p>
<h4 id="3️⃣-🎛️-fifo란">3️⃣ 🎛️ FIFO란?</h4>
<p><strong>FIFO</strong>는 ‘First-In, First-Out’의 줄임말로,<br /><strong>먼저 들어온 데이터가 먼저 나가는 큐(Queue) 메모리</strong>입니다.</p>
<p>🎵 <strong>오디오 재생을 예로 들면...</strong></p>
<ul>
<li>FIFO는 중간 버퍼처럼 작동합니다.</li>
<li>CPU는 한가할 때 데이터를 FIFO에 <strong>채워 넣기만</strong> 하면 되고,</li>
<li>DAC는 FIFO에서 일정한 속도로 <strong>꺼내쓰기만</strong> 하면 됩니다.</li>
</ul>
<blockquote>
<p>음악이 끊기지 않도록 중간에서 연결고리를 만들어주는 거예요!</p>
</blockquote>
<h4 id="4️⃣-근데-fifo도-찰-수-있고-비어버릴-수도-있잖아요">4️⃣ &quot;근데 FIFO도 찰 수 있고, 비어버릴 수도 있잖아요?&quot;</h4>
<p>맞습니다. 그래서 FIFO에는 <strong>두 가지 감시 트리거</strong>가 있습니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/83181b90-3fad-4de8-b605-32aac08d92d2/image.png" /></p>
<table>
<thead>
<tr>
<th>이름</th>
<th>의미</th>
<th>동작</th>
</tr>
</thead>
<tbody><tr>
<td>🔽 낮은 워터마크</td>
<td>FIFO가 <strong>거의 비었을 때</strong></td>
<td>CPU에게 “데이터 더 줘!” 라고 <strong>인터럽트 요청</strong></td>
</tr>
<tr>
<td>🔼 높은 워터마크</td>
<td>FIFO가 <strong>거의 찼을 때</strong></td>
<td>CPU에게 “그만 줘도 돼!” 라고 <strong>인터럽트 요청</strong></td>
</tr>
</tbody></table>
<p>이렇게 하면 CPU는 너무 자주 방해받지도 않고, DAC는 끊김 없이 데이터를 받을 수 있게 됩니다.</p>
<h4 id="💧-fifo는-물탱크-dac는-수도꼭지">💧 FIFO는 물탱크, DAC는 수도꼭지!</h4>
<p>상상해봅시다:</p>
<ul>
<li><p>FIFO는 <strong>물탱크</strong></p>
</li>
<li><p>DAC는 <strong>수도꼭지</strong></p>
</li>
<li><p>CPU는 <strong>물을 붓는 사람</strong>입니다.</p>
</li>
<li><p>물이 너무 적으면(낮은 워터마크) → <strong>“물 좀 부어줘!”</strong></p>
</li>
<li><p>물이 넘치기 직전이면(높은 워터마크) → <strong>“잠깐 멈춰!”</strong></p>
</li>
</ul>
<p>이런 식으로 <strong>자동 조절되는 수돗물 시스템</strong>이 바로 FIFO + DAC 구조입니다.</p>
<h3 id="🔊-fifo는-어디에-있을까">🔊 FIFO는 어디에 있을까?</h3>
<p><strong>FIFO는 컴퓨터 안에만 있는 게 아니라</strong>, 오히려 <strong>스피커나 오디오 재생 장치 쪽에 더 가까이</strong> 있습니다.</p>
<h4 id="💻-컴퓨터의-경우">💻 컴퓨터의 경우</h4>
<ul>
<li>FIFO는 보통 <strong>사운드 카드</strong>나 <strong>내장 오디오 컨트롤러 칩셋</strong> 안에 있어요.</li>
<li>예: <strong>Realtek ALC 시리즈</strong>, <strong>Intel HD Audio</strong>, <strong>USB 오디오 DAC 칩</strong> 등</li>
</ul>
<h4 id="📱-스마트폰이나-디지털-기기에서는">📱 스마트폰이나 디지털 기기에서는</h4>
<ul>
<li>FIFO는 <strong>SoC(System on Chip)</strong>나 <strong>오디오 DSP</strong> 내부에 내장되어 있어요.</li>
<li>그 덕분에 음원 파일을 부드럽게 재생할 수 있죠.</li>
</ul>
<h4 id="🔊-스피커-자체에도">🔊 스피커 자체에도?</h4>
<ul>
<li><strong>액티브 스피커</strong>나 <strong>블루투스 스피커</strong>에는<br />내부에 <strong>DAC + 앰프 + 마이크로컨트롤러(MCU)</strong>가 들어 있습니다.<br />이 안에도 <strong>FIFO 같은 버퍼 메모리</strong>가 탑재돼 있어요!</li>
</ul>
<p><strong>DAC(Digital to Analog Converter)</strong>는 <strong>&quot;디지털 데이터를 실제 소리로 바꿔주는 칩&quot;</strong>인데, DAC는 어디 있을까?</p>
<table>
<thead>
<tr>
<th>기기 종류</th>
<th>DAC 위치</th>
</tr>
</thead>
<tbody><tr>
<td>노트북/PC/스마트폰</td>
<td>메인보드의 오디오 칩셋 안</td>
</tr>
<tr>
<td>무선 이어폰</td>
<td>이어폰 내부 (SoC 칩 안)</td>
</tr>
<tr>
<td>블루투스 스피커</td>
<td>스피커 내부 (MCU + DAC 내장)</td>
</tr>
<tr>
<td>고급 오디오 장비</td>
<td>전용 외장 DAC 기기</td>
</tr>
</tbody></table>
<h3 id="🧾-요약-정리">🧾 요약 정리</h3>
<table>
<thead>
<tr>
<th>개념</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>DAC</td>
<td>디지털 숫자를 아날로그 신호로 바꾸는 장치</td>
</tr>
<tr>
<td>톱니파 생성</td>
<td>단순 반복 증가로 파형 만들기 (<code>PORTB = i++</code>)</td>
</tr>
<tr>
<td>메모리 + FIFO</td>
<td>복잡한 파형을 끊기지 않고 출력하기 위한 구조</td>
</tr>
<tr>
<td>FIFO 역할</td>
<td>데이터를 일정한 비율로 꺼내어 DAC로 전달</td>
</tr>
<tr>
<td>워터마크</td>
<td>FIFO 상태에 따라 CPU에게 인터럽트 보내기</td>
</tr>
</tbody></table>
<blockquote>
<p>🎶 <strong>“음악은 디지털 숫자의 예술이다. DAC와 FIFO는 그 숫자들을 리듬으로 바꾼다.”</strong> 🎼</p>
</blockquote>
<h2 id="🔄-3-현실의-소리나-빛을-컴퓨터에-담고-싶을-때는">🔄 3. 현실의 소리나 빛을 컴퓨터에 담고 싶을 때는?</h2>
<h3 id="🧭-왜-adc가-필요할까">🧭 왜 ADC가 필요할까?</h3>
<p>현실 세계의 대부분 정보는 <strong>연속적인 아날로그 신호</strong>입니다.<br />예를 들어 온도, 소리, 빛, 압력 등은 전부 끊기지 않고 부드럽게 변하죠.</p>
<p>하지만 <strong>컴퓨터는 오직 0과 1, 즉 디지털 정보만 이해</strong>합니다.<br />그래서 이런 연속적인 신호를 컴퓨터가 이해할 수 있도록 바꿔주는 <strong>A/D 변환기(ADC)</strong>가 필요합니다.</p>
<h3 id="🧪-아날로그-→-디지털-adcanalog-to-digital-converter">🧪 아날로그 → 디지털: <strong>ADC(Analog to Digital Converter)</strong></h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/641088a9-22f3-48c3-ba97-ecb1f6f713ef/image.png" /></p>
<blockquote>
<p>현실의 아날로그 신호를 컴퓨터가 읽을 수 있도록<br /><strong>디지털 숫자</strong>로 변환하는 장치</p>
</blockquote>
<h3 id="🧪-1️⃣-첫-단계-지금-이-순간을-포착하라-→-샘플-앤드-홀드-회로">🧪 1️⃣ 첫 단계: &quot;지금 이 순간&quot;을 포착하라! → <strong>샘플 앤드 홀드 회로</strong></h3>
<p>아날로그 신호는 계속해서 변화합니다.<br />그래서 ADC는 먼저 <strong>샘플 앤드 홀드(sample &amp; hold)</strong> 회로를 사용해<br />지금 이 순간의 전압 값을 ‘딱’ 잡아 안정적으로 유지시킵니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/d6508aeb-84d3-4eb6-855a-a33caee1623a/image.png" /></p>
<p>이 회로는 일종의 <strong>디지털 래치의 아날로그 버전</strong>이라고 생각하면 됩니다.</p>
<pre><code>아날로그 입력 → 샘플 얻기 → 저장 탱크에 고정</code></pre><h3 id="🧮-2️⃣-다음-단계-값을-비교해서-디지털로-바꾸기-→-플래시-변환기-방식">🧮 2️⃣ 다음 단계: 값을 비교해서 디지털로 바꾸기 → <strong>플래시 변환기 방식</strong></h3>
<p>이제 저장된 아날로그 값을 여러 전압 기준들과 <strong>비교기(comparator)</strong>를 통해 비교합니다.<br />이 과정을 빠르게 병렬로 처리한 것이 바로 <strong>플래시 변환기(Flash ADC)</strong>입니다.</p>
<p>🧠 특징 요약:</p>
<ul>
<li>기준 전압 여러 개 + 비교기 여러 개</li>
<li>엄청 빠르지만 비효율적 (비트를 낭비함)</li>
<li>회로가 비싸고 복잡함</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/0d42900a-a93a-4289-acba-df1f457a71b4/image.png" /></p>
<blockquote>
<p>플래시 ADC는 <strong>“속도는 빠르지만, 비용이 비싸고 비트 낭비가 큼”</strong> 이라는 특징이 있어요.</p>
</blockquote>
<h3 id="3️⃣-조금-느리지만-더-효율적으로-→-램프-변환기ramp-converter">3️⃣ 조금 느리지만 더 효율적으로! → <strong>램프 변환기(Ramp Converter)</strong></h3>
<p>RAM처럼 <strong>차근차근 하나씩 증가</strong>시키며 변환하는 방식도 있습니다.<br />저장된 아날로그 값과 DAC 출력을 비교하면서, DAC의 출력을 1씩 올려서 일치할 때까지 찾는 방식이에요.</p>
<pre><code class="language-c">DAC값 = 0부터 시작 → 저장된 샘플값과 같아질 때까지 계속 증가</code></pre>
<p>📉 단점:  </p>
<ul>
<li>변환 시간이 <strong>신호 크기에 비례</strong> (최대 2ⁿ 클록 걸릴 수도)</li>
</ul>
<h3 id="🔍-4️⃣-더-빠르고-똑똑하게-→-연속-추정-변환기successive-approximation-adc">🔍 4️⃣ 더 빠르고 똑똑하게! → <strong>연속 추정 변환기(Successive Approximation ADC)</strong></h3>
<p>이 방식은 마치 <strong>2진 검색(binary search)</strong>을 하듯 변환을 진행합니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/6060a099-1ccd-4e99-85a8-346e3671d7a4/image.png" /></p>
<blockquote>
<p>📌 한마디로 &quot;가운데부터 찍고, 작으면 오른쪽, 크면 왼쪽&quot;을 반복!</p>
</blockquote>
<p>🧭 동작 방식:</p>
<ol>
<li>DAC를 중간값으로 설정</li>
<li>비교기를 통해 샘플보다 큰지 작은지 판단</li>
<li>범위를 절반으로 줄이며 다시 시도</li>
<li>이 과정을 log₂(n) 회 반복</li>
</ol>
<p>📌 <strong>효율 최고!</strong> 속도도 적당하고 회로도 합리적이에요.</p>
<p>🎯 오늘날 <strong>가성비 좋은 ADC</strong> 대부분은 이 방식!</p>
<h3 id="🎯-adc-흐름-요약">🎯 ADC 흐름 요약</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/0bc66fe1-2f83-4dbd-8070-13ec6f8cf78c/image.png" /></p>
<table>
<thead>
<tr>
<th>단계</th>
<th>설명</th>
<th>예시 장치</th>
</tr>
</thead>
<tbody><tr>
<td>1️⃣ 샘플링</td>
<td>아날로그 신호의 특정 시점 값 포착</td>
<td>샘플 앤드 홀드</td>
</tr>
<tr>
<td>2️⃣ 비교</td>
<td>기준 전압과 비교해 디지털 값 생성</td>
<td>비교기, DAC</td>
</tr>
<tr>
<td>3️⃣ 변환 방식</td>
<td>빠르게? 정밀하게? 다양한 전략</td>
<td>플래시 / 램프 / 연속 추정 방식</td>
</tr>
</tbody></table>
<h3 id="🔁-마무리-요약">🔁 마무리 요약</h3>
<blockquote>
<p>ADC는 현실의 연속적인 아날로그 정보를<br />컴퓨터가 이해할 수 있도록 0과 1의 세계로 바꿔주는 다리입니다.</p>
</blockquote>
<ul>
<li>플래시는 빠르지만 비쌈</li>
<li>램프는 단순하지만 느림</li>
<li>연속 추정은 가장 <strong>실용적</strong></li>
</ul>
<h3 id=""></h3>
<h3 id="🎚️-dac-vs-adc-비교-요약">🎚️ DAC vs ADC 비교 요약</h3>
<pre><code>&quot;내 목소리 → ADC → FIFO → CPU → 네트워크&quot;

&quot;상대방 음성 ← DAC ← FIFO ← CPU ← 네트워크&quot;</code></pre><table>
<thead>
<tr>
<th>항목</th>
<th>DAC</th>
<th>ADC</th>
</tr>
</thead>
<tbody><tr>
<td>기능</td>
<td>디지털 → 아날로그</td>
<td>아날로그 → 디지털</td>
</tr>
<tr>
<td>대표 사용처</td>
<td>음악 재생, 스피커</td>
<td>마이크, 센서 데이터</td>
</tr>
<tr>
<td>핵심 부품</td>
<td>전압 생성기, 포트</td>
<td>비교기, 샘플 앤드 홀드</td>
</tr>
<tr>
<td>해상도</td>
<td>단계 수 (ex. 256단계)</td>
<td>샘플링 간격, 정확도</td>
</tr>
<tr>
<td>변환 방식</td>
<td>포트 출력 → 전압</td>
<td>플래시 / 램프 / 이진 탐색 등</td>
</tr>
</tbody></table>
<blockquote>
<p>&quot;컴퓨터가 현실을 이해하려면 ADC가,<br />현실이 컴퓨터를 표현하려면 DAC가 필요하다.&quot;</p>
</blockquote>
<h2 id="adc-dac-fifo가-같은-공간에-있는가">ADC, DAC, FIFO가 같은 공간에 있는가?</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/8042d117-936e-44b2-82d3-d211668ed95b/image.png" /></p>
<blockquote>
<p>✅ <strong>같은 칩(SoC) 안에 같이 존재할 수 있습니다!</strong><br />❌ 하지만 <strong>무조건 같이 있는 건 아닙니다.</strong> 설계 목적에 따라 달라요.</p>
</blockquote>
<h3 id="🔧-예시-1-마이크-입력-전용-장치-예-음성인식용-soc">🔧 예시 1: 마이크 입력 전용 장치 (예: 음성인식용 SoC)</h3>
<ul>
<li><strong>ADC만 있음</strong></li>
<li>마이크 → ADC → CPU (DAC은 필요 없음)</li>
</ul>
<h3 id="🎧-예시-2-오디오-재생-전용-장치-예-블루투스-이어폰">🎧 예시 2: 오디오 재생 전용 장치 (예: 블루투스 이어폰)</h3>
<ul>
<li><strong>DAC만 있음</strong></li>
<li>CPU → DAC → 스피커 (ADC는 필요 없음)</li>
</ul>
<h3 id="📱-예시-3-스마트폰-태블릿-노트북">📱 예시 3: 스마트폰, 태블릿, 노트북</h3>
<ul>
<li><strong>ADC + DAC + FIFO가 다 같이</strong> 한 <strong>SoC(System on Chip)</strong> 안에 포함  </li>
<li>오디오, 영상, 센서 입력/출력까지 종합처리하니까 전부 필요</li>
</ul>
<h3 id="🔍-fifo는-어디에">🔍 FIFO는 어디에?</h3>
<ul>
<li>FIFO는 <strong>ADC나 DAC 근처에 위치</strong>합니다  </li>
<li>왜냐면: ADC/DAC가 <strong>고속 신호 처리</strong>를 하니까,<br /><strong>버퍼링(임시 저장)</strong>을 해야 안정적으로 처리할 수 있기 때문이죠</li>
</ul>
<h3 id="💡-결론">💡 결론</h3>
<blockquote>
<p>✅ 같은 장치 안, 혹은 같은 칩 안에 <strong>ADC, DAC, FIFO가 함께 들어있는 경우가 많지만</strong>,  
목적이 단순한 기기라면 그중 일부만 포함되어 있을 수도 있어요.</p>
</blockquote>
<h1 id="🎵-아날로그-소리를-디지털로-담아내는-마법">🎵 아날로그 소리를 디지털로 담아내는 마법</h1>
<h2 id="1-왜-소리를-잘게-쪼개야-할까">1) 왜 소리를 잘게 쪼개야 할까?</h2>
<p>우리 귀에 들리는 소리는 실제로는 <strong>연속적인 파동</strong>이에요. 마치 물결처럼 부드럽게 흘러가죠.<br />하지만 컴퓨터는 이런 연속된 정보를 이해하지 못해요. 그래서 <strong>샘플링</strong>이라는 방식을 사용해요.</p>
<p><strong>샘플링</strong>은 이렇게 작동해요:</p>
<blockquote>
<p>“이 파형의 높이를 0.001초마다 한 번씩 기록하자!”</p>
</blockquote>
<p>그렇게 되면, 멋진 사인파도 정해진 간격으로 '딱딱' 잘라서 숫자로 저장되죠. 이 숫자는 나중에 DAC를 통해 다시 소리로 바뀌어요.</p>
<h2 id="2-샘플링-간격을-어떻게-정할까">2) 샘플링 간격을 어떻게 정할까?</h2>
<p>스웨덴의 전기 엔지니어 <strong>해리 나이퀴스트</strong>는 이렇게 말했어요:</p>
<blockquote>
<p>&quot;소리의 최고 주파수의 <strong>두 배 이상</strong>으로 샘플링해야 원래 소리를 잘 복원할 수 있어!&quot;</p>
</blockquote>
<p>이걸 <strong>나이퀴스트 샘플링 이론</strong>이라고 부릅니다.</p>
<p>예: 인간이 들을 수 있는 가장 높은 주파수는 약 20kHz<br />→ <strong>샘플링 주파수는 최소 40kHz 이상</strong>이어야 한다는 뜻!</p>
<h2 id="3-샘플링만-하면-끝일까">3) 샘플링만 하면 끝일까?</h2>
<p>그렇지 않아요! 높은 주파수가 섞이면 가짜 소리, <strong>에일리어스(alias)</strong>가 생겨요.</p>
<blockquote>
<p>🎧 &quot;21kHz 소리를 40kHz로 샘플링하면, 진짜 소리가 19kHz로 거짓말을 하고 나와요!&quot;</p>
</blockquote>
<p>그래서 등장한 게 바로 <strong>로우패스 필터</strong>입니다.</p>
<p>이 필터는 <strong>높은 주파수를 잘라내는 칼날</strong>이에요. 샘플링 전에 필터를 거쳐야 진짜 소리만 담을 수 있어요.</p>
<h2 id="4-푸리에-변환-파동의-dna를-풀다">4) 푸리에 변환: 파동의 DNA를 풀다</h2>
<p>모든 복잡한 소리는 여러 개의 사인파(=순수한 소리)를 섞은 거예요.<br />이걸 수학적으로 분석해주는 게 바로 <strong>푸리에 변환(Fourier Transform)</strong>!</p>
<blockquote>
<p>🎼 “도, 미, 솔이 섞인 소리? 그건 400Hz, 494Hz, 587Hz 사인파가 섞인 G메이저 코드야!”</p>
</blockquote>
<p>그래서 컴퓨터가 소리를 분석하거나 편집할 때는 푸리에 변환으로 <strong>파동의 구성 성분</strong>을 먼저 알아봐요.</p>
<h2 id="5-음악-파일은-어떻게-작아질까">5) 음악 파일은 어떻게 작아질까?</h2>
<p>CD 품질은 샘플링 주파수 44.1kHz, 16비트 샘플 = 1초에 175KB! 꽤 큰 용량이죠.<br />그래서 소리를 <strong>압축</strong>합니다.</p>
<ul>
<li><strong>무손실 압축 (예: FLAC)</strong> : 원래 소리를 그대로, 하지만 반쯤 줄어들어요.</li>
<li><strong>손실 압축 (예: MP3, AAC)</strong> : 사람 귀가 못 듣는 소리는 버려서 많이 줄어들어요.</li>
</ul>
<p>그런데… <strong>모든 귀가 똑같진 않아요!</strong><br />민감한 사람은 MP3에서 누락된 소리를 바로 느낄 수 있답니다.</p>
<h2 id="🎧-fm-스테레오와-위상의-마법">🎧 FM 스테레오와 위상의 마법</h2>
<p>FM 스테레오는 <strong>왼쪽/오른쪽 소리를 교대로 샘플링</strong>하고, 다시 조합해 스테레오를 만들어요.<br />스테레오의 핵심은 <strong>위상 차이</strong>. 소리가 어느 쪽에서 오는지 구분하는 감각이죠.</p>
<blockquote>
<p>&quot;머리가 클수록 스테레오 감각이 더 뛰어나다고요? 진짜예요!&quot;</p>
</blockquote>
<h2 id="🧠-핵심-요약">🧠 핵심 요약</h2>
<table>
<thead>
<tr>
<th>용어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>샘플링</td>
<td>아날로그 소리를 일정 간격으로 숫자로 기록</td>
</tr>
<tr>
<td>나이퀴스트 이론</td>
<td>최고 주파수의 2배 이상으로 샘플링해야 함</td>
</tr>
<tr>
<td>로우패스 필터</td>
<td>높은 주파수를 제거해 에일리어스 방지</td>
</tr>
<tr>
<td>푸리에 변환</td>
<td>복잡한 소리를 여러 사인파로 분해</td>
</tr>
<tr>
<td>압축</td>
<td>소리를 작게 만드는 기술 (FLAC, MP3 등)</td>
</tr>
<tr>
<td>위상</td>
<td>소리가 공간에서 어디서 오는지 느끼게 해주는 정보</td>
</tr>
</tbody></table>
<h1 id="🎨-컴퓨터는-어떻게-보는가--디지털-이미지와-시각의-비밀">🎨 컴퓨터는 어떻게 '보는'가? – 디지털 이미지와 시각의 비밀</h1>
<h2 id="1-👀-세상을-보는-방식-컴퓨터에게는-낯설다">1. 👀 세상을 보는 방식, 컴퓨터에게는 낯설다</h2>
<p>우리는 세상을 ‘연속적인 색과 빛’으로 봅니다. 자연의 풍경도, 고양이의 털 한 올도…<br />하지만 컴퓨터는 이 연속적인 세상을 이해할 수 없습니다.<br />그래서 ‘조금씩 나눠서’ 기억해야 하죠.<br />이 과정을 우리는 <strong>샘플링(sampling)</strong>이라고 부릅니다.</p>
<p>📸 사진 한 장도 사실은 수많은 <strong>픽셀(pixel, 그림 요소)</strong>로 이루어진 작은 사각형 타일들입니다.<br />그리고 각 타일은 <strong>빨간색, 초록색, 파란색(RGB)</strong>으로 이루어진 조합으로 색을 표현하죠.  </p>
<p>오늘날 디스플레이는 <strong>RGB 각각에 8비트</strong>, 총 24비트 컬러를 사용합니다.<br />즉, 한 픽셀이 표현할 수 있는 색상은 무려 16,777,216가지!</p>
<p>하지만 해상도가 높아질수록 더 많은 픽셀이 필요하겠죠?<br />더 좋은 화면은 더 많은 데이터를 먹습니다.<br />그래서 등장한 것이 바로… <strong>압축 기술</strong>입니다.</p>
<h2 id="2-🖼️-jpeg-이미지도-머리-좋게-기억한다">2. 🖼️ JPEG, 이미지도 머리 좋게 기억한다</h2>
<p>이미지를 그냥 저장하면 메모리를 금방 잡아먹겠죠.<br />그래서 컴퓨터는 머리를 씁니다.</p>
<p>&quot;어? 옆에 있는 픽셀이랑 색이 비슷하네?<br />그럼 그냥 그 비슷함을 저장하면 되겠네!&quot;  </p>
<p>이게 바로 <strong>JPEG 압축</strong>입니다.<br />정확히 모든 픽셀을 저장하지 않고, 주변과의 <strong>유사성</strong>만 기억해요.<br />사람의 시각은 색보다 밝기에 더 민감하기 때문에, 색은 조금 손해봐도 괜찮다고 판단하죠.  </p>
<blockquote>
<p>JPEG은 마치 &quot;화면을 기억하는 게 아니라 느낌을 기억하는 방식&quot;입니다.</p>
</blockquote>
<h2 id="3-🎥-비디오란-이미지가-시간-위를-걷기-시작한-것">3. 🎥 비디오란? 이미지가 시간 위를 걷기 시작한 것</h2>
<p>비디오는 이미지가 ‘시간을 걷기’ 시작한 것입니다.<br />초당 24프레임, 30프레임, 60프레임… 우리는 빠르게 바뀌는 정지화를 ‘움직임’으로 인식하죠.<br />하지만 이걸 저장하려면?</p>
<p>예:<br />3840 × 2160 해상도 × RGB(3바이트) × 초당 60프레임<br />= 무려 <strong>1.5GB/s의 데이터</strong>가 필요합니다!</p>
<p>🤯 절대 감당 안 되겠죠.<br />그래서 <strong>비디오 압축</strong>은 프레임 사이의 ‘변화된 부분만’ 저장합니다.</p>
<p>미스터 시그마가 택배 받으러 가는 비디오를 생각해보세요.<br />집도 배경도 그대로고, 바뀌는 건 미스터 시그마의 위치뿐이니까요.  </p>
<p>이걸 우리는 <strong>움직임 보상(Motion Compensation)</strong>이라 부릅니다.</p>
<p>하지만 이 방식은 중간 데이터가 깨지면 전체 영상이 깨질 수 있죠.<br />그래서 중간중간 완전한 이미지인 <strong>키프레임(keyframe)</strong>을 넣어 복구가 가능하게 합니다.</p>
<h2 id="4-🧪-디스플레이의-진화--crt에서-lcd-그리고-픽셀-전쟁">4. 🧪 디스플레이의 진화 – CRT에서 LCD, 그리고 픽셀 전쟁</h2>
<p>처음에는 전자총을 쏘는 <strong>CRT</strong> 디스플레이가 주력이었습니다.<br />CRT는 인광물질 위에 <strong>벡터(선)</strong>를 그리듯 이미지를 표시했죠.<br />하지만 이건 선형 작업이라 <strong>화면에 가득 찬 이미지를 표시하기 어려웠습니다.</strong></p>
<p>그래서 등장한 방식이 <strong>래스터(raster)</strong><br />즉, 왼쪽에서 오른쪽, 위에서 아래로 차례차례 줄 긋듯이 화면을 채우는 방식입니다.</p>
<p>🖥️ 오늘날 대부분의 디스플레이는 래스터 기반입니다.<br />화면을 구성하는 수많은 점들을 빠르게 켜고 끄며 이미지를 보여주죠.</p>
<p>물론 해상도가 낮으면 <strong>모서리가 깨지거나 울퉁불퉁</strong>해 보입니다.<br />이를 해결하려고 등장한 기술이 바로 <strong>슈퍼샘플링</strong>, <strong>안티에일리어싱</strong> 같은 기술입니다.</p>
<h2 id="5-👆-휴먼-인터페이스--마우스와-키보드-이야기">5. 👆 휴먼 인터페이스 – 마우스와 키보드 이야기</h2>
<p>우리가 컴퓨터와 대화하는 방법도 진화했습니다.</p>
<p>처음엔 펀치카드로 대화했어요.<br />그다음엔 <strong>텔레타이프 터미널(TTY)</strong>, 종이에 텍스트를 뽑아주는 방식이었죠.</p>
<p>시간이 흐르면서 화면 기반 <strong>그래픽 터미널</strong>이 등장합니다.<br />그리고 여기서 우리는…</p>
<ul>
<li><strong>마우스</strong>를 통해 자유로운 위치를 지정하고,  </li>
<li><strong>키보드</strong>로 빠르게 명령을 입력하고,  </li>
<li><strong>터치스크린</strong>으로 직접 화면을 ‘만질 수’ 있게 됐습니다.</li>
</ul>
<p>이제는 손가락 하나로 그림을 그리고, 명령을 내리며, 세계와 연결될 수 있는 시대가 되었죠.</p>
<h2 id="✨-마무리-요약">✨ 마무리 요약</h2>
<table>
<thead>
<tr>
<th>구분</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody><tr>
<td>디지털 이미지</td>
<td>RGB 24비트 컬러, 픽셀 기반 샘플링</td>
</tr>
<tr>
<td>이미지 압축</td>
<td>JPEG: 이웃한 픽셀 색상 유사성 활용</td>
</tr>
<tr>
<td>비디오</td>
<td>초당 수십 장 이미지, 변화된 영역만 저장</td>
</tr>
<tr>
<td>디스플레이</td>
<td>CRT → LCD, 래스터 방식으로 점을 표현</td>
</tr>
<tr>
<td>입력 장치</td>
<td>키보드, 마우스, 터치: 사용자의 명령 인터페이스</td>
</tr>
</tbody></table>
<blockquote>
<p>“화면 속의 세상은 전자와 픽셀의 언어로 말합니다.<br />그리고 우리는 그 언어를 이해하는 시대에 살고 있죠.”  </p>
</blockquote>