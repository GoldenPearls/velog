<p>컴퓨터를 사용하다 보면 *<em>갑자기 프로그램이 느려지거나 종료되는 답답한 경험을 한 적 있으신가요? *</em></p>
<blockquote>
<p>이런 문제들은 대부분 '메모리 부족' 때문입니다.</p>
</blockquote>
<p>혹시 컴퓨터가 메모리를 어떻게 관리하는지 궁금했던 적 있나요? 사실 우리 컴퓨터는 메모리를 매우 꼼꼼하고 영리하게 관리하고 있답니다. 특히 리눅스라는 운영체제는 &quot;모든 메모리를 직접 관리한다!&quot; 라는 철학을 가지고 있어요. 오늘은 이 복잡한 메모리 관리 과정을 친절하고 재미있게 풀어 드릴게요~</p>
<h1 id="🚦-1장-리눅스는-메모리를-어떻게-관리할까요">🚦 1장: 리눅스는 메모리를 어떻게 관리할까요?</h1>
<h2 id="🌟-메모리-전체를-리눅스가-관리한다고요">🌟 메모리 전체를 리눅스가 관리한다고요?</h2>
<p>네, 맞습니다! 리눅스는 시스템에 설치된 메모리를 혼자서 깔끔하게 관리합니다. 
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/d25d56bc-202b-4529-8fe2-56b7a928d588/image.png" /></p>
<blockquote>
<p>그 말은 <code>커널(리눅스의 핵심!)</code>이 프로세스와 자신이 사용할 메모리까지 모두 관리한다는 뜻이에요. </p>
</blockquote>
<p>커널은 마치 엄마처럼 집안의 모든 방을 꼼꼼히 관리하는 역할을 하는데요. 프로세스들이 메모리를 요구할 때마다 이를 적절히 할당해주는 역할을 합니다.</p>
<p>이렇게 하면 프로세스들은 필요한 만큼 메모리를 얻을 수 있고, <strong>불필요한 메모리는 빠르게 반환됩
니다.</strong> 깨끗한 방을 유지하려면 엄마가 직접 청소해야 하듯이, 리눅스도 커널이 나서서 메모리 정리를 하는 거죠~</p>
<p>예를 들어, 집에 여러 개의 방이 있다면 커널은 각각의 방에 누가 들어가 있고, 어디가 비어 있는지 항상 체크하는 똑똑한 집주인이에요.</p>
<pre><code class="language-bash">$ free</code></pre>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/8c516542-0db0-49a0-92a1-3a5deda4ea63/image.png" /></p>
<p>이 명령어를 통해 현재 메모리 상태를 간편하게 확인할 수 있답니다.</p>
<p>이 명령어를 실행하면 전체 메모리 크기(total), 사용 중인 메모리(used), 남아 있는 메모리(free), 캐시로 사용하는 메모리(buff/cache), 실제로 사용 가능한 메모리(available)까지 보여줍니다. (친절하죠?)</p>
<h3 id="📚-필드별로-쉽게-이해하기">📚 필드별로 쉽게 이해하기</h3>
<h3 id="사진으로-쉽게-이해하기">사진으로 쉽게 이해하기</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/08b2cebb-38b7-44f6-9f73-7c95dc4d4aaf/image.png" /></p>
<ol>
<li><strong>total</strong>  </li>
</ol>
<ul>
<li>시스템 전체에 설치된 물리 메모리의 총량입니다.  </li>
<li>그림의 전체 너비가 바로 total 영역이에요.</li>
</ul>
<ol start="2">
<li><strong>used = total - free - buff/cache</strong></li>
</ol>
<ul>
<li>실제로 사용 중인 메모리입니다.</li>
<li>여기에는 프로세스가 직접 사용하는 메모리뿐만 아니라 커널이 사용하는 메모리도 포함됩니다.</li>
</ul>
<ol start="3">
<li><strong>free</strong></li>
</ol>
<ul>
<li>아직 아무도 사용하지 않은, <strong>명목상 '비어 있는 메모리'</strong>입니다.</li>
<li>하지만 실제로는 <strong>available</strong> 항목이 더 정확한 ‘사용 가능한 메모리’를 나타냅니다.</li>
<li>free 항목은 프로세스가 바로 접근 가능한 영역만 포함합니다.</li>
</ul>
<ol start="4">
<li><strong>buff/cache</strong></li>
</ol>
<ul>
<li>커널이 디스크 I/O 성능 향상을 위해 사용 중인 캐시 메모리입니다.</li>
<li><code>buffer</code>: 디스크 블록을 임시로 저장해두는 공간  </li>
<li><code>cache</code>: 파일 내용을 저장해두는 공간  </li>
<li>이 영역은 <strong>필요 시 해제 가능한 부분(노란색)</strong>과 <strong>해제 불가능한 부분(갈색)</strong>으로 나뉩니다.</li>
</ul>
<ol start="5">
<li><strong>available</strong></li>
</ol>
<ul>
<li>실제로 애플리케이션이 사용할 수 있는 메모리 양입니다.</li>
<li>free + buff/cache 중에서 <strong>커널이 해제 가능한 부분</strong>을 합친 값이에요.</li>
<li>그림에서는 ‘해제 가능’ 부분과 ‘free’를 합쳐서 available로 표시하고 있죠.</li>
</ul>
<ol start="6">
<li><strong>프로세스가 사용 중</strong></li>
</ol>
<ul>
<li>애플리케이션이나 사용자 프로그램이 현재 점유 중인 메모리입니다.</li>
<li>이 영역은 커널이 알아서 회수하지 않으며, 해당 프로세스가 종료되어야 해제됩니다.</li>
</ul>
<p><strong>✅ 요약</strong></p>
<table>
<thead>
<tr>
<th>항목</th>
<th>의미 요약</th>
</tr>
</thead>
<tbody><tr>
<td><strong>total</strong></td>
<td>시스템에 설치된 메모리 총량</td>
</tr>
<tr>
<td><strong>free</strong></td>
<td>바로 사용 가능한 메모리 (작음)</td>
</tr>
<tr>
<td><strong>available</strong></td>
<td>실제로 사용 가능한 메모리. free 필드값과 비어 있는 메모리가 줄어 들었을 때 해제 가능한 커널 내부 메모리 영역(예를 들어 페이지 캐시) 크기를 더한 값 (큰 값)</td>
</tr>
<tr>
<td><strong>buff/cache</strong></td>
<td>커널이 캐시로 점유한 메모리이자, 데이터를 빠르게 접근하기 위해 저장한 임시 공간</td>
</tr>
<tr>
<td><strong>used</strong></td>
<td>프로세스 + 커널이 사용 중인 메모리</td>
</tr>
</tbody></table>
<p>이 그림을 이해하면 <code>free</code> 명령어 결과를 해석할 때 숫자에 너무 얽매이지 않고, <strong>커널이 얼마나 유동적으로 메모리를 관리하는지</strong> 감을 잡을 수 있습니다! </p>
<h1 id="🚧-2장-used와-buffcache의-비밀을-풀어보자">🚧 2장: used와 buff/cache의 비밀을 풀어보자!</h1>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/e99fc03f-adfa-4d85-9aa8-6072ab4cda90/image.png" /></p>
<h2 id="🗃-used-메모리의-진짜-모습">🗃 used 메모리의 진짜 모습</h2>
<p>간단하게 이야기하면 <code>used</code>는** 프로세스가 쓰고 있는 메모리, 그리고 커널 자신이 쓰고 있는 메모리를 모두 포함한 값이에요.**</p>
<p>'used' 메모리는 실제로 프로세스가 점유하고 있는 공간과, 커널이 스스로 사용하는 공간을 모두 포함한 값이라는 거죠. 프로그램이 작동할 때마다 점점 올라가고, 프로그램이 종료되면 다시 내려갑니다. 마치 도서관에서 책을 빌렸다가 반납하면 빈자리가 다시 생기는 것과 같은 원리죠.</p>
<blockquote>
<p>만약 어떤 프로세스가 종료되면, *<em>커널이 알아서 그 메모리를 깨끗하게 비워주는 거죠. *</em></p>
</blockquote>
<p>실제로 메모리를 많이 쓰는 프로그램을 실행한 뒤 종료하면, used 값이 다시 원래대로 돌아가는 걸 눈으로 확인할 수 있어요. (신기하죠?)</p>
<h2 id="memusepy-실험">memuse.py 실험</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/fa4eb395-ed93-4263-8313-f5238da0d7de/image.png" /></p>
<h3 id="✅-memusepy-전체-코드-해설-주석-추가">✅ memuse.py 전체 코드 (해설 주석 추가)</h3>
<pre><code class="language-python">#!/usr/bin/python3
import subprocess

# 사용할 리스트 크기 설정 (데이터 수: 1천만 개)
# 너무 크면 메모리 부족으로 실행 실패할 수 있음
size = 10000000

# 현재 시스템 메모리 상태를 출력 (실험 전 상태)
print(&quot;메모리 사용 전의 전체 시스템 메모리 사용량을 표시합니다.&quot;)
subprocess.run([&quot;free&quot;])

# 리스트에 0을 1천만 개 생성 (메모리를 실제로 할당함)
array = [0] * size

# 메모리 사용 후의 시스템 상태 출력
print(&quot;메모리 사용 후의 전체 시스템 메모리 남은 용량을 표시합니다.&quot;)
subprocess.run([&quot;free&quot;])</code></pre>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/1c3628ea-02c2-48ee-94f5-a2ff4f1dc8df/image.png" /></p>
<h3 id="📌-실행-순서별-요약">📌 실행 순서별 요약:</h3>
<ol>
<li><strong>프로그램 실행 전 <code>free</code> 출력</strong></li>
<li><strong>리스트를 생성하며 메모리 사용 (<code>array = [0] * 10000000</code>)</strong></li>
<li><strong>프로그램 내부에서 다시 <code>free</code> 출력</strong></li>
<li><strong>프로그램 종료 후, 사용자가 터미널에서 <code>free</code> 재실행</strong></li>
</ol>
<h3 id="🔍-각-단계-분석">🔍 각 단계 분석</h3>
<h4 id="✅-1-프로그램-실행-전">✅ 1. 프로그램 실행 전</h4>
<pre><code class="language-bash">Mem:  16257384  513144   15338352  3572  405888  15474572</code></pre>
<ul>
<li><strong>total</strong>: 16.2GiB (16257384 KiB)</li>
<li><strong>used</strong>: 513144 KiB</li>
<li><strong>free</strong>: 15.3GiB</li>
<li><strong>buff/cache</strong>: 405888 KiB</li>
<li><strong>available</strong>: 15474572 KiB</li>
</ul>
<p>🔎 상태:<br />→ 전체 시스템 메모리 중 대부분이 아직 사용되지 않음 (정상적인 idle 상태)</p>
<h4 id="✅-2-프로그램-실행-후-array-생성-직후">✅ 2. 프로그램 실행 후 (array 생성 직후)</h4>
<pre><code class="language-bash">Mem:  16257384  593596  15257900  3572  405888  15394120</code></pre>
<ul>
<li><strong>used</strong>가 <strong>+80MiB</strong> 증가<br />→ <code>593596 - 513144 = 80452 KiB ≈ 78.5MiB</code></li>
</ul>
<p>🔎 해석:<br />→ Python 리스트 생성으로 약 <strong>80MiB 메모리</strong>가 사용됨<br />→ <code>available</code> 값도 함께 감소함</p>
<h4 id="✅-3-프로그램-종료-후-터미널에서-free-재실행">✅ 3. 프로그램 종료 후 (터미널에서 free 재실행)</h4>
<pre><code class="language-bash">Mem:  16257384  523968  15546368  3576  187048  15474436</code></pre>
<ul>
<li><strong>used</strong>: 523968 (다시 거의 원래대로 돌아옴)</li>
<li><strong>buff/cache</strong>: 감소 (405888 → 187048)  </li>
<li><strong>available</strong>: 다시 원래 수준인 15474436</li>
</ul>
<p>🔎 해석:</p>
<ul>
<li>프로그램이 종료되자 <strong>array에 할당됐던 메모리가 커널에 의해 해제</strong>됨</li>
<li><code>used</code> 수치가 다시 줄고, <code>available</code>도 회복</li>
<li><strong>정확히 종료 전과 일치하진 않지만 거의 같은 수준</strong> (이는 다른 백그라운드 활동 때문일 수 있음)</li>
</ul>
<h4 id="📊-핵심-정리">📊 핵심 정리</h4>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/09c5452f-b170-479c-846d-6484d9acf2f3/image.png" /></p>
<table>
<thead>
<tr>
<th>구분</th>
<th>used (KiB)</th>
<th>available (KiB)</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>실행 전</td>
<td>513,144</td>
<td>15,474,572</td>
<td>대부분 여유 상태</td>
</tr>
<tr>
<td>array 생성 후</td>
<td>593,596</td>
<td>15,394,120</td>
<td>약 80MiB 사용 증가</td>
</tr>
<tr>
<td>종료 후</td>
<td>523,968</td>
<td>15,474,436</td>
<td>사용량 거의 복귀됨</td>
</tr>
</tbody></table>
<h4 id="✅-결론">✅ 결론</h4>
<ul>
<li><code>memuse.py</code> 실행 후 메모리를 사용한 흔적이 <strong><code>used</code> 수치의 증가</strong>로 보였고,  </li>
<li>프로세스가 종료되자 메모리가 자동으로 해제되어 <strong>다시 줄어든 것</strong>을 확인할 수 있습니다.</li>
<li><strong>이것이 리눅스 메모리 관리 시스템의 특징</strong>이며, 우리가 프로그램 종료 시 직접 <code>free()</code>하지 않아도 되는 이유예요.</li>
</ul>
<h4 id="💡-참고-팁">💡 참고 팁</h4>
<ul>
<li>Python은 가비지 컬렉터가 있어도, 프로세스가 종료되기 전까지는 메모리가 유지됩니다.</li>
<li>이 실험은 <strong>메모리 사용 추세 분석</strong>이나 <strong>OOM 상황 디버깅</strong> 시 유용합니다.</li>
<li>같은 방식으로 <code>free</code>나 <code>top</code>, <code>sar</code> 명령어와 함께 메모리 변화 패턴을 파악해보는 것도 좋아요.</li>
</ul>
<blockquote>
<p>&quot;프로그램이 종료되면 해당 메모리는 운영체제(리눅스 커널)에 의해 회수된다&quot;
는 사실을 증명하는 근거입니다.</p>
</blockquote>
<h2 id="✨-buffcache의-마법">✨ buff/cache의 마법</h2>
<p>buff/cache는 데이터를 미리 메모리에 올려놓아 다음 번 접근할 때 속도를 높이는 <code>캐시 메모리</code>입니다. 빈번히 읽는 데이터를 계속해서 하드디스크에서 읽으면 시간이 오래 걸리니까, 자주 쓰는 책을 책상 위에 올려놓는 것과 같아요.</p>
<h2 id="✅-실험하기">✅ 실험하기</h2>
<pre><code class="language-bash">#!/bin/bash
# 1. 파일 작성 전 시스템 메모리 상태 출력
echo &quot;파일 작성 전의 시스템 전체 메모리 사용량을 표시합니다.&quot;
free

# 2. 1GiB 크기의 파일을 생성하여 페이지 캐시 사용 유도
echo &quot;1GB 파일을 새로 작성합니다. 커널은 메모리에 1GB 페이지 캐시 영역을 사용합니다.&quot;
dd if=/dev/zero of=testfile bs=1M count=1024

# 3. 파일 생성 후 메모리 상태 출력 → 페이지 캐시 증가 확인
echo &quot;페이지 캐시 사용 후의 시스템 전체 메모리 사용량을 표시합니다.&quot;
free

# 4. 파일 삭제 → 페이지 캐시 제거
echo &quot;파일 삭제 후, 즉 페이지 캐시 삭제 후의 시스템 전체 메모리 사용량을 표시합니다.&quot;
rm testfile

# 5. 파일 삭제 후 메모리 상태 출력 → buff/cache 감소 확인
free</code></pre>
<h3 id="📊-실험-결과-정리">📊 실험 결과 정리</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/332f1dcc-08d0-4bdf-94c6-f1e1fa2b9c5f/image.png" /></p>
<table>
<thead>
<tr>
<th>단계</th>
<th>used (KiB)</th>
<th>buff/cache (KiB)</th>
<th>free (KiB)</th>
<th>available (KiB)</th>
</tr>
</thead>
<tbody><tr>
<td>파일 작성 전</td>
<td>523004</td>
<td>192476</td>
<td>15541864</td>
<td>15472644</td>
</tr>
<tr>
<td>파일 작성 후</td>
<td>522072</td>
<td>1269160</td>
<td>14466152</td>
<td>15451568</td>
</tr>
<tr>
<td>파일 삭제 후</td>
<td>521748</td>
<td>194128</td>
<td>15541508</td>
<td>15473096</td>
</tr>
</tbody></table>
<h3 id="📌-핵심-변화-요약">📌 핵심 변화 요약</h3>
<ol>
<li><p><strong>파일 작성 전 (baseline)</strong>  </p>
<ul>
<li><code>buff/cache</code>: 약 <strong>192MiB</strong></li>
<li>시스템이 안정된 상태, 페이지 캐시도 적당한 수준</li>
</ul>
</li>
<li><p><strong>파일 작성 후</strong>  </p>
<ul>
<li><code>buff/cache</code>: 약 <strong>1.2GiB로 급증</strong><br />→ 이는 <code>dd</code> 명령으로 <strong>1GiB 파일을 생성</strong>하면서, 커널이 해당 데이터를 <strong>페이지 캐시로 메모리에 저장했기 때문</strong>입니다.</li>
</ul>
</li>
<li><p><strong>파일 삭제 후</strong>  </p>
<ul>
<li><code>buff/cache</code>: <strong>다시 약 194MiB로 감소</strong><br />→ 커널이 <strong>사용하지 않는 페이지 캐시를 자동으로 해제</strong>했음을 보여줍니다.</li>
</ul>
</li>
</ol>
<h3 id="📈-시각적-변화-흐름">📈 시각적 변화 흐름</h3>
<pre><code class="language-plaintext">    buff/cache (KiB)

1.4M |                        
     |                     
1.2M |                ● 파일 작성 후
     |                     
 200K | ● 파일 작성 전    ● 파일 삭제 후
     |
     +----------------------------→ 시간 흐름
        작성 전     생성 후      삭제 후</code></pre>
<h3 id="🧠-해석-및-결론">🧠 해석 및 결론</h3>
<ul>
<li><code>dd</code> 명령으로 생성한 <strong>1GiB 파일의 내용은 디스크에만 저장되지 않고, 동시에 메모리의 페이지 캐시에 올라갑니다.</strong></li>
<li>이로 인해 <strong>buff/cache 값이 급격히 증가</strong>합니다.</li>
<li>하지만, 파일을 <code>rm</code> 명령어로 삭제하면 <strong>커널은 이 데이터가 더 이상 필요하지 않음을 인지하고 페이지 캐시를 해제</strong>합니다.</li>
<li>이 과정을 통해 메모리의 <strong>buff/cache 영역이 자동으로 줄어드는 것</strong>을 확인할 수 있습니다.</li>
</ul>
<h3 id="✅-정리하자면">✅ 정리하자면</h3>
<table>
<thead>
<tr>
<th>개념</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>페이지 캐시</td>
<td>디스크 데이터를 빠르게 접근하기 위해 메모리에 임시로 저장하는 영역</td>
</tr>
<tr>
<td>buff/cache</td>
<td>페이지 캐시 + 버퍼 캐시 영역을 나타냄</td>
</tr>
<tr>
<td>자동 해제</td>
<td>시스템이 필요하면 해당 메모리를 자동으로 반환 (커널이 똑똑함!)</td>
</tr>
</tbody></table>
<h3 id="🔍-실무에서의-팁">🔍 실무에서의 팁</h3>
<blockquote>
<p><code>free</code> 명령어로 메모리를 볼 때 <code>used</code>나 <code>free</code>만 보고 “메모리가 부족하다”고 오해하지 마세요!  
진짜 사용할 수 있는 메모리는 <code>available</code>이고, <code>buff/cache</code>는 <strong>필요 시 커널이 반납 가능한 메모리</strong>입니다.</p>
</blockquote>
<h2 id="free와-available-의미-차이">free와 available 의미 차이</h2>
<p><code>free</code>와 <code>available</code>은 모두 &quot;쓸 수 있는 메모리&quot;처럼 보이지만, 실제로는 <strong>완전히 다른 의미</strong>를 담고 있습니다. </p>
<table>
<thead>
<tr>
<th>항목</th>
<th>의미</th>
<th>왜 헷갈릴까?</th>
<th>진짜로 쓸 수 있나?</th>
</tr>
</thead>
<tbody><tr>
<td><code>free</code></td>
<td><strong>지금 아무도 사용하고 있지 않은 메모리 공간</strong></td>
<td>숫자가 작으면 “메모리 부족하잖아?!”라고 생각하기 쉬움</td>
<td>쓸 수 있지만, 시스템은 일부를 캐시로 활용 중</td>
</tr>
<tr>
<td><code>available</code></td>
<td><strong>필요할 경우 커널이 즉시 회수해서 사용할 수 있는 전체 메모리</strong></td>
<td>캐시 포함이라 <code>free</code>보다 훨씬 큼</td>
<td>진짜로 사용 가능한 메모리! 가장 신뢰해야 할 값</td>
</tr>
</tbody></table>
<h3 id="🔍-예시로-이해해보자">🔍 예시로 이해해보자</h3>
<pre><code class="language-bash">$ free
               total        used        free      shared  buff/cache   available
Mem:        16257384      523004     15541864        3576      192476     15472644</code></pre>
<ul>
<li><code>free</code>: 15,541,864 KiB → 진짜로 아무도 안 쓰는 공간  </li>
<li><code>available</code>: 15,472,644 KiB → 캐시까지 포함한 실제로 쓸 수 있는 공간</li>
</ul>
<blockquote>
<p>그런데 왜 <code>available</code>이 <code>free</code>보다 <strong>더 작을 수도 있고</strong>, <strong>더 클 수도 있냐</strong>면…</p>
</blockquote>
<p>🔎  <strong>왜 <code>available</code>이 <code>free</code>보다 클 수도 있을까?</strong></p>
<p>바로 <strong><code>buff/cache</code> 영역이 포함되기 때문</strong>입니다.</p>
<p>리눅스는 성능을 높이기 위해 <strong>가능한 많은 메모리를 캐시(임시 저장)로 사용</strong>합니다.<br />하지만 이 캐시 메모리는 커널이 <strong>필요하면 언제든 회수해서 다른 데 쓸 수 있어요</strong>.</p>
<p>그래서 <code>available</code>에는 다음이 포함돼요:</p>
<ul>
<li><code>free</code>: 아무도 안 쓰는 메모리</li>
<li><ul>
<li><code>buff/cache</code>: 캐시로 쓰이지만 곧 회수 가능</li>
</ul>
</li>
<li><ul>
<li>기타 reclaimable 영역 등</li>
</ul>
</li>
</ul>
<p>👉 즉, <code>available = free + reclaim 가능한 메모리</code></p>
<p><strong>예시로 보면 더 명확해요</strong></p>
<pre><code class="language-bash">              total        used        free      shared  buff/cache   available
Mem:        16257384      523004     15541864      3572     192476     15472644</code></pre>
<ul>
<li><code>free</code>: 15,541,864 KiB (15GB) → 지금 안 쓰고 있는 공간</li>
<li><code>available</code>: 15,472,644 KiB → 지금 <strong>쓸 수 있는 전체 공간</strong><br />→ 캐시 일부도 포함하니, 약간 <strong>작거나 클 수도</strong> 있어요.</li>
</ul>
<blockquote>
<p>🧐 그런데 왜 <code>available</code>이 <code>free</code>보다 작을 때도 있을까?</p>
</blockquote>
<p>그 이유는 다음과 같아요:</p>
<ul>
<li>시스템에 메모리를 많이 쓴 프로세스가 떠 있음</li>
<li><code>buff/cache</code> 영역도 많이 사용 중인데 <strong>당장 회수할 수 없는 상태</strong></li>
<li>즉, <strong>커널이 안전하게 회수할 수 있는 메모리 양이 적다</strong>고 판단하면<br />→ <code>available</code>은 <code>free</code>보다 작을 수도 있어요.</li>
</ul>
<table>
<thead>
<tr>
<th>상황</th>
<th><code>available</code> vs <code>free</code></th>
<th>이유</th>
</tr>
</thead>
<tbody><tr>
<td>일반적인 상황</td>
<td><code>available &gt; free</code></td>
<td>캐시 메모리 포함</td>
</tr>
<tr>
<td>메모리 빡빡한 상황</td>
<td><code>available &lt; free</code></td>
<td>회수 가능한 캐시가 거의 없음</td>
</tr>
<tr>
<td>파일 캐시, 버퍼 많을 때</td>
<td><code>available &gt; free</code></td>
<td>필요 시 회수 가능하므로 더 큼</td>
</tr>
</tbody></table>
<p><strong>💬 한 줄 요약</strong></p>
<blockquote>
<p><code>free</code>는 지금 완전히 놀고 있는 메모리,<br /><code>available</code>은 당장 회수해서 쓸 수 있는 <strong>&quot;잠재적 여유 메모리&quot;</strong>예요.</p>
</blockquote>
<h3 id="🎓-핵심-차이-요약">🎓 핵심 차이 요약</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>free</th>
<th>available</th>
</tr>
</thead>
<tbody><tr>
<td>의미</td>
<td><em>아무도 안 쓰는 메모리</em></td>
<td><em>지금 당장은 쓰이고 있지만, 시스템이 필요하면 회수 가능한 메모리 포함</em></td>
</tr>
<tr>
<td>포함 내용</td>
<td>진짜로 놀고 있는 메모리만</td>
<td>free + 일부 캐시 + 버퍼 캐시</td>
</tr>
<tr>
<td>시스템 신뢰도</td>
<td>낮음 (헷갈리기 쉬움)</td>
<td>높음 (현실 반영된 값)</td>
</tr>
<tr>
<td>보기 좋은 항목</td>
<td>❌</td>
<td>✅ 실제 사용 가능한 공간으로 판단해야 할 지표</td>
</tr>
</tbody></table>
<h3 id="🧠-비유로-쉽게-이해하기">🧠 비유로 쉽게 이해하기</h3>
<ul>
<li><code>free</code>: <strong>책상에 아무것도 안 올려둔 공간</strong></li>
<li><code>available</code>: <strong>책상 위에 책이 있지만, 당장 쓰지 않으면 옆으로 밀어버릴 수 있는 공간까지 포함</strong></li>
</ul>
<p>즉, <strong>당장 비어 있는가?</strong> vs. <strong>필요하면 비울 수 있는가?</strong>의 차이예요.</p>
<h3 id="📝-정리">📝 정리</h3>
<ul>
<li><code>free</code>는 <strong>현재 사용되지 않는 공간</strong></li>
<li><code>available</code>은 <strong>사용 중이지만, 언제든 회수 가능한 공간까지 포함</strong></li>
<li>메모리 부족 판단 시 <strong>무조건 <code>available</code>을 기준으로 판단</strong>해야 합니다!</li>
</ul>
<h2 id="sar-명령어를-사용해서-메모리-관련-정보를-수집하기">sar 명령어를 사용해서 메모리 관련 정보를 수집하기</h2>
<p>sar -r 명령어를 사용하면 두 번째 인수로 지정한 간격(예제는 1초)으로 메모리 관련 통계 정
보를 얻을 수 있습니다.</p>
<h1 id="🚨-3장-메모리가-부족할-때의-히어로-oom-killer">🚨 3장: 메모리가 부족할 때의 히어로, OOM Killer</h1>
<h2 id="📉-메모리가-부족하면-어떡해요-oom-killer-등장">📉 메모리가 부족하면 어떡해요? (OOM Killer 등장!)</h2>
<p>메모리 관리가 잘되다가도 시스템이 너무 바쁘고 메모리를 심하게 쓰면 갑자기 부족해질 수 있어요. 이걸 'Out Of Memory'(OOM) 상태라고 부릅니다. 이런 상황에서는 리눅스가 과감하게 하나의 프로세스를 강제로 종료시켜요! 네, 조금 무섭지만... 생존을 위한 어쩔 수 없는 선택이죠. 이걸 OOM Killer라고 불러요.</p>
<p>만약 여러분이 돌리던 프로그램이 갑자기 사라졌다면, OOM Killer 때문일 수 있습니다. </p>
<h3 id="💡-먼저-이해할-개념-available과-free">💡 먼저 이해할 개념: <code>available</code>과 <code>free</code></h3>
<p>리눅스에서 메모리 상태를 나타낼 때는 <code>free</code>, <code>used</code>, <code>available</code>, <code>buff/cache</code> 등의 값이 나오죠.</p>
<ul>
<li><strong>free</strong>: 말 그대로 지금 아무도 안 쓰고 있는 메모리</li>
<li><strong>available</strong>: <strong>필요하면 바로 회수해서 쓸 수 있는 재활용 가능한 메모리</strong><ul>
<li><code>buff/cache</code> 영역도 포함됨</li>
<li>즉, <code>free</code>보다 항상 크거나 작을 수 있음!</li>
</ul>
</li>
</ul>
<h2 id="❗-그럼에도-메모리가-부족해진다면">❗ 그럼에도 메모리가 부족해진다면?</h2>
<p>일반적으로는 <code>buff/cache</code> 영역을 줄이거나 다른 프로세스가 종료되면서 메모리를 회수할 수 있어요.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/06d8bad7-b577-483d-b4ab-df32fd978aed/image.png" /></p>
<p>시스템 부하가 높아지면 <strong>free 메모리가 줄어듭니다.</strong>
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/0405108a-489a-4609-9149-9de80a7ea07a/image.png" /></p>
<p>이럴때, 커널의 메모리 관리 시스템은 <code>재활용 가능한 메모리 영역을 해제해 free 값</code>을 늘립니다.
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/637ede69-a2b8-4d1b-9be5-89331f565f57/image.png" /></p>
<p>예를 들어 <strong>재활용 가능한 메모리에는 디스크에서 데이터를 읽어서 아직 변경되지 않은 페이지
캐시가 있습니다.</strong> 이런 페이지 캐시는 동일한 데이터가 디스크에 존재하므로 메모리를 해제해
도 문제가 없습니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/f917d43e-c044-4e00-99b0-56e650ebcfb5/image.png" /></p>
<blockquote>
<p>만약 회수할 수 있는 재활용 메모리(<code>available</code>)도 모두 써버리고<br /><strong>더는 줄일 수 없는데 새로운 메모리 요청이 온다면?</strong></p>
</blockquote>
<p>시스템은 이제 선택을 해야 해요. 이때 동작하는 무서운 친구가 등장합니다:
마치 초과 탑승한 비행기에서 승객 몇 명을 어쩔 수 없이 내려야 하는 상황과 같죠.</p>
<h2 id="💀-oom-killer-메모리-부족-시-발동되는-프로세스-제거자">💀 OOM Killer: 메모리 부족 시 발동되는 &quot;프로세스 제거자&quot;</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/62a7d7e0-7bbb-431b-a889-17a005540af3/image.png" /></p>
<p>OOM은 <strong>Out Of Memory</strong>의 줄임말이고,<br /><strong>OOM Killer</strong>는 리눅스 커널이 <strong>강제로 프로세스를 종료</strong>시켜<br />메모리를 확보하려는 자동 방어 시스템이에요.</p>
<h3 id="🧠-oom-killer의-작동-방식">🧠 OOM Killer의 작동 방식</h3>
<ol>
<li>시스템이 메모리 부족 상황에 빠짐</li>
<li><code>available</code> 메모리조차 부족해서 더 이상 쓸 수 없음</li>
<li>커널이 <strong>&quot;이 중 누구를 죽이면 가장 이득일까?&quot;</strong> 계산함</li>
<li>메모리를 많이 쓰면서 중요도가 낮은 프로세스를 <strong>&quot;제물&quot;로 삼음</strong></li>
<li>그 프로세스를 강제로 종료하고 메모리를 회수함</li>
</ol>
<h2 id="📉-예시-상황-그림-설명">📉 예시 상황 (그림 설명)</h2>
<h3 id="out-of-memory-상태">Out Of Memory 상태</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/154f11be-e363-4a20-8a29-516cd4fdaa2d/image.png" /></p>
<table>
<thead>
<tr>
<th>상태</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>total</td>
<td>전체 메모리</td>
</tr>
<tr>
<td>free</td>
<td>지금 당장 아무도 안 쓰는 메모리</td>
</tr>
<tr>
<td>buff/cache</td>
<td>페이지 캐시나 버퍼 캐시로 쓰이는 메모리</td>
</tr>
<tr>
<td>used</td>
<td>total - free - buff/cache</td>
</tr>
<tr>
<td>available</td>
<td>실제로 필요하면 회수 가능한 메모리 (buff/cache 포함)</td>
</tr>
</tbody></table>
<p>→ 그런데 <strong>used 영역이 너무 커서</strong> 더 이상 available도 확보 못 하면 OOM 발생!</p>
<h3 id="oom-killer-동작-전후">OOM Killer 동작 전후</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/12437b58-7feb-4b80-b0ee-2c83b5306187/image.png" /></p>
<ul>
<li><strong>동작 전</strong>: 커널도 메모리를 쓰고, 각종 프로세스도 메모리를 차지 중  </li>
<li><strong>동작 후</strong>: OOM Killer가 <strong>불필요한 프로세스를 강제 종료</strong><br />→ 남은 메모리를 확보하고 시스템을 정상으로 복귀시킴</li>
</ul>
<h2 id="🧪-oom-발생-확인-방법">🧪 OOM 발생 확인 방법</h2>
<pre><code class="language-bash">$ dmesg | grep -i oom</code></pre>
<ul>
<li>위 명령어로 커널 로그에서 OOM Killer가 작동한 흔적을 확인할 수 있어요. 다음과 같이 출력돼요.</li>
</ul>
<pre><code>[XXX] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),...</code></pre><h2 id="🧹-메모리-누수나-oom-예방-팁">🧹 메모리 누수나 OOM 예방 팁</h2>
<ol>
<li><p><strong>ps 명령어로 프로세스 메모리 감시</strong></p>
<pre><code class="language-bash">$ ps aux</code></pre>
<p>→ 이 중 <code>RSS</code> 필드를 보면 각 프로세스의 실제 메모리 사용량을 확인할 수 있어요.</p>
</li>
<li><p><strong>수상한 프로세스 모니터링</strong></p>
</li>
</ol>
<ul>
<li>시간이 지날수록 <code>RSS</code>가 계속 증가한다면 <strong>메모리 누수일 가능성</strong></li>
<li>원인을 못 찾으면 <strong>정기 재시작(cron 등)</strong>으로 임시 해결 가능</li>
</ul>
<blockquote>
<p>OOM Killer가 동작하는 시스템이라면
메모리가 충분하지 않은 경우가 많습니다. 동시 실행 중인 프로세스 개수를 줄여서 메모리 사용
량을 줄이거나 또는 추가로 메모리를 설치하는게 좋습니다.</p>
</blockquote>
<h2 id="✅-요약-정리">✅ 요약 정리</h2>
<table>
<thead>
<tr>
<th>개념</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>available</td>
<td>커널이 재활용할 수 있는 메모리 (free보다 정확한 지표)</td>
</tr>
<tr>
<td>OOM 상태</td>
<td>전체 메모리 중 재활용 가능한 부분도 다 써버린 상황</td>
</tr>
<tr>
<td>OOM Killer</td>
<td>메모리 부족 시, 불필요한 프로세스를 종료해서 시스템을 살리는 기능</td>
</tr>
<tr>
<td>확인 명령어</td>
<td><code>dmesg</code>, <code>ps aux</code>, <code>top</code>, <code>free</code> 등으로 상태 확인 가능</td>
</tr>
<tr>
<td>예방 방법</td>
<td>수상한 프로세스 감시, 필요시 재시작 자동화, 메모리 증설 등</td>
</tr>
</tbody></table>
<blockquote>
<p>“어느 날 갑자기 프로그램이 튕겼다?” → <code>OOM Killer</code>의 소행일 수 있어요.<br />dmesg 로그 확인은 필수입니다!</p>
</blockquote>
<h2 id="추가-정리--🎯-oom-killer는-어떤-기준으로-프로세스를-죽일까">추가 정리 : 🎯 OOM Killer는 어떤 기준으로 프로세스를 죽일까?</h2>
<p>리눅스 커널이 OOM(Out Of Memory) 상황에서 <strong>어떤 프로세스를 죽일지 결정하는 기준</strong>은 사실 꽤 똑똑하고 계산적인 방식으로 진행됩니다. 바로 <strong>&quot;OOM Score (OOM 점수)&quot;</strong>라는 기준이 있어요.</p>
<blockquote>
<p>커널은 메모리가 부족할 때, 다음과 같은 기준을 종합적으로 고려해 <strong>&quot;누굴 죽이는 게 가장 이득일까?&quot;</strong>를 계산합니다:</p>
</blockquote>
<h3 id="1-메모리-사용량이-많은-프로세스">1. <strong>메모리 사용량이 많은 프로세스</strong></h3>
<ul>
<li>기본적으로 <strong>RSS(Resident Set Size)</strong>, 즉 실제 메모리를 많이 차지하는 프로세스는 좋은 후보가 됩니다.</li>
<li>왜냐하면, 이 프로세스를 죽이면 <strong>많은 메모리를 한꺼번에 회수</strong>할 수 있기 때문이죠.</li>
</ul>
<h3 id="2-oom_score-값이-높은-프로세스">2. <strong><code>oom_score</code> 값이 높은 프로세스</strong></h3>
<ul>
<li>리눅스는 각 프로세스마다 <code>oom_score</code>라는 점수를 관리해요.</li>
<li>점수가 <strong>높을수록 죽을 확률이 높음</strong><br />→ 이 점수는 <code>/proc/[PID]/oom_score</code> 파일로 확인할 수 있어요.</li>
</ul>
<pre><code class="language-bash">$ cat /proc/1234/oom_score</code></pre>
<h3 id="3-프로세스의-중요도-oom_score_adj">3. <strong>프로세스의 중요도 (<code>oom_score_adj</code>)</strong></h3>
<ul>
<li>사용자는 프로세스에 <strong>중요도 가중치</strong>도 부여할 수 있어요.</li>
<li>이 값은 <code>-1000</code>에서 <code>+1000</code>까지 설정 가능:<ul>
<li><code>-1000</code>: 절대 죽이면 안 되는 프로세스 (예: 시스템 데몬, SSH 등)</li>
<li><code>0</code>: 기본값</li>
<li><code>+1000</code>: 아주 죽이기 쉬운 프로세스</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">$ echo -1000 &gt; /proc/1234/oom_score_adj</code></pre>
<p>→ 이걸로 OOM Killer가 어떤 프로세스를 피하거나 우선적으로 종료하도록 <strong>정책을 조정</strong>할 수 있어요.</p>
<h3 id="4-프로세스의-유효-사용자-iduid">4. <strong>프로세스의 유효 사용자 ID(uid)</strong></h3>
<ul>
<li>시스템은 일반적으로 <strong>루트 프로세스보다는 일반 사용자 프로세스</strong>를 먼저 종료하려고 해요.</li>
</ul>
<h3 id="5-백그라운드-vs-포그라운드">5. <strong>백그라운드 vs 포그라운드</strong></h3>
<ul>
<li><strong>데스크탑 환경</strong>에서는 사용자가 직접 사용하는 앱보다 <strong>백그라운드에서 조용히 돌아가는 앱</strong>을 먼저 종료하려고 하기도 해요.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/f6e6eecc-a5a1-4050-a3c3-4164cb1d2b9f/image.png" /></p>
<h3 id="🔍-예시-시나리오">🔍 예시 시나리오</h3>
<table>
<thead>
<tr>
<th>PID</th>
<th>프로세스</th>
<th>메모리 사용량</th>
<th>oom_score_adj</th>
<th>최종 종료 가능성</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>SSH 데몬</td>
<td>적음</td>
<td>-1000</td>
<td>매우 낮음 ❌</td>
</tr>
<tr>
<td>200</td>
<td>Python 서버</td>
<td>많음</td>
<td>0</td>
<td>높음 🔥</td>
</tr>
<tr>
<td>300</td>
<td>DB 백업 툴</td>
<td>중간</td>
<td>+500</td>
<td>꽤 높음 🔥</td>
</tr>
<tr>
<td>400</td>
<td>크롬 브라우저</td>
<td>많음</td>
<td>0</td>
<td>사용자 포커스면 낮음</td>
</tr>
</tbody></table>
<h3 id="🛠-정리하자면">🛠 정리하자면</h3>
<table>
<thead>
<tr>
<th>기준 항목</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>oom_score</code></td>
<td>현재 메모리 부족 상황에서 각 프로세스의 &quot;죽을 확률&quot; 점수</td>
</tr>
<tr>
<td><code>oom_score_adj</code></td>
<td>사용자가 직접 조정할 수 있는 가중치 (중요도 설정)</td>
</tr>
<tr>
<td>메모리 사용량</td>
<td>많이 쓰는 놈이 죽으면 효율적!</td>
</tr>
<tr>
<td>프로세스 UID</td>
<td>루트보다 일반 사용자 프로세스가 더 죽기 쉬움</td>
</tr>
<tr>
<td>중요 데몬 여부</td>
<td>SSH, 시스템 필수 프로세스는 보호됨</td>
</tr>
</tbody></table>
<h3 id="✅-확인-방법-정리">✅ 확인 방법 정리</h3>
<pre><code class="language-bash"># 특정 PID의 oom_score 확인
cat /proc/1234/oom_score

# oom_score_adj 조정
echo -1000 &gt; /proc/1234/oom_score_adj</code></pre>
<blockquote>
<p>요약: <strong>&quot;가장 많은 메모리를 차지하면서도, 덜 중요한 프로세스&quot;</strong>가 OOM Killer의 1순위입니다.<br />서버 운영 중이라면, 중요한 프로세스는 <code>oom_score_adj = -1000</code>으로 꼭 보호해 주세요!</p>
</blockquote>
<hr />
<h1 id="🌈-4장-가상-메모리의-신비로운-세계">🌈 4장: 가상 메모리의 신비로운 세계</h1>
<p>가상 메모리는 실제 메모리를 가상 공간으로 나누어 관리합니다. 이를 통해 여러 가지 문제를 해결할 수 있습니다. 예를 들어 가상 메모리는 마치 모든 프로세스에 독립된 방을 제공하는 호텔과 같습니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/b2e4b587-fc37-45a2-b01e-174b8d963de8/image.png" /></p>
<h2 id="🌌-가상-메모리의-마법">🌌 가상 메모리의 마법!</h2>
<p>메모리 관리의 핵심 중 하나가 바로 <strong>가상 메모리</strong>예요. 가상 메모리는 실제 메모리(물리 메모리)를 가상적으로 관리해서 프로세스가 직접 메모리를 다루지 못하게 합니다. 이렇게 하면 여러 가지 문제가 해결됩니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/64ac1cff-192f-4f35-9805-31faf5d490b1/image.png" /></p>
<h3 id="🧩-메모리-단편화-해결-흩어진-공간도-이어-붙인다">🧩 메모리 단편화 해결: 흩어진 공간도 이어 붙인다!</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/c65835d6-72d9-4188-9a89-d12c1d525ba8/image.png" /></p>
<ul>
<li>메모리를 할당하고 해제하는 작업이 반복되면 조각조각 나서 단편화가 발생합니다. </li>
<li>하지만 가상 메모리를 사용하면, 물리 메모리가 조각나 있어도 <strong>프로세스 입장에서는 연속된 공간처럼 보이게</strong> 만들 수 있어요.</li>
<li>퍼즐처럼 흩어진 물리 메모리를 논리적으로 이어 붙여주는 역할이죠!</li>
</ul>
<h3 id="🧍♀️🧍♂️-멀티-프로세스도-ok-모든-프로세스에-독립된-방">🧍‍♀️🧍‍♂️ 멀티 프로세스도 OK: 모든 프로세스에 독립된 방</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/027aef73-c98c-475b-ab36-b9eb538e15a1/image.png" /></p>
<ul>
<li>여러 프로그램이 동시에 돌아가도 각각의 프로세스에게 <strong>서로 완전히 독립적인 가상 주소 공간</strong>을 제공해 줍니다.</li>
<li>같은 프로그램을 두 번 실행해도 문제없이 돌아가는 이유는, 실제 물리 메모리 주소가 달라도 가상 주소로는 각자 <strong>동일한 주소에서 시작하는 듯이 보이기 때문이에요.</strong></li>
<li>각자 다른 방에서 같은 인테리어를 한 셈이죠!</li>
</ul>
<h3 id="🛡-다른-방은-열-수-없다-보안-보장">🛡 다른 방은 열 수 없다! 보안 보장</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/e34b21fe-a920-4b62-a18c-0f64507041a5/image.png" /></p>
<ul>
<li>가상 메모리를 통해 <strong>자기 방(프로세스 메모리)</strong>만 보이고, 다른 방은 보이지 않아요.</li>
<li>즉, 다른 프로세스나 커널 메모리에 마음대로 접근하는 일이 원천 차단됩니다.</li>
<li>보안과 안정성까지 챙겨주는 1석 3조 기능이에요.</li>
</ul>
<h2 id="🏗️-가상-메모리가-없다면-어떤-문제가-생길까">🏗️ 가상 메모리가 없다면 어떤 문제가 생길까?</h2>
<h3 id="🚨-문제-1-메모리-단편화">🚨 문제 1: 메모리 단편화</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/a3f8c552-efb8-4e8f-8919-9012b86773f2/image.png" /></p>
<p>메모리를 계속 할당하고 반납하다 보면, <strong>비어 있는 공간이 여러 조각으로 흩어지게</strong> 됩니다.<br />이런 상태에서 연속된 큰 공간이 필요하면, <strong>전체 빈 공간은 충분해도 할당에 실패</strong>할 수 있어요.</p>
<blockquote>
<p>&quot;조각조각 빈 방은 많지만, 커다란 짐 하나를 둘 연속된 공간은 없는 셈이죠.&quot;</p>
</blockquote>
<h3 id="🚧-문제-2-여러-프로세스가-동시에-실행되기-어려움">🚧 문제 2: 여러 프로세스가 동시에 실행되기 어려움</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/33795521-33d7-4008-9725-b3f0cdaf653b/image.png" /></p>
<p>가상 메모리가 없다면, <strong>실제 메모리 주소에 맞춰 프로그램이 실행</strong>되어야 합니다.
그러면 같은 프로그램을 두 번 실행하면 주소가 겹쳐서 오류가 납니다. </p>
<ul>
<li>프로그램 A: 300~500 사용 중이면,</li>
<li>프로그램 B는 같은 주소에 배치 못해서 실행 불가!</li>
</ul>
<blockquote>
<p>&quot;모든 손님에게 301호만 주는 호텔이면 동시에 둘은 못 들어가요.&quot;</p>
</blockquote>
<h3 id="🔓-문제-3-다른-메모리에-마음대로-접근-가능">🔓 문제 3: 다른 메모리에 마음대로 접근 가능</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/01a5e481-f39e-4278-8c6f-b571259aaf60/image.png" /></p>
<p>프로세스가 <strong>다른 프로세스나 커널 메모리 주소를 지정</strong>하면 실제로 접근이 가능해집니다.<br />즉, 데이터 손상이나 보안 문제가 발생할 수 있어요!</p>
<blockquote>
<p>&quot;옆방 문이 열려 있다면, 그 방 짐도 함부로 만질 수 있다는 거죠.&quot;</p>
</blockquote>
<h2 id="🧠-가상-메모리의-동작-방식">🧠 가상 메모리의 동작 방식</h2>
<h3 id="🎯-기본-개념">🎯 기본 개념</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/710bf947-6720-4326-be60-a7c2d71fa582/image.png" /></p>
<blockquote>
<p>출처 ： <a href="https://velog.io/@hyun0310woo/11-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC">https://velog.io/@hyun0310woo/11-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC</a></p>
</blockquote>
<p>가상 메모리의 원리는 생각보다 간단합니다. 프로세스가 4Gb의 크기를 가지고 있다고는 하지만 CPU가 한번에 4Gb의 코드를 읽을 수는 없습니다. 한번에 읽을 수 있는 코드, 다시 말해 메모리 크기는 제한적이라는 말입니다.</p>
<blockquote>
<p>이는 CPU가 프로세스를 실행하기 위해서는 *<em>모든 코드에 대한 주소가 필요하지 않고 현재 실행 중인 코드에 대한 물리 메모리 정보만 알고 있으면 된다는 말입니다. *</em></p>
</blockquote>
<p>그리고 다음 코드로 넘어간다면 이미 읽었던 코드에 대한 정보는 물리 메모리에서 지워버리고 다시 읽어야 하는 코드 주소에 대한 정보만 실제 메모리에 올려서 실행하면 되는겁니다.</p>
<p>위와 같은 원리로 동작을 하기 위해서는 두 개의 주소가 필요합니다. 0 ~ 4Gb의 주소를 가지고 있는 프로세스가 참조하는 <code>가상 주소(Vitual address)</code>와 이러한 가상 주소 중에서 실제로 메모리에 올라가야 하는 주소인 <code>물리 주소(Physical address)</code>가 필요합니다.</p>
<ul>
<li>가상 주소 (virtual address): 프로세스가 참조하는 주소 | 0 ~ 4Gb</li>
<li>물리 주소 (physical address): 실제 메모리 주소</li>
</ul>
<p>CPU는 프로세스를 실행하기 위해서 먼저 가상 주소에 대한 정보를 찾습니다. 그리고 해당 가상 주소를 가지고 프로세스를 실행하기 위해서는 가상 주소가 실제로 어떤 물리 주소에 위치해 있는지 알아야합니다. : mmu로</p>
<blockquote>
<p>가상 메모리는 &quot;가상 주소(Virtual Address)&quot;를 사용해서, <strong>물리 주소(Physical Address)</strong>로 간접 접근하게 만드는 기술입니다.</p>
</blockquote>
<p>가상 주소에 대비되는 시스템에 설치된 메모리의 실제 주소를 <code>물리 주소</code>라고 하며, 이런 주소를 사용해서 접근 가능한 범위를 <code>주소 공간</code>이라고 합니다。</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/d999c0ad-63ed-404e-9128-d3255c7953a0/image.png" /></p>
<ul>
<li>프로세스는 오직 가상 주소만 사용합니다.</li>
<li>가상 주소는 실제 메모리 주소가 아니라, 중간에서 <strong>커널이 번역</strong>해주는 주소예요.</li>
<li>번역 작업은 <strong>페이지 테이블(Page Table)</strong>을 통해 이루어집니다.</li>
</ul>
<h3 id="✅-프로세스가-실행되는-구조">✅ 프로세스가 실행되는 구조</h3>
<p>프로세스 하나는 최대 4GiB의 가상 주소 공간을 할당받아요.</p>
<p>실제 메모리(RAM)는 제한되어 있지만, 모든 코드를 한 번에 실행하는 건 아니기 때문에 필요한 부분만 올려서 실행해요.</p>
<p>이를 가능하게 하는 하드웨어가 <strong>MMU(Memory Management Unit)</strong>입니다.</p>
<h3 id="🧱-mmu의-역할">🧱 MMU의 역할</h3>
<blockquote>
<p>MMU는 CPU에서 코드를 실행할시에 가상 주소를 실제 물리 주소로 변환해주는 하드웨어 칩입니다.</p>
</blockquote>
<p>CPU가 가상 주소로 요청하면 MMU가 페이지 테이블을 참조해 물리 주소로 변환합니다.
CR3 레지스터: 현재 프로세스의 페이지 테이블 시작 주소를 저장하는 CPU 레지스터입니다.</p>
<p>정리하자면 CPU는 프로세스를 실행하기 위해 가상 메모리 주소에 대한 정보를 찾고 실제로 해당 주소로 접근할 시에 MMU라는 하드웨어가 실제 물리 주소로 변환해서 CPU에게 전달해 줍니다.</p>
<p>이렇게 실제 메모리 용량보다 더 많은 프로세스를 실행하기 위해서 프로세스를 일정 부분만 메모리에 올려서 실행하는것과 그것을 도와주는 하드웨어에 대해서 알게되었습니다. </p>
<blockquote>
<p>어떤 규칙으로 프로세스를 나누냐는 것?이냐가 아래입니다.</p>
</blockquote>
<h3 id="📖-페이지-테이블과-페이지">📖 페이지 테이블과 페이지</h3>
<p>메모리는 페이지(Page) 단위(보통 4KiB)로 나뉘어 관리돼요.</p>
<ul>
<li>커널은 각 프로세스마다 페이지 테이블을 만들어서, <strong>가상 주소 → 물리 주소</strong>로 연결해줍니다.</li>
<li>CPU는 메모리에 접근할 때 페이지 단위로 매핑된 주소를 참조합니다.</li>
</ul>
<blockquote>
<p>페이지 테이블 = 가상의 룸 넘버 → 실제 방 위치 안내도</p>
</blockquote>
<p><strong>⚡ TLB (Translation Lookaside Buffer)</strong>
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/5764a6ed-3c1d-48c2-85fd-016b48a224c6/image.png" /></p>
<p>MMU가 매번 페이지 테이블에 접근하면 느리기 때문에** 자주 쓰는 주소는 TLB라는 고속 캐시에 저장해 속도를 높입니다..**</p>
<h2 id="🧠-가상-메모리가-어떻게-작동하는가">🧠 가상 메모리가 어떻게 작동하는가?</h2>
<h3 id="✅-프로세스가-실행되는-구조-1">✅ 프로세스가 실행되는 구조</h3>
<ul>
<li>프로세스 하나는 <strong>최대 4GiB의 가상 주소 공간</strong>을 할당받아요.</li>
<li>실제 메모리(RAM)는 제한되어 있지만, 모든 코드를 한 번에 실행하는 건 아니기 때문에 필요한 부분만 올려서 실행해요.</li>
<li>이를 가능하게 하는 하드웨어가 <strong>MMU(Memory Management Unit)</strong>입니다.</li>
</ul>
<h3 id="🧱-mmu의-역할-1">🧱 MMU의 역할</h3>
<ul>
<li><strong>가상 주소 → 물리 주소 변환</strong>을 담당하는 하드웨어 장치</li>
<li>CPU가 가상 주소로 요청하면 MMU가 페이지 테이블을 참조해 물리 주소로 변환합니다.</li>
<li><strong>CR3 레지스터</strong>: 현재 프로세스의 페이지 테이블 시작 주소를 저장하는 CPU 레지스터입니다.</li>
</ul>
<h2 id="🗺️-페이지-테이블과-tlb">🗺️ 페이지 테이블과 TLB</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/34625048-d4c0-409d-b2e5-9476bc338387/image.png" /></p>
<h3 id="📖-페이지-테이블과-페이지-1">📖 페이지 테이블과 페이지</h3>
<h4 id="페이지-테이블이란">페이지 테이블이란?</h4>
<blockquote>
<p>&quot;가상 주소를 물리 주소로 바꿔주는 비서!&quot;</p>
</blockquote>
<p><strong>🎒 비유: 주소 변환이 필요한 배달원</strong>
우리가 프로그램을 실행하면, 운영체제는 각 프로그램(프로세스)마다 가상 주소 공간을 줘요.
하지만 컴퓨터는 진짜 물리 메모리(RAM) 주소를 알아야 데이터를 읽고 쓸 수 있겠죠?</p>
<p>그래서 필요한 게 바로…</p>
<blockquote>
<p>📬 &quot;주소 변환표&quot; 역할을 하는 <strong>페이지 테이블 (Page Table)</strong>입니다!</p>
</blockquote>
<p><strong>🧭 페이지 테이블의 역할은?</strong></p>
<table>
<thead>
<tr>
<th>기능</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>주소 변환</td>
<td>CPU가 사용하는 가상 주소를 <strong>물리 주소로 변환</strong>해줘요.</td>
</tr>
<tr>
<td>접근 보호</td>
<td>이 주소가 유효한지? 읽기만 가능한지? 실행 가능한지? 등 <strong>접근 권한 확인</strong>도 해줘요.</td>
</tr>
<tr>
<td>메모리 할당 여부</td>
<td>물리 메모리가 아직 안 할당됐으면 <strong>페이지 폴트를 발생</strong>시켜요.</td>
</tr>
</tbody></table>
<p><strong>🧩 어떻게 구성돼 있을까?</strong>
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/1c76edb5-8b53-4994-9b37-4a68199bffe4/image.png" /></p>
<p>운영체제는 <strong>가상 주소를 &quot;페이지 단위(보통 4KiB)&quot;로 나눠서</strong> 관리하고 있어요.<br />예: 4KB 단위로 쪼개서 가상 주소 0번 페이지, 1번 페이지, 2번 페이지… 식으로요.</p>
<p>📌 <strong>페이지 테이블</strong>은 이 각각의 가상 페이지 번호가 <strong>어디 물리 주소에 있는지</strong>를 저장해두는 표예요.</p>
<pre><code class="language-plaintext">가상 페이지 번호 → 물리 페이지 번호
        0       →       3
        1       →       7
        2       →     없음 (페이지 폴트!)</code></pre>
<p><strong>📦 페이지 테이블은 어디에 있을까?</strong></p>
<ul>
<li><strong>각 프로세스마다 고유한 페이지 테이블</strong>을 갖고 있어요!</li>
<li>페이지 테이블 자체도 <strong>물리 메모리에 저장</strong>되고,</li>
<li>CPU는 <code>CR3</code> 레지스터를 통해 현재 사용 중인 페이지 테이블을 참조해요.</li>
</ul>
<p><strong>🌉 계층형 페이지 테이블이 필요한 이유</strong></p>
<p>x86_64 시스템에선 가상 주소 공간이 <strong>128TB나 되니까</strong>,  
모든 주소를 다 평면(1차원 배열)으로 저장하면 너무 커요! (256GB 넘게 먹음 😱)</p>
<p>그래서 메모리 낭비를 줄이기 위해 <strong>트리 구조처럼 계층적으로 관리</strong>합니다.</p>
<blockquote>
<p>📚 책을 목차 → 챕터 → 페이지 순으로 찾듯,<br /><strong>페이지 테이블도 4단계 계층 구조</strong>로 쭉쭉 따라 내려가요.</p>
</blockquote>
<p>** 💡 요약 정리**</p>
<table>
<thead>
<tr>
<th>항목</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>📌 정의</td>
<td>가상 주소를 물리 주소로 바꿔주는 주소 변환표</td>
</tr>
<tr>
<td>🧠 존재 이유</td>
<td>주소 보호, 접근 권한, 메모리 할당 관리</td>
</tr>
<tr>
<td>🧱 구조</td>
<td>페이지 단위 매핑 (4KB 기준), 계층형 테이블 구조</td>
</tr>
<tr>
<td>💥 폴트</td>
<td>매핑이 없으면 페이지 폴트 발생 → OS介입</td>
</tr>
<tr>
<td>🏢 각자 보유</td>
<td>모든 프로세스는 각자 자기만의 페이지 테이블을 가짐</td>
</tr>
</tbody></table>
<blockquote>
<p>“페이지 테이블은 모든 가상 메모리 접근을 책임지는 든든한 안내도다!”</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/d0bc956b-ef41-44ae-bc1c-537f0dd56ede/image.png" /></p>
<blockquote>
<p>페이지 테이블 = 가상의 룸 넘버 → 실제 방 위치 안내도</p>
</blockquote>
<blockquote>
<p>사실은 가상 주소 공간 크기는 고정된 값이고, 페이지 테이블 엔트리에 페이지와 대응하는 물리
메모리의 존재 여부를 관리하는 데이터가 있습니다.</p>
</blockquote>
<blockquote>
<p>참고로 <strong>&quot;가상 주소를 물리 주소로 바꿔주는 실질적인 하드웨어&quot;</strong>는 <strong>MMU (Memory Management Unit)</strong>입니다.</p>
</blockquote>
<p><strong>🧠 정리해보면 이렇게 나눌 수 있어요:</strong></p>
<table>
<thead>
<tr>
<th>역할</th>
<th>주체</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>📋 <strong>변환 정보 저장</strong></td>
<td><strong>페이지 테이블 (Page Table)</strong></td>
<td>가상 페이지가 물리 메모리 어디에 있는지 저장된 표</td>
</tr>
<tr>
<td>⚙️ <strong>주소 변환 실행</strong></td>
<td><strong>MMU (메모리 관리 유닛)</strong></td>
<td>CPU 안에 있는 하드웨어. 페이지 테이블을 참고해 주소를 변환함</td>
</tr>
<tr>
<td>💡 <strong>의사 결정 주체</strong></td>
<td><strong>운영체제 (커널)</strong></td>
<td>페이지 테이블 생성/관리, 페이지 폴트 처리, 권한 부여 등</td>
</tr>
</tbody></table>
<blockquote>
<p>즉, <strong>MMU는 변환을 ‘실행’하는 사람</strong>,  
<strong>페이지 테이블은 그 ‘지도’</strong>,  
<strong>운영체제는 그걸 ‘작성하고 감독’하는 관리자</strong>입니다.</p>
</blockquote>
<h3 id="⚡-tlb-translation-lookaside-buffer">⚡ TLB (Translation Lookaside Buffer)</h3>
<ul>
<li>MMU가 매번 페이지 테이블에 접근하면 느리기 때문에 자주 쓰는 주소는 <strong>TLB라는 고속 캐시</strong>에 저장해 속도를 높입니다.</li>
</ul>
<h2 id="🔍-페이지-폴트-완전-정복-컴퓨터가-방을-찾지-못했을-때-생기는-일">🔍 페이지 폴트 완전 정복: 컴퓨터가 ‘방을 찾지 못했을 때’ 생기는 일</h2>
<h3 id="🚪-페이지-폴트란-그-방은-아직-준비되지-않았어요">🚪 페이지 폴트란? &quot;그 방은 아직 준비되지 않았어요&quot;</h3>
<p>가상 메모리는 마치 호텔처럼 생겼습니다.</p>
<ul>
<li>예약은 되어 있지만, 아직 실제 방이 만들어지지 않은 경우도 있죠!</li>
<li>이때 손님(프로세스)이 방(메모리)에 들어가려 하면, 프런트(커널)가 가서 <strong>급히 방을 만드는 과정</strong>이 발생합니다.</li>
</ul>
<blockquote>
<p>이게 바로 <strong>페이지 폴트(Page Fault)</strong>입니다.</p>
</blockquote>
<p>이런 페이지 폴트 예외가 발생하면 CPU에서 실행 중인 명령이 중단되고, 커널 메모리에 배치된 <code>페이지폴트 핸들러 page fault handler</code> 처리가 실행됩니다.</p>
<h3 id="🧠-기본-정의">🧠 기본 정의</h3>
<ul>
<li>프로세스가 가상 주소를 참조했는데, <strong>TLB도 모르고</strong>, <strong>페이지 테이블에도 물리 주소가 없을 때</strong> 발생합니다.</li>
<li>CPU는 실행을 멈추고 커널에게 <strong>페이지 폴트 예외(Page Fault Exception)</strong>를 발생시킵니다.</li>
<li>커널은 이 예외를 처리하고, 해당 페이지를 디스크에서 RAM으로 불러옵니다.</li>
</ul>
<h3 id="🧩-페이지-폴트의-종류-다-같은-폴트가-아니다">🧩 페이지 폴트의 종류: 다 같은 폴트가 아니다!</h3>
<h4 id="1-📦-minor-page-fault-마이너-폴트">1) 📦 <strong>Minor Page Fault (마이너 폴트)</strong></h4>
<blockquote>
<p>📌 &quot;주소에 대응되는 물리 페이지는 이미 메모리에 있어요. 근데 페이지 테이블에만 아직 없었네요!&quot;</p>
</blockquote>
<ul>
<li>예: 같은 프로그램이 이미 메모리를 공유하고 있는 경우 등</li>
<li>또는 fork() 이후에 부모와 자식이 같은 페이지를 공유하는 상태일 수도 있어요</li>
</ul>
<p>이럴 때는 디스크 접근 없이, 페이지 테이블만 업데이트하면 끝!</p>
<p>✅ 빠르고 부담 없음</p>
<p><strong>🧠 비유하자면?</strong>
이미 책은 책장에 꽂혀 있는데, <strong>도서 목록(페이지 테이블)</strong>에만 누락된 상태예요.</p>
<p>&quot;아! 목록에만 추가하면 되는구나~&quot; 👓</p>
<blockquote>
<p>🧠 메모리는 있는데, 주소표(페이지 테이블)가 빠져 있어서 생긴 일</p>
</blockquote>
<h4 id="2-🛠️-major-page-fault-메이저-폴트">2) 🛠️ <strong>Major Page Fault (메이저 폴트)</strong></h4>
<blockquote>
<p>📌 &quot;이건 큰일이에요! 그 주소의 데이터가 메모리에 없고 디스크에 있어요!&quot;</p>
</blockquote>
<ul>
<li><p>디스크에 있던 데이터를 <strong>RAM으로 로딩해야만 할 경우</strong></p>
</li>
<li><p>보통은 swap 영역이나 mmap된 파일에서 데이터를 디스크에서 읽어와야 해요</p>
</li>
<li><p>디스크 I/O는 엄청 느려서 ➡ CPU가 한참 기다려야 함 </p>
<blockquote>
<p>즉, <strong>디스크 I/O</strong>가 발생함</p>
</blockquote>
</li>
<li><p>메이저 폴트가 자주 일어나면 성능이 뚝 떨어집니다</p>
</li>
<li><p>속도도 훨씬 느림 (하드디스크 → 메모리 복사)</p>
</li>
</ul>
<p><strong>🧠 비유하자면?</strong>
책장에도 책이 없고, 창고(디스크)까지 가서 찾아와야 해요.</p>
<blockquote>
<p>&quot;아이고 이걸 지금 가지러 가야 해?&quot; 🧳</p>
</blockquote>
<blockquote>
<p>🧠 방이 아예 없어서, 새로 시트를 깔고 TV를 놓고 방을 꾸미는 작업이 필요한 상황</p>
</blockquote>
<p><strong>🧪 실전에서 이걸 어떻게 확인해?</strong></p>
<pre><code>ps -o min_flt,maj_flt -p &lt;PID&gt;
</code></pre><ul>
<li>min_flt: 마이너 폴트 횟수</li>
<li>maj_flt: 메이저 폴트 횟수</li>
</ul>
<p>demand-paging.py에서도 페이지에 접근하면 둘 중 하나가 올라가요!</p>
<h2 id="✨-그리고-이걸-완성시키는-기술-cow-copy-on-write">✨ 그리고 이걸 완성시키는 기술, COW (Copy-On-Write)</h2>
<h3 id="🤔-언제-쓰냐면">🤔 언제 쓰냐면?</h3>
<p>fork()로 부모 프로세스를 복사할 때요.
자식 프로세스를 만들기 위해 메모리를 전부 복사해야 한다면? 💥 비효율적이죠.</p>
<h3 id="💡-해결책-복사-안-하고-일단-같이-써">💡 해결책: &quot;복사 안 하고 일단 같이 써!&quot;</h3>
<ul>
<li>부모와 자식은 같은 메모리 페이지를 읽기 전용으로 공유</li>
</ul>
<blockquote>
<p>둘 중 누가 쓰기 시도를 하면?</p>
</blockquote>
<p>-페이지 폴트 발생!</p>
<ul>
<li>그때 비로소 해당 페이지를 진짜 복사해서 분리</li>
</ul>
<p>🧠 마치 문서를 복사해달라고 해서 같이 보고 있다가, 한 명이 낙서를 하려고 하면 그때서야 복사해주는 느낌이에요</p>
<p><strong>📌 그래서 얻는 이점은?</strong>
메모리 절약</p>
<ul>
<li>fork() 성능 향상 (특히 exec()로 금방 덮어쓸 경우)</li>
</ul>
<blockquote>
<p>“페이지 폴트가 다 같은 게 아니다.
문제는 메이저 폴트!
똑똑하게 아끼는 기술은 COW!”</p>
</blockquote>
<h3 id="🏃-페이지-폴트가-발생하면-어떤-일이-벌어질까">🏃 페이지 폴트가 발생하면 어떤 일이 벌어질까?</h3>
<p>아래는 페이지 폴트가 발생하고 처리되는 전체 흐름입니다:</p>
<h3 id="✅-전체-흐름-요약">✅ 전체 흐름 요약</h3>
<pre><code class="language-plaintext">1. 프로세스가 가상 주소에 접근함
2. TLB에서 확인 – 실패!
3. 페이지 테이블에서 확인 – 실패!
4. 페이지 폴트 예외 발생 (인터럽트)
5. 운영체제가 디스크에서 해당 페이지를 물리 메모리에 로드
6. 페이지 테이블 업데이트
7. 프로세스 재실행</code></pre>
<h3 id="🎨-그림으로-보면-더-쉬워요">🎨 그림으로 보면 더 쉬워요!</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/3adc1b1a-1402-469a-8cee-c77a3ae1f1bf/image.png" /></p>
<h3 id="💥-페이지-폴트-실전-예시-고의로-터트려보자">💥 페이지 폴트 실전 예시: 고의로 터트려보자</h3>
<ul>
<li>가상 주소에는 있지만 물리 메모리에 없는 경우, CPU는 <strong>페이지 폴트 예외</strong>를 발생시켜요.</li>
<li>커널은 이걸 감지하고 필요한 페이지를 디스크에서 RAM으로 불러오고 다시 실행시킵니다.</li>
</ul>
<pre><code class="language-go">// segv.go
package main

import &quot;fmt&quot;

func main() {
    var p *int = nil
    fmt.Println(&quot;비정상 메모리 접근 전&quot;)
    *p = 8 // 💣 터진다!
    fmt.Println(&quot;비정상 메모리 접근 후&quot;)
}</code></pre>
<ul>
<li>이 코드를 실행하면 다음과 같은 메시지가 뜹니다:</li>
</ul>
<pre><code class="language-bash">panic: runtime error: invalid memory address or nil pointer dereference
SIGSEGV: segmentation violation</code></pre>
<blockquote>
<p>💡 실제 물리 메모리에도 존재하지 않는 주소에 접근했기 때문이에요!</p>
</blockquote>
<p>이 프로그램을 실행하면 다음과 같이 <strong>panic: invalid memory address</strong> 메시지와 함께 <strong>프로세스가 종료</strong>됩니다.<br />이것이 바로 <strong>가상 메모리 보호기능</strong>이 제대로 작동했다는 증거입니다.</p>
<blockquote>
<p>실행하면 SIGSEGV(세그멘테이션 폴트)가 발생하며 프로그램이 종료됩니다.</p>
</blockquote>
<h3 id="📊-페이지-폴트-실습에서-본-변화">📊 페이지 폴트 실습에서 본 변화</h3>
<p>앞서 사용한 <code>demand-paging.py</code> 예시처럼…</p>
<ul>
<li><code>mmap()</code>으로 메모리 확보한 뒤에도</li>
<li>실제 접근하기 전까지는 물리 메모리 사용량이 <strong>변하지 않습니다</strong></li>
<li>접근 시점마다 <strong>페이지 폴트가 발생하고</strong>, 그때서야 메모리에 로딩됩니다</li>
</ul>
<blockquote>
<p>💡 이게 바로 <strong>Demand Paging</strong>이에요! 실제 필요할 때만 물리 메모리 할당</p>
</blockquote>
<ul>
<li>모든 페이지를 미리 메모리에 올려놓는 <strong>선행 페이징</strong>과 달리, 필요한 순간에 메모리에 올리는 방식입니다.</li>
<li>프로세스가 접근하려는 페이지가 없으면 <strong>페이지 폴트 → 메모리에 로드 → 테이블 갱신 → 재시작</strong> 흐름이 발생합니다.</li>
</ul>
<h3 id="🧠-리눅스에서의-페이지-폴트-관리">🧠 리눅스에서의 페이지 폴트 관리</h3>
<p>리눅스는 다음과 같은 방식으로 페이지 폴트를 처리합니다:</p>
<table>
<thead>
<tr>
<th>단계</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>페이지 폴트 예외 발생</td>
</tr>
<tr>
<td>2</td>
<td>커널의 <code>page_fault_handler()</code> 동작</td>
</tr>
<tr>
<td>3</td>
<td>해당 주소가 유효한 범위인지 검사</td>
</tr>
<tr>
<td>4</td>
<td>메모리 할당이 가능하면 페이지 테이블을 업데이트</td>
</tr>
<tr>
<td>5</td>
<td>가능하지 않으면 <code>SIGSEGV</code> 시그널 전송</td>
</tr>
</tbody></table>
<h3 id="🔍-분석-도구로-확인하기">🔍 분석 도구로 확인하기</h3>
<h4 id="ps--o-min_fltmaj_flt--p-pid"><code>ps -o min_flt,maj_flt -p &lt;PID&gt;</code></h4>
<ul>
<li>프로세스의 마이너/메이저 페이지 폴트 횟수 확인</li>
</ul>
<h4 id="vmstat"><code>vmstat</code></h4>
<ul>
<li>시스템 전체의 페이지 폴트 흐름 파악 가능</li>
</ul>
<h3 id="⚠️-페이지-폴트는-많으면-안-좋은가">⚠️ 페이지 폴트는 많으면 안 좋은가?</h3>
<p>그렇습니다!</p>
<ul>
<li><strong>초반에는 필요하지만</strong>, 지속적으로 발생한다면?</li>
<li>→ 메모리 부족, 메모리 설계 미숙, 캐시 미스 등의 문제가 있을 수 있어요</li>
</ul>
<p>📌 예를 들어, Major Page Fault가 계속 발생하면 디스크 I/O가 빈번해지고 성능이 크게 저하될 수 있습니다.</p>
<blockquote>
<p>페이지 폴트가 자주 일어난다면 어떻게 될까여 
→ 처리 시간이 오래 걸린다. 
 
페이지 폴트를 방지하려면 어떻게 해야할까?
→ 앞으로 실행될 코드나 요청될 데이터를 포함한 페이지를 미리미리 메모리에 올립니다.
→  완벽한 미래예측 = 신의 영역 </p>
</blockquote>
<ul>
<li>이러한 문제를 해결하기 위해서 다양한 페이지 교체 알고리즘이 있다. <blockquote>
<p>출처: <a href="https://devraphy.tistory.com/246">https://devraphy.tistory.com/246</a> [개발자를 향하여:티스토리]</p>
</blockquote>
</li>
</ul>
<h3 id="✨-정리-페이지-폴트-꼭-나쁜-것만은-아니지만">✨ 정리: 페이지 폴트, 꼭 나쁜 것만은 아니지만…</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Minor Page Fault</td>
<td>메모리는 있음, 주소 정보만 없음</td>
</tr>
<tr>
<td>Major Page Fault</td>
<td>디스크에서 읽어야 함</td>
</tr>
<tr>
<td>발생 시 처리</td>
<td>커널의 page fault handler가 물리 메모리에 올리고 페이지 테이블 갱신</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>메모리 공간이 아예 없으면 발생하는 시그널</td>
</tr>
</tbody></table>
<h2 id="페이지-폴트가-발생한-후-처리">페이지 폴트가 발생한 후 처리</h2>
<p>운영체제는 이러한 페이지 폴트가 발생하면 <strong>해당 페이지를 물리 메모리에 올려주고 재실행을 하게합니다.</strong> </p>
<p>이러한 과정을 그림으로 살펴보면 아래와 같습니다.</p>
<blockquote>
<p>출처  : <a href="https://velog.io/@hyun0310woo/11-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC">https://velog.io/@hyun0310woo/11-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC</a></p>
</blockquote>
<h3 id="1-tlb에-물리-주소가-있을-경우">1. TLB에 물리 주소가 있을 경우</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/f482117d-1166-4ae4-a053-82689a352377/image.png" /></p>
<p>TLB에 물리 주소가 있다면 메모리에 있는 페이지 테이블에 가지 않고** 바로 물리 주소에 해당하는 데이터를 확인 후에 전달하면 됩니다.**</p>
<h3 id="2-tlb에-물리-주소가-없을-경우">2. TLB에 물리 주소가 없을 경우</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/1303bb20-d824-4070-8cbd-bf3eb5219b29/image.png" /></p>
<p><code>없을 경우</code>에는 CR3 레지스터 값을 통해서** 페이지 테이블에 접근하며 이때 페이지 테이블의 정보(valid - invalid bit값)을 확인해서 물리 주소에 대한 데이터가 있을 경우 전달해주면 됩니다.**</p>
<h3 id="3-페이지-테이블에-물리-메모리-데이터가-없을-경우">3. 페이지 테이블에 물리 메모리 데이터가 없을 경우</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/58d14a04-9d49-408f-bad6-c7fd4b8b193c/image.png" /></p>
<p>페이지 테이블에도 물리 메모리 데이터가 없다면 페이지 폴트 인터럽트를 통해서 운영체제에게 알려줍니다. 그러면 운영체제는 해당 인터럽트를 처리하기 위해서 프로세스의 공간에서 페이지를 가져와 물리 메모리에 올려주게 되고 페이지 테이블을 업데이트하게 됩니다. 그리고 다시 CPU에게 가상 주소 요청을 하도록 합니다.</p>
<blockquote>
<p>물론 이러한 페이지 폴드가 빈번하게 발생하면 실행 시간이 오래 걸립니다.</p>
</blockquote>
<h2 id="🔁-페이지-교체-정책-page-replacement">🔁 페이지 교체 정책 (Page Replacement)</h2>
<h3 id="✅-물리-메모리가-꽉-찼다면">✅ 물리 메모리가 꽉 찼다면?</h3>
<ul>
<li>새 페이지를 올려야 하는데 공간이 없다면 기존 페이지를 하나 제거해야 해요.</li>
<li>어떤 페이지를 제거할지는 교체 알고리즘에 따라 결정됩니다:</li>
</ul>
<table>
<thead>
<tr>
<th>알고리즘</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>FIFO</td>
<td>가장 먼저 들어온 페이지 제거</td>
</tr>
<tr>
<td>OPT</td>
<td>앞으로 가장 오래 안 쓸 페이지 제거 (이론상 최적이지만 구현 어려움)</td>
</tr>
<tr>
<td>LRU</td>
<td>가장 오래전에 사용한 페이지 제거</td>
</tr>
<tr>
<td>LFU</td>
<td>가장 적게 사용된 페이지 제거</td>
</tr>
<tr>
<td>NUR</td>
<td>최근 사용되지 않은 페이지 우선 제거 (R/M 비트 사용)</td>
</tr>
</tbody></table>
<h3 id="⚡-thrashing-스레싱">⚡ Thrashing (스레싱)</h3>
<ul>
<li>너무 많은 페이지 폴트와 교체 작업이 반복되면 CPU는 일만 하고 실제 일은 못 하게 됩니다.</li>
<li>시스템 성능이 급격히 떨어지는 현상으로, <strong>스레싱 방지</strong>를 위해 페이지 수 조절이 필요해요.</li>
</ul>
<h3 id="📚-segmentation-세그멘테이션">📚 Segmentation (세그멘테이션)</h3>
<ul>
<li>페이징과 달리, <strong>논리적인 의미 단위로 메모리를 나누는 기법</strong>이에요.</li>
<li>코드, 데이터, 스택 등으로 나눔 (크기 불균형 허용)</li>
</ul>
<blockquote>
<p>보통 페이징과 혼합해서 사용되기도 합니다.</p>
</blockquote>
<h2 id="🧾-마무리-한-줄-요약">🧾 마무리 한 줄 요약</h2>
<blockquote>
<p><strong>가상 메모리는 리눅스 메모리 시스템의 마법 같은 기능입니다.</strong><br />각 프로세스가 독립된 세계에 살게 하여, 충돌과 침범을 막고 효율적으로 메모리를 사용할 수 있게 해줘요!</p>
</blockquote>
<h2 id="🔄-리눅스에서의-메모리-접근-흐름-요약">🔄 리눅스에서의 메모리 접근 흐름 요약</h2>
<ol>
<li><p>CPU는 TLB(Translation Lookaside Buffer)를 먼저 확인합니다.
→ TLB에 매핑이 있으면 즉시 물리 주소로 접근 가능! ✅</p>
</li>
<li><p>TLB에 없다면? → 페이지 테이블을 조회합니다. 이때 CR3 레지스터(x86에서는 페이지 테이블의 루트 주소를 담고 있음)를 통해 시작합니다.</p>
</li>
<li><p>페이지 테이블에서 해당 엔트리를 찾습니다.
→ Valid bit(유효 여부)를 확인하여, 물리 주소가 유효한지 판단합니다.</p>
</li>
<li><p>만약 해당 가상 주소에 유효한 물리 주소가 없다면?
→ <strong>페이지 폴트 예외(Page Fault Exception)</strong>가 발생합니다. 🚨</p>
</li>
<li><p>커널의 페이지 폴트 핸들러가 동작하여 디스크(스왑 or 파일)에서 데이터를 물리 메모리에 로드하고, 페이지 테이블을 업데이트합니다.</p>
</li>
</ol>
<h1 id="🛠-5장-메모리-할당의-놀라운-방법-mmap과-demand-paging">🛠 5장: 메모리 할당의 놀라운 방법, mmap과 Demand Paging</h1>
<h2 id="📚-이야기로-풀어보는-메모리-할당">📚 이야기로 풀어보는 메모리 할당</h2>
<p>우리가 흔히 생각하는 메모리 할당 방식은 이래요:</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/84cbf05a-1f38-48f2-9980-d135940e4e1d/image.png" /></p>
<ol>
<li>프로그램이 “XX 바이트 주세요!”라고 요청</li>
<li>커널이 실제 물리 메모리에서 그만큼을 꺼내서 줌</li>
<li>확보한 메모리 영역을 프로세스의 가상 주소 공간에 매핑</li>
<li>가상 주소 공간의 시작 위치 주소를 프로세스에 돌려줌</li>
</ol>
<p>하지만 리눅스는 이렇게 단순하게 동작하지 않습니다.</p>
<p><code>메모리</code>는 확보한 순간 당장 사용하기보다는 조금 시간이 지난 후에 사용하는 일이 많아서 리눅스는 메모리를 확보하는 절차를 두 단계로 나눕니다.
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/70d4816f-0094-46d1-b718-6f14e0e620d3/image.png" /></p>
<p><strong>1. 메모리 영역 할당:</strong> 가상 주소 공간에 새롭게 접근 가능한 메모리 영역을 매핑합니다.
<strong>2. 메모리 할당:</strong> 확보한 메모리 영역에 물리 메모리를 할당합니다.</p>
<p>리눅스는 대신, <strong>“일단 책장은 만들어 줄게. 진짜 책은 나중에 넣자!”</strong>라는 철학을 가집니다.<br />이걸 가능하게 해주는 것이 바로…</p>
<h2 id="💾-mmap-책장을-만드는-시스템-콜파일처리-성능-개선-기법이기도-한">💾 mmap(): 책장을 만드는 시스템 콜(파일처리 성능 개선 기법이기도 한)</h2>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/5af0fff7-ad6a-4391-9177-1c12be1e98cf/image.png" /></p>
<blockquote>
<p>출처 : <a href="https://bannavi.tistory.com/80">https://bannavi.tistory.com/80</a></p>
</blockquote>
<p><code>mmap()</code>은 프로세스가 새로운 메모리 공간이 필요할 때 사용하는 시스템 콜입니다. </p>
<p>추가로 설명하자면 mmap() 시스템 콜과 Go 언어의 map() 함수 인수는 조금 다릅니다. 예를 들어 <code>시스템 콜</code>은 요청하는 <strong>메모리 크기를 두 번째 인수로 지정</strong>하지만, <code>Go 언어 함수</code>는 <strong>세번째 인수로 지정</strong>합니다. </p>
<p>이 함수는 실제 물리 메모리를 바로 할당해주지 않고, <strong>가상 주소 공간에 “비어 있는 영역”을 매핑</strong>해주는 역할을 해요.</p>
<blockquote>
<p>📌 즉, 물리 메모리는 아직 없지만, “여기부터 여기까지는 네 거야!” 하고 표식만 해두는 겁니다.</p>
</blockquote>
<p>이렇게 확보된 가상 메모리 공간은 <code>/proc/&lt;pid&gt;/maps</code> 파일을 통해 확인할 수 있습니다.<br />아직 <strong>물리 메모리는 0바이트도 할당되지 않았지만</strong>, <code>mmap()</code> 호출 이후 <strong>가상 메모리 공간은 증가</strong>한 것을 확인할 수 있어요.</p>
<p>양쪽 모두 수많은 인수가 있지만 여기서는 메모리 영역 크기를 지정하는 인수에만 주의하면 됩니다. </p>
<h2 id="mmap의-3가지-핵심-속성-정리">mmap의 3가지 핵심 속성 정리</h2>
<blockquote>
<p>출처 : <a href="https://keepat-it.tistory.com/39">https://keepat-it.tistory.com/39</a></p>
</blockquote>
<h3 id="1️⃣-권한-읽기쓰기실행은-protection으로-설정한다">1️⃣ 권한: <strong>&quot;읽기/쓰기/실행&quot;은 protection으로 설정한다!</strong></h3>
<p><code>mmap()</code>은 메모리와 파일을 맵핑하는 함수입니다.<br />하지만 단순한 파일 입출력이 아니라 메모리 페이지 단위로 작동하므로, <strong>&quot;접근 권한&quot;</strong>도 메모리 방식으로 설정합니다.</p>
<h4 id="🧷-mmap의-접근-권한--protection">🧷 mmap의 접근 권한 = Protection</h4>
<table>
<thead>
<tr>
<th>권한 약어</th>
<th>의미</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>PROT_READ</code></td>
<td>읽기</td>
<td>해당 메모리 영역을 읽을 수 있음</td>
</tr>
<tr>
<td><code>PROT_WRITE</code></td>
<td>쓰기</td>
<td>해당 메모리 영역에 쓸 수 있음</td>
</tr>
<tr>
<td><code>PROT_EXEC</code></td>
<td>실행</td>
<td>코드처럼 실행 가능 (코드 영역 매핑에 사용)</td>
</tr>
<tr>
<td><code>PROT_NONE</code></td>
<td>접근 금지</td>
<td>보호 목적, 아무 작업도 못함</td>
</tr>
</tbody></table>
<blockquote>
<p>파일의 <code>rwx</code>처럼 보이지만, mmap에서는 <code>PROT_*</code>으로 설정한다는 점이 다릅니다!</p>
</blockquote>
<h3 id="2️⃣-가상-메모리-스왑과-페이지-인아웃의-관계">2️⃣ 가상 메모리: <strong>&quot;스왑과 페이지 인/아웃의 관계&quot;</strong></h3>
<p>리눅스는 가상 메모리를 기반으로 작동하기 때문에, mmap으로 확보된 메모리도 물리 메모리가 아닌 <strong>디스크(스왑 공간)</strong>으로 이동될 수 있어요.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/9ce8a5ef-7d7e-4a1f-9a29-6b9788a0a7d3/image.png" /></p>
<h3 id="🌀-스왑-동작-요약">🌀 스왑 동작 요약</h3>
<table>
<thead>
<tr>
<th>용어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Page Out / Swap Out</strong></td>
<td>메모리 부족 시, 사용 중인 페이지를 디스크로 내보내기</td>
</tr>
<tr>
<td><strong>Page In / Swap In</strong></td>
<td>다시 필요해진 페이지를 디스크에서 메모리로 불러오기</td>
</tr>
</tbody></table>
<p>이게 중요한 이유는:</p>
<ul>
<li>mmap된 메모리가 실제로 물리 메모리에서 <strong>사라질 수도 있다</strong></li>
<li>다시 접근 시 <strong>페이지 폴트 발생 → 페이지 인 필요</strong></li>
</ul>
<blockquote>
<p>즉, mmap도 스왑의 대상이 될 수 있다는 것, <strong>단, 공유 mmap은 예외일 수 있음!</strong></p>
</blockquote>
<h3 id="3️⃣-공유-방식-shared-vs-private">3️⃣ 공유 방식: <strong>Shared vs Private</strong></h3>
<p><code>mmap()</code>은 메모리 매핑 방식을 <strong>공유(shared)</strong> 또는 <strong>사설(private)</strong> 중에서 선택할 수 있습니다.</p>
<h4 id="📤-shared-공유-mmap">📤 Shared (공유) mmap</h4>
<ul>
<li><code>MAP_SHARED</code> 옵션</li>
<li>mmap과 원본 파일이 <strong>양방향 동기화됨</strong></li>
<li>여러 프로세스가 동일한 mmap 영역을 공유 가능</li>
<li><strong>스왑 아웃 대상이 아님</strong> (원본 파일이 항상 디스크에 존재하므로)</li>
</ul>
<h4 id="예시">예시:</h4>
<pre><code class="language-c">mmap(..., MAP_SHARED)</code></pre>
<blockquote>
<p>프로세스 A에서 수정한 내용이 프로세스 B에도 그대로 반영됨<br />(단, 파일과의 싱크에는 <strong>약간의 시간차</strong>가 있을 수 있음)</p>
</blockquote>
<h4 id="🧍-private-사설-mmap">🧍 Private (사설) mmap</h4>
<ul>
<li><code>MAP_PRIVATE</code> 옵션</li>
<li><strong>처음에는 원본 파일 내용 복사</strong>, 이후는 독자적 메모리 사용</li>
<li>파일과 동기화 ❌ → 수정해도 파일에 반영되지 않음</li>
<li>변경된 페이지는 프로세스 고유 메모리로 전환되며, <strong>스왑 아웃 대상이 됨</strong></li>
</ul>
<h4 id="예시-1">예시:</h4>
<pre><code class="language-c">mmap(..., MAP_PRIVATE)</code></pre>
<blockquote>
<p>읽기 전용 참고용으로는 좋지만, 쓰기 성능이나 스왑 관리에는 주의 필요</p>
</blockquote>
<h4 id="💡-tip-사설-mmap을-스왑에서-제외하고-싶다면">💡 Tip: 사설 mmap을 스왑에서 제외하고 싶다면?</h4>
<pre><code class="language-c">mlock(addr, length)</code></pre>
<blockquote>
<p>특정 메모리 영역을 고정시켜 <strong>페이징 아웃(스왑 아웃)</strong>을 방지할 수 있음</p>
</blockquote>
<h3 id="✅-정리-표">✅ 정리 표</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>Shared mmap</th>
<th>Private mmap</th>
</tr>
</thead>
<tbody><tr>
<td>동기화 여부</td>
<td>O (파일과 공유)</td>
<td>X (한 번만 복사)</td>
</tr>
<tr>
<td>다른 프로세스와 공유</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>파일 수정 반영</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>스왑 아웃 대상</td>
<td>❌ (디스크에 있음)</td>
<td>✅ (RAM에 있어야 함)</td>
</tr>
<tr>
<td>쓰기 시 동작</td>
<td>바로 반영</td>
<td>COW (복사 후 수정)</td>
</tr>
</tbody></table>
<h3 id="📌-요약-정리">📌 요약 정리</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>Protection</td>
<td><code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_EXEC</code> 등으로 접근 권한 설정</td>
</tr>
<tr>
<td>가상 메모리 관계</td>
<td>필요 시 스왑 아웃/인 발생, 특히 Private mmap은 스왑 대상이 됨</td>
</tr>
<tr>
<td>공유 방식</td>
<td><code>MAP_SHARED</code>는 파일과 공유, <code>MAP_PRIVATE</code>는 복사 후 독립 사용</td>
</tr>
</tbody></table>
<h2 id="💤-demand-paging-실제로-접근해야만-주는-메모리">💤 Demand Paging: 실제로 접근해야만 주는 메모리</h2>
<p><code>mmap()</code> 시스템 콜을 호출한 직후라면 새로운 메모리 영역에 대응하는** 물리 메모리는 아직 존재하지 않습니다.**</p>
<blockquote>
<p>리눅스는 <strong>메모리 낭비를 막기 위해</strong> 진짜 메모리 할당을 “필요할 때만” 합니다.<br />이런 방식이 바로 <strong>Demand Paging</strong>입니다.</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/46a3dbeb-5bbc-4d02-bd89-c9c1c638a96e/image.png" /></p>
<h3 id="🎯-demand-paging이란">🎯 Demand Paging이란?</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/29830f9e-c705-4078-8822-247b4bd57aa9/image.png" /></p>
<p><strong>페이지 접근 후 메모리 확보 절차</strong>
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/c00476f0-7b87-408d-afb6-d967f3c1ce02/image.png" /></p>
<ol>
<li><p>프로세스가 <code>mmap()</code>으로 메모리 공간을 요청하면<br />→ 가상 주소만 확보됨 (물리 메모리는 없음)</p>
</li>
<li><p>이 주소에 <strong>실제로 접근하려고 하면</strong><br />→ <strong>페이지 폴트 예외(Page Fault Exception)</strong> 발생
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/f2efabdc-4b37-4428-8707-6eb5a64ffbf9/image.png" /></p>
</li>
<li><p>커널이 물리 메모리를 할당하고<br />→ 페이지 테이블을 갱신</p>
</li>
</ol>
<ul>
<li>이후 메모리 접근 정상 처리!</li>
</ul>
<blockquote>
<p>📖 비유하자면?<br />“빈 책장을 만들어두고, 독자가 실제로 책을 꺼내려 할 때 그 책을 꽂는 것”</p>
</blockquote>
<h3 id="demand-paging-좀-더-자세히-알아보기">Demand Paging 좀 더 자세히 알아보기</h3>
<blockquote>
<p>페이지 폴트 핸들러는 <strong>페이지 테이블 엔트리가 존재하지 않을 시</strong>, 프로세스에 <code>SIGSEGV</code> 시그널을 보내지만, <strong>페이지 테이블 엔트리는 존재하되 물리 메모리가 할당되지 않은 경우</strong>에는 새로운 메모리를 할당하는 처리로 분기합니다.</p>
</blockquote>
<p>리눅스에서 페이지 폴트가 발생했을 때, 커널의 페이지 폴트 핸들러(<code>page_fault_handler</code>)는 다음과 같은 분기 처리를 합니다:</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/8d2d940c-787c-444c-a801-7e5ccc233542/image.png" /></p>
<p><strong>1) 페이지 테이블에 엔트리가 없으면?</strong></p>
<ul>
<li>이 가상 주소가 <strong>정상적인 주소 범위가 아니거나</strong>,  
해당 주소에 대해 메모리를 할당할 이유가 없다면<br />👉 운영체제는 <strong><code>SIGSEGV</code> (Segmentation Fault)</strong> 시그널을 해당 프로세스에 보냅니다.</li>
<li>이는 프로그램이 <strong>허용되지 않은 주소를 접근</strong>한 것이므로,<br />대부분의 경우 프로그램은 강제 종료됩니다.</li>
</ul>
<blockquote>
<p>예: <code>nil</code> 포인터 역참조, 해제된 메모리 접근, 스택/힙 영역을 넘은 접근 등</p>
</blockquote>
<p><strong>2) 페이지 테이블 엔트리는 있으나, 물리 메모리가 할당되지 않은 경우?</strong></p>
<ul>
<li>이는 <code>mmap()</code> 등으로 가상 메모리 공간을 확보해두었지만, 아직 <strong>실제 메모리에 대응된 페이지가 없는 상태</strong>입니다.</li>
<li>이 경우 커널은 “아, 접근했으니 이제 물리 메모리 할당해줘야겠다!” 하고<br />👉 <strong>Demand Paging 처리</strong>를 합니다.</li>
<li>물리 메모리에서 페이지를 할당하고, 해당 가상 주소와 연결해주는 페이지 테이블을 업데이트합니다.</li>
<li>이후, <strong>인터럽트가 발생했던 명령어를 다시 실행</strong>시킵니다.</li>
</ul>
<blockquote>
<p>✅ 이건 오류가 아니라 정상적인 메모리 요청 흐름의 일부입니다!</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/be2559a2-a891-4671-95b7-dc7320ddb9e1/image.png" /></p>
<p><strong>✅ 요약 정리</strong></p>
<table>
<thead>
<tr>
<th>상황</th>
<th>처리 방식</th>
<th>결과</th>
</tr>
</thead>
<tbody><tr>
<td>페이지 테이블 엔트리 없음</td>
<td><code>SIGSEGV</code> 시그널 전송</td>
<td>프로세스 강제 종료</td>
</tr>
<tr>
<td>페이지 테이블은 있지만 물리 메모리 없음</td>
<td>Demand Paging 수행</td>
<td>물리 메모리 할당 후 재실행</td>
</tr>
</tbody></table>
<p><strong>📌 관련 키워드 정리</strong></p>
<table>
<thead>
<tr>
<th>용어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SIGSEGV</strong></td>
<td>잘못된 메모리 접근 시 운영체제가 프로세스에 보내는 시그널</td>
</tr>
<tr>
<td><strong>Demand Paging</strong></td>
<td>메모리 접근 시점에 실제 물리 메모리를 동적으로 할당하는 기법</td>
</tr>
<tr>
<td><strong>페이지 테이블</strong></td>
<td>가상 주소와 물리 주소의 매핑 정보를 담는 구조</td>
</tr>
<tr>
<td><strong>페이지 폴트 핸들러</strong></td>
<td>페이지 폴트가 발생했을 때 커널에서 실행되는 처리 루틴</td>
</tr>
</tbody></table>
<ul>
<li>&quot;접근 시 → TLB 미스 → 페이지 테이블 체크 → 존재 여부 판단 → Demand Paging or SIGSEGV&quot;  </li>
</ul>
<h2 id="🧪-실험으로-보는-mmap과-demand-paging">🧪 실험으로 보는 mmap과 Demand Paging</h2>
<h3 id="✔️-go로-보는-예시-mmapgo">✔️ Go로 보는 예시 (mmap.go)</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/6a9f0a5a-69bd-484b-8d3a-c7e5051ca8b9/image.png" />
<strong>코드 프로세스</strong></p>
<ol>
<li>프로세스의 메모리 매핑 정보(<code>/proc/&lt;pid&gt;/maps</code> 출력)를 표시합니다.</li>
<li>mmap() 시스템 콜로 1GiB 메모리를 요청합니다.</li>
<li>다시 메모리 매핑 정보를 표시합니다.</li>
</ol>
<p><strong>결과</strong></p>
<ol>
<li><code>mmap()</code> 호출 → 0x7fd00aa94000 - 0x7fcfcaa94000 = 1GiB 메모리 공간 확보  </li>
<li><code>/proc/&lt;pid&gt;/maps</code>로 확인하면, 가상 메모리 공간은 늘었지만<br /><strong>물리 메모리는 아직 할당되지 않음!</strong></li>
</ol>
<blockquote>
<p>주소를 뺀 값이 1GiB라는 점이 중요합니다.</p>
</blockquote>
<h3 id="✔️-python으로-보는-예시-demand-pagingpy">✔️ Python으로 보는 예시 (demand-paging.py)</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/70610c01-3fc2-40cc-8dc8-c123a7851ca6/image.png" /></p>
<ol>
<li><code>mmap()</code>으로 100MiB 확보  </li>
<li>한 페이지씩 메모리에 접근 → 페이지 폴트 발생  </li>
<li>그때마다 물리 메모리 하나씩 할당  </li>
<li><code>ps</code>, <code>sar -r</code>, <code>sar -B</code> 등으로<br />메모리 사용량, 페이지 폴트 횟수 확인 가능!</li>
</ol>
<h3 id="📊-실험-결과-한눈에-보기">📊 실험 결과 한눈에 보기</h3>
<table>
<thead>
<tr>
<th>시점</th>
<th>가상 메모리</th>
<th>물리 메모리</th>
<th>페이지 폴트</th>
</tr>
</thead>
<tbody><tr>
<td><code>mmap()</code> 직후</td>
<td>증가함</td>
<td>그대로</td>
<td>없음</td>
</tr>
<tr>
<td>메모리 접근 중</td>
<td>그대로</td>
<td>점점 증가</td>
<td>초당 수천 회</td>
</tr>
<tr>
<td>접근 완료 후</td>
<td>그대로</td>
<td>100MiB 증가</td>
<td>고정됨</td>
</tr>
<tr>
<td>프로세스 종료</td>
<td>사라짐</td>
<td>회수됨</td>
<td>0</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ 즉, 실제로 메모리를 <strong>사용할 때만</strong> 할당되고,<br />페이지 폴트를 통해 커널이 <strong>즉석에서 처리</strong>해주는 방식입니다.</p>
</blockquote>
<h2 id="📦-프로그래밍-언어는-어떻게-사용할까">📦 프로그래밍 언어는 어떻게 사용할까?</h2>
<p>파이썬, Go, C 같은 언어들도 내부적으로 비슷한 전략을 사용합니다.</p>
<ul>
<li>매번 <code>mmap()</code>을 호출하지 않고,</li>
<li>처음 실행 시 <strong>큰 메모리 공간을 확보</strong>한 뒤</li>
<li>그 공간에서 필요한 만큼 잘라 씁니다</li>
</ul>
<blockquote>
<p>📌 이건 malloc(), new, 리스트 생성 등에서도 확인할 수 있어요.</p>
</blockquote>
<h2 id="✨-요약-정리">✨ 요약 정리</h2>
<table>
<thead>
<tr>
<th>개념</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>mmap()</code></td>
<td>가상 주소 공간만 확보하는 시스템 콜</td>
</tr>
<tr>
<td>Demand Paging</td>
<td>메모리에 실제 접근할 때 물리 메모리 할당</td>
</tr>
<tr>
<td>페이지 폴트</td>
<td>접근 시 물리 메모리가 없으면 발생하는 예외</td>
</tr>
<tr>
<td>물리 메모리 할당 시점</td>
<td>페이지 폴트 발생 후</td>
</tr>
<tr>
<td>이점</td>
<td>메모리 낭비 방지, 성능 최적화</td>
</tr>
</tbody></table>
<h2 id="🧠-페이지-폴트가-언제-어떻게-일어나는지-직접-확인해보자">🧠 “페이지 폴트가 언제, 어떻게 일어나는지 직접 확인해보자!”</h2>
<p>우리가 지금 알아보고 싶은 건 한 가지예요.</p>
<blockquote>
<p>“가상 메모리는 처음에 그냥 주소만 할당해주고, 실제 물리 메모리는 언제 주는 걸까?”</p>
</blockquote>
<p>답은 <strong>바로 접근할 때!</strong> 입니다. 이걸 &quot;Demand Paging&quot;이라고 하죠.<br />이번 실험은 바로 <strong>그 Demand Paging이 실제로 어떻게 동작하는지</strong>를 <strong>몸소 확인</strong>하는 실험이에요.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/f3ca673d-dc23-4804-b341-de9f53689a97/image.png" /></p>
<h3 id="🧪-step-1-새로운-메모리-영역-확보-하지만-아직은-비어-있음">🧪 Step 1. 새로운 메모리 영역 확보 (하지만 아직은 비어 있음)</h3>
<p>실험은 Python 코드(<code>demand-paging.py</code>)로 진행됩니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/a9786856-fe26-4db5-8935-ad9f9348ffc2/image.png" /></p>
<pre><code class="language-python">memregion = mmap.mmap(-1, ALLOC_SIZE, flags=mmap.MAP_PRIVATE)</code></pre>
<ul>
<li><code>mmap()</code> 시스템 콜로 <strong>100MiB의 가상 메모리 영역</strong>을 확보합니다.</li>
<li>이때! 실제 물리 메모리는 <strong>아직 아무것도 할당되지 않았어요.</strong></li>
<li>그저 “이 주소부터 이만큼 쓸 수 있게만 해줘~” 한 것뿐입니다.</li>
</ul>
<blockquote>
<p>📦 아직 책장을 조립해놓기만 했고, 책은 한 권도 안 꽂혀 있는 상태죠.</p>
</blockquote>
<h3 id="🧪-step-2-접근을-시작하자-→-페이지-폴트-발생">🧪 Step 2. 접근을 시작하자! → 페이지 폴트 발생</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/1efe6140-5639-4b1e-89d2-494229556438/image.png" /></p>
<pre><code class="language-python">for i in range(0, ALLOC_SIZE, PAGE_SIZE):
    memregion[i] = 8  # 각 페이지에 첫 바이트 접근</code></pre>
<p>이제 메모리 영역의 <strong>각 페이지에 1바이트씩 접근</strong>합니다.<br />이 순간! Demand Paging이 시작돼요.</p>
<ul>
<li>페이지에 처음 접근하면 운영체제가 “이 주소엔 아직 물리 메모리가 없어!”를 감지하고,</li>
<li>➡ <strong>페이지 폴트가 발생!</strong></li>
<li>➡ 운영체제가 <strong>실제 물리 메모리 페이지를 할당</strong>해줍니다.</li>
<li>➡ 페이지 테이블을 업데이트하고, 방금 중단됐던 명령어를 <strong>다시 실행</strong>합니다.</li>
</ul>
<blockquote>
<p>✨ “필요할 때만 책을 꺼내 꽂는 방식” — 이게 바로 Demand Paging입니다!</p>
</blockquote>
<h3 id="🧪-step-3-sar-명령어로-시스템-상태를-관찰해보자">🧪 Step 3. sar 명령어로 시스템 상태를 관찰해보자</h3>
<p>실행 중 <code>sar -r 1</code>, <code>sar -B 1</code> 명령어를 병렬로 실행하면 다음을 확인할 수 있어요:</p>
<h4 id="🖥️-메모리-사용량-sar--r-1">🖥️ 메모리 사용량 (<code>sar -r 1</code>)</h4>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/03c6ed7d-5b77-4456-a018-fd64fde70a81/image.png" /></p>
<ul>
<li>메모리 영역만 확보한 직후엔 메모리 사용량 거의 변화 없음</li>
<li>실제로 접근을 시작한 이후부터 초당 약 <strong>10MiB씩</strong> 물리 메모리 사용량이 증가</li>
<li>프로그램이 종료되면 메모리 사용량도 <strong>원래대로 돌아감</strong></li>
</ul>
<h4 id="🔍-페이지-폴트-발생-sar--b-1">🔍 페이지 폴트 발생 (<code>sar -B 1</code>)</h4>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/7da22e93-df00-4d13-b8a0-29424e606e25/image.png" /></p>
<ul>
<li>접근이 시작된 순간부터 <code>fault/s</code>(초당 페이지 폴트 수) <strong>수천 단위로 급증</strong></li>
<li>페이지 폴트는 접근한 만큼만 발생 (100MiB → 약 25,000개 페이지 접근 = 그만큼 폴트 발생)</li>
</ul>
<blockquote>
<p>이건 바로 <strong>물리 메모리가 필요한 순간에만 할당</strong>되기 때문이에요!</p>
</blockquote>
<h3 id="📊-capturesh로-프로세스-상태-실시간-모니터링">📊 capture.sh로 프로세스 상태 실시간 모니터링</h3>
<p>이제 특정 프로세스(demand-paging.py)의 상태를 1초 간격으로 살펴보는 스크립트를 실행해볼 수 있어요:</p>
<pre><code class="language-bash">./capture.sh</code></pre>
<p>출력되는 주요 지표는 다음과 같아요:</p>
<table>
<thead>
<tr>
<th>항목</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td><code>VSZ</code></td>
<td>가상 메모리 크기</td>
</tr>
<tr>
<td><code>RSS</code></td>
<td>실제로 할당된 물리 메모리 크기</td>
</tr>
<tr>
<td><code>maj_flt</code></td>
<td>메이저 페이지 폴트 횟수</td>
</tr>
<tr>
<td><code>min_flt</code></td>
<td>마이너 페이지 폴트 횟수</td>
</tr>
</tbody></table>
<h4 id="📈-실행-중-확인된-변화">📈 실행 중 확인된 변화</h4>
<ul>
<li>가상 메모리(VSZ)는 미리 할당되었기 때문에 <strong>처음부터 100MiB 수준</strong></li>
<li>하지만 실제 물리 메모리(RSS)는 페이지에 접근할 때마다 점점 증가</li>
<li>페이지 폴트(min_flt)는 각 페이지마다 발생하며 점점 누적됨</li>
</ul>
<blockquote>
<p>마치, 책장에 매번 책 한 권씩 꽂을 때마다 알람이 울리는 거예요. &quot;책 왔다!&quot; 📦</p>
</blockquote>
<h3 id="🧠-정리-요약">🧠 정리 요약</h3>
<table>
<thead>
<tr>
<th>단계</th>
<th>설명</th>
<th>메모리 변화</th>
</tr>
</thead>
<tbody><tr>
<td><code>mmap()</code> 호출</td>
<td>가상 주소 공간만 확보 (물리 메모리 없음)</td>
<td>VSZ 증가, RSS 변화 없음</td>
</tr>
<tr>
<td>각 페이지 접근 시작</td>
<td>페이지 폴트 발생 → 물리 메모리 동적 할당</td>
<td>RSS 증가, fault/s 증가</td>
</tr>
<tr>
<td>접근 완료</td>
<td>모든 페이지에 물리 메모리 할당 완료</td>
<td>RSS = VSZ</td>
</tr>
<tr>
<td>프로그램 종료</td>
<td>모든 메모리 해제</td>
<td>VSZ, RSS 모두 감소</td>
</tr>
</tbody></table>
<h3 id="💡-마무리-한-줄-요약">💡 마무리 한 줄 요약</h3>
<blockquote>
<p>“Demand Paging은 미리 메모리를 주지 않지만, 필요한 순간엔 정확히 필요한 만큼만, 스마트하게 준다!”</p>
</blockquote>
<p>📌 운영체제의 메모리 효율 전략이란 이런 것이다!  </p>
<h1 id="📗-페이지-테이블은-얼마나-메모리를-쓸까와-계층형-테이블-구조">📗 &quot;페이지 테이블은 얼마나 메모리를 쓸까?&quot;와 계층형 테이블 구조</h1>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/53414782-5201-4171-a376-d7cced1eb560/image.png" /></p>
<h2 id="🧠-페이지-테이블은-얼마나-메모리를-쓸까">🧠 &quot;페이지 테이블은 얼마나 메모리를 쓸까?&quot;</h2>
<blockquote>
<p>가상 주소 공간이 어마어마하게 넓은데, 그걸 전부 관리하려면 페이지 테이블도 엄청 커야 하지 않을까?</p>
</blockquote>
<h3 id="📘-페이지-테이블은-뭐냐면요">📘 페이지 테이블은 뭐냐면요...</h3>
<p>&quot;컴퓨터의 주소록&quot;이에요!
우리 집 주소는 “서울시 00구 123-45번지” 같은 가상 주소잖아요? 그런데 실제로 물건은 창고 안 칸칸마다 들어 있어요.
이때 &quot;가상 주소 → 실제 주소(창고칸)&quot;을 알려주는 게 바로 페이지 테이블이에요!</p>
<blockquote>
<p>✅ 즉, 페이지 테이블 = 주소 변환 표</p>
</blockquote>
<h3 id="1️⃣-단순-계산-진짜-그렇게-큰가">1️⃣ 단순 계산: 진짜 그렇게 큰가?</h3>
<blockquote>
<p>📊 그런데 페이지 테이블이 왜 이렇게 크다고 하는 걸까요?</p>
</blockquote>
<p><strong>🔍 가정: x86_64 아키텍처</strong></p>
<ul>
<li>가상 주소 공간: <strong>128TB</strong></li>
<li>페이지 크기: <strong>4KB (4,096바이트)</strong></li>
<li>한 페이지를 찾기 위해 필요한 정보(엔트리): <strong>8바이트</strong></li>
</ul>
<p>그럼 얼마나 많은 페이지가 필요하냐면...</p>
<blockquote>
<p><strong>128TB ÷ 4KB = 약 34,359,738,368개! (약 340억 개 페이지)</strong><br />거기다 <strong>각 페이지마다 8바이트 정보</strong>가 필요하니...</p>
</blockquote>
<pre><code>340억 개 × 8바이트 = 256GB</code></pre><p>😱 페이지 테이블만 256GB나 필요하다는 말이 되는 거예요!  
근데... 내 컴퓨터 RAM은 16GB밖에 안 되는데?!?</p>
<blockquote>
<p>🤔 “헉, 그럼 우리 컴퓨터는 멀쩡히 돌아가는 거 맞아?”<br />맞아요. 왜냐하면...</p>
</blockquote>
<h3 id="2️⃣-진짜-핵심-계층형-구조라서-괜찮아요">2️⃣ 진짜 핵심! “계층형 구조라서 괜찮아요”</h3>
<p>여기서 비밀 무기 등장! 바로 <strong>계층형 페이지 테이블 구조</strong>예요.<br />이건 “필요한 것만 꺼내 쓰는” 방식이에요.</p>
<h3 id="🌲-계층형-페이지-테이블은-이렇게-동작해요">🌲 계층형 페이지 테이블은 이렇게 동작해요:</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/783bfe84-1725-4823-9615-5a21fb07b587/image.png" /></p>
<ol>
<li>📚 <strong>1단계:</strong> &quot;책장 큰 분류&quot; (예: 영어책, 과학책, 만화책...)</li>
<li>📘 <strong>2단계:</strong> &quot;해당 분류의 실제 책 목록&quot;</li>
<li>📄 <strong>3단계:</strong> &quot;책의 실제 내용 페이지&quot;</li>
</ol>
<blockquote>
<p>만약 만화책만 본다면, <strong>과학책 목록이나 내용은 아예 만들지도 않아요!</strong></p>
</blockquote>
<p>즉,</p>
<ul>
<li>우리가 실제 사용하는 가상 주소 범위만큼만!</li>
<li>필요한 <strong>테이블 일부만 메모리에 생성</strong>해요!</li>
</ul>
<p>그래서 실제로는 전체 256GB가 <strong>필요하지 않아요.</strong></p>
<blockquote>
<p>페이지 테이블은 실제로 <strong>나무처럼 계층 구조(Tree-like structure)</strong>로 되어 있어요.</p>
</blockquote>
<h4 id="✅-단일-구조-vs-계층-구조-비교">✅ 단일 구조 vs 계층 구조 비교</h4>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/0a85bd17-f245-4a75-9d64-f35dcdf41393/image.png" /></p>
<ul>
<li>평탄한 테이블(flat): 전체 공간을 한눈에 다 관리<ul>
<li>공간 낭비 심해요.</li>
</ul>
</li>
</ul>
<ul>
<li>계층 구조(hierarchical): 필요한 부분만 만들고 관리<ul>
<li>공간 아껴서 현실적으로 운영 가능해요.</li>
</ul>
</li>
</ul>
<h4 id="🧩-예시-페이지-크기-100바이트-가상-주소-공간-1600바이트">🧩 예시 (페이지 크기 100바이트, 가상 주소 공간 1600바이트):</h4>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/56274e64-ee22-433a-a515-4756d11fb116/image.png" /></p>
<ul>
<li><strong>평탄한 구조</strong>: 전체 페이지 엔트리 16개 필요</li>
<li><strong>2단 계층형</strong>: 실제 사용하는 페이지만 테이블에 포함 → 엔트리 수 8개로 감소!</li>
</ul>
<table>
<thead>
<tr>
<th>구조</th>
<th>설명</th>
<th>메모리 낭비 여부</th>
</tr>
</thead>
<tbody><tr>
<td>평탄형 (1차원)</td>
<td>모든 페이지에 대해 무조건 엔트리 생성</td>
<td>있음 😭</td>
</tr>
<tr>
<td>계층형 (트리 구조)</td>
<td>필요한 페이지만 점차 구조 생성</td>
<td>없음 😊</td>
</tr>
</tbody></table>
<h3 id="3️⃣-현실-x86_64는-4단계-계층형-페이지-테이블-🪜">3️⃣ 현실: x86_64는 <strong>4단계 계층형</strong> 페이지 테이블 🪜</h3>
<ul>
<li>시스템에 따라 다르지만, 리눅스 x86_64는 일반적으로 4단계 구조를 사용해요:<ul>
<li><strong>PML4</strong> → <strong>PDPT</strong> → <strong>PD</strong> → <strong>PT</strong> → 실제 페이지</li>
</ul>
</li>
</ul>
<p>👉 그래서 프로세스 하나가 256GB를 차지하지 않고도, 메모리를 효율적으로 관리할 수 있는 거예요!</p>
<h3 id="sar---all-명령">sar - ALL 명령</h3>
<p>시스템이 사용하는 물리 메모리 중에서 페이지 테이블이 사용하는 메모리는 sar - ALL 명령어로 kbpgtbl 필드에서 확인할 수 있습니다</p>
<h3 id="🏁-정리-한줄-요약">🏁 정리 한줄 요약!</h3>
<blockquote>
<p>“페이지 테이블은 처음 보면 너무 커 보여도, 실제로는 ‘필요한 만큼만’ 만들어서 똑똑하게 메모리를 아껴요!”</p>
</blockquote>
<h2 id="🧱-huge-page와-transparent-huge-page-thp">🧱 Huge Page와 Transparent Huge Page (THP)</h2>
<p>메모리 관리 효율을 한 단계 더 끌어올리기 위한 기술이에요.
<img alt="" src="https://velog.velcdn.com/images/prettylee620/post/8d3750a7-80b6-487b-b627-5ba9227cc25b/image.png" />
이걸 1페이지당 크기가 400바이트인 Huge Page로 바꾸면 페이지 테이블 계층을 1단은 건너뛰고 [그림 04-24]처럼 됩니다.</p>
<h3 id="4️⃣-huge-page-페이지를-크게-써서-엔트리-줄이자">4️⃣ Huge Page: &quot;페이지를 크게 써서 엔트리 줄이자!&quot;</h3>
<blockquote>
<p>기본 페이지는 4KiB지만, <strong>Huge Page는 보통 2MiB~1GiB</strong></p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/64bb0d58-c02d-4f78-bef7-64d2ec61cc8a/image.png" /></p>
<h4 id="✅-장점">✅ 장점</h4>
<ul>
<li>페이지 테이블의 엔트리 수가 확 줄어듦</li>
<li>페이지 테이블 복사 비용도 줄어서 <code>fork()</code> 속도 향상!</li>
</ul>
<h4 id="💻-사용-방법">💻 사용 방법</h4>
<pre><code class="language-c">mmap(..., MAP_HUGETLB);  // 명시적으로 Huge Page 요청</code></pre>
<blockquote>
<p>대용량 데이터 처리하는 DB, 가상머신 등에 좋음</p>
</blockquote>
<h3 id="5️⃣-transparent-huge-page-thp-자동으로-알아서-써줄게">5️⃣ Transparent Huge Page (THP): “자동으로 알아서 써줄게!”</h3>
<blockquote>
<p>프로그래머가 명시하지 않아도, OS가 <strong>알아서</strong> 4KiB 페이지들을 묶어서 Huge Page로 만들어줍니다.</p>
</blockquote>
<h4 id="✅-장점-1">✅ 장점</h4>
<ul>
<li>성능 향상 기대</li>
<li>프로그래머가 직접 Huge Page 설정 안 해도 됨</li>
</ul>
<h4 id="⚠️-주의점">⚠️ 주의점</h4>
<ul>
<li>조건이 맞아야 합쳐짐</li>
<li>다시 4KiB로 쪼개는 비용도 있어서 성능이 <strong>오히려 낮아질 수도 있음</strong></li>
</ul>
<h4 id="🛠-설정-확인-및-변경">🛠 설정 확인 및 변경</h4>
<pre><code class="language-bash">cat /sys/kernel/mm/transparent_hugepage/enabled
# 출력 예시: always [madvise] never</code></pre>
<ul>
<li><strong>always</strong> : 항상 THP 사용</li>
<li><strong>madvise</strong> : <code>madvise()</code> 시스템콜로 요청한 경우만 사용 (Ubuntu 20.04 기본값)</li>
<li><strong>never</strong> : THP 비활성화</li>
</ul>
<h2 id="🧠-정리-요약-1">🧠 정리 요약</h2>
<table>
<thead>
<tr>
<th>개념</th>
<th>설명</th>
<th>장점</th>
<th>주의점</th>
</tr>
</thead>
<tbody><tr>
<td>평탄한 페이지 테이블</td>
<td>전 범위를 일괄 관리</td>
<td>구조 간단</td>
<td>메모리 낭비 큼</td>
</tr>
<tr>
<td>계층형 페이지 테이블</td>
<td>필요한 범위만 계층적으로 구성</td>
<td>메모리 효율적</td>
<td>구조 복잡</td>
</tr>
<tr>
<td>Huge Page</td>
<td>페이지 단위 자체를 키움 (ex. 2MiB)</td>
<td>페이지 테이블 작아짐</td>
<td>명시적 설정 필요</td>
</tr>
<tr>
<td>Transparent Huge Page</td>
<td>연속된 페이지를 OS가 자동으로 묶음</td>
<td>자동 최적화</td>
<td>오히려 느려질 수도 있음</td>
</tr>
</tbody></table>
<h1 id="보충-정리--새로운-메모리-계층과-운영체제의-역할">보충 정리 : 새로운 메모리 계층과 운영체제의 역할</h1>
<blockquote>
<p>출처 : <a href="https://medium.com/rate-labs/%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5%EA%B3%BC-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0-92109ebea01a">https://medium.com/rate-labs/%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5%EA%B3%BC-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%97%AD%ED%95%A0-92109ebea01a</a></p>
</blockquote>
<h2 id="📚-dram이-부족한-세상-계층형-메모리가-나타났다">📚 &quot;DRAM이 부족한 세상, 계층형 메모리가 나타났다!&quot;</h2>
<h3 id="1️⃣-dram의-성장-둔화와-새로운-시대의-도래">1️⃣ DRAM의 성장 둔화와 새로운 시대의 도래</h3>
<p>옛날에는 DRAM이 무서운 속도로 성장했어요.  </p>
<ul>
<li>초창기엔 3년에 4배씩! 🚀  </li>
<li>그다음엔 2년에 2배씩!  </li>
<li>그런데 최근엔... <strong>4년에 겨우 2배</strong>.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/46f9a579-dc59-4d07-852c-7fd538d1f32a/image.png" /></p>
<p>한마디로 &quot;DRAM 성장이 예전 같지 않다...&quot;는 거죠.<br />하지만 세상은 점점 더 많은 데이터를 원해요.  </p>
<ul>
<li>글에서 → 사진에서 → 영상으로  </li>
<li>그리고 요즘은 <strong>AI가 데이터를 폭식</strong> 중이에요.</li>
</ul>
<blockquote>
<p>“DRAM만으로는 도저히 감당할 수 없다!”</p>
</blockquote>
<p>그래서 연구자들은 대안을 찾아 나섰습니다.</p>
<h3 id="2️⃣-대안-새로운-메모리-기술의-등장">2️⃣ 대안: 새로운 메모리 기술의 등장!</h3>
<p>DRAM을 보완하거나 대체할 방법들, 바로 이것들이에요:</p>
<ul>
<li>🔁 <strong>Persistent Memory (PM)</strong></li>
<li>🔌 <strong>Non-volatile Memory (NVM)</strong></li>
<li>🌪️ <strong>Storage Class Memory (SCM)</strong></li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/3d3e5f1e-cc82-4255-821d-4a23ce8bd9b3/image.png" /></p>
<p>그리고 그 안에는 또 멋진 기술들이 숨어 있어요:</p>
<ul>
<li>PCM, FeRAM, STT-RAM 같은 신소재 기반 메모리들</li>
<li>그리고 인텔의 Optane 같은 <strong>실제 상용 제품</strong>도 나왔죠.</li>
</ul>
<p>또 하나, <strong>Disaggregated Memory</strong>란 개념도 나왔어요.<br />→ 여러 서버의 DRAM을 합쳐 하나의 거대한 메모리처럼 쓰는 거예요!</p>
<blockquote>
<p>🚍 최근엔 CXL(Compute Express Link)이라는 고속 통신 기술 덕분에,<br />CPU가 원격 메모리에 <strong>마치 내 것처럼</strong> 빠르게 접근할 수 있게 됐습니다.</p>
</blockquote>
<h3 id="3️⃣-현실적인-전략-계층형-메모리-시스템-등장">3️⃣ 현실적인 전략: 계층형 메모리 시스템 등장!</h3>
<p>그렇다고 &quot;DRAM이 없어도 된다&quot;는 건 아니에요.<br />오히려 <strong>DRAM을 캐시처럼</strong> 사용해서<br /><strong>속도와 용량 사이에서 절묘한 균형을 찾자!</strong> 이게 핵심입니다.</p>
<p>그래서 만들어진 구조가 바로 이거예요:</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/d725479a-c175-4856-967c-cc67f9869dad/image.png" /></p>
<pre><code>CPU 가까이: 빠르지만 비싼 메모리 (L1/L2 캐시, DRAM)
CPU 멀리: 느리지만 큰 메모리 (SCM, SSD 등)</code></pre><blockquote>
<p>🎯 목표는 단 하나!  
&quot;핫한 데이터는 위쪽에서, 콜드한 데이터는 아래쪽에서 처리하자!&quot;</p>
</blockquote>
<h3 id="4️⃣-문제-1-어떤-데이터를-남기고-어떤-걸-버릴까-페이지-교체-알고리즘">4️⃣ 문제 1: “어떤 데이터를 남기고, 어떤 걸 버릴까?” (페이지 교체 알고리즘)</h3>
<p>계층 구조에서 가장 중요한 건<br />➡ <strong>무슨 데이터를 DRAM에 두고, SCM으로 내릴지 결정하는 것</strong>이에요.</p>
<p>🔍 판단 기준은 두 가지:</p>
<ol>
<li>얼마나 자주 접근했는가 (빈도) → <strong>LFU</strong></li>
<li>마지막 접근이 얼마나 최근인가 (최신성) → <strong>LRU</strong></li>
</ol>
<blockquote>
<p>현실에선 이 둘을 적절히 섞어서 판단해요.</p>
</blockquote>
<p>그런데! 운영체제는 모든 데이터 접근을 <strong>완벽히 알 수가 없어요.</strong></p>
<h4 id="🛑-기존-방식의-한계">🛑 기존 방식의 한계:</h4>
<ul>
<li><code>PTE 접근 비트</code>는 정확하지 않음 (TLB 덕분에 생략되기도 함)</li>
<li><code>의도적 페이지 폴트</code>는 성능에 악영향 😭</li>
</ul>
<h4 id="✅-최근-해결책-intel의-pebs-활용">✅ 최근 해결책: <strong>Intel의 PEBS 활용!</strong></h4>
<ul>
<li>CPU 내부 이벤트를 샘플링해서</li>
<li>어떤 주소가 <strong>실제로 접근됐는지</strong> 확인 가능!</li>
<li>성능 부담도 적고, TLB 접근도 빠짐없이 기록됨!</li>
</ul>
<h3 id="5️⃣-문제-2-공간을-너무-낭비하고-있진-않을까-공간-효율성-문제">5️⃣ 문제 2: “공간을 너무 낭비하고 있진 않을까?” (공간 효율성 문제)</h3>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/1c4f1edb-3ce6-4ade-83d4-55a495dcc64f/image.png" /></p>
<blockquote>
<p>Huge page 로 인한 비효율적인 공간 활용</p>
</blockquote>
<h4 id="🧱-huge-page가-왜-쓰일까">🧱 Huge Page가 왜 쓰일까?</h4>
<ul>
<li>4KB 페이지 512개 → 2MB Huge Page</li>
<li>TLB 커버리지가 커지고, 페이지 테이블도 줄어요!</li>
</ul>
<h4 id="😨-그런데-문제가">😨 그런데 문제가...</h4>
<ul>
<li>2MB 중에 딱 4KB만 쓰면?</li>
<li>나머지 1.996MB는 낭비! → 메모리 부풀림(bloat) 발생!</li>
</ul>
<h4 id="🔄-해결책-필요하면-다시-쪼개기">🔄 해결책: 필요하면 다시 쪼개기!</h4>
<ul>
<li>Huge Page를 4KB base page로 분해해서,<br />진짜 ‘핫한’ 페이지만 DRAM에 넣자!</li>
</ul>
<p>하지만 이것도 쉽지 않아요:</p>
<ul>
<li>다시 huge로 합쳐야 할 수도 있음</li>
<li>쪼개고 합치는 데 <strong>시간과 비용</strong> 발생</li>
</ul>
<p>그래서 연구자들은 적당한 타이밍과 기준을 찾아내려는 알고리즘도 연구 중이에요.<br />예: Memtis(2023)은 내부 단편화 수준을 보고 쪼개는 기준을 제안했어요!</p>
<h2 id="🔚-결론-계층-메모리-시스템-아직-갈-길이-멀지만-가능성은-크다">🔚 결론: 계층 메모리 시스템, 아직 갈 길이 멀지만 가능성은 크다!</h2>
<ul>
<li>DRAM은 더 이상 무한히 커지지 않아요.</li>
<li>그래서 새로운 메모리 계층, 페이지 교체, 공간 관리 등이 필요해졌고</li>
<li>이를 해결하기 위한 기술과 아이디어들이 쏟아지고 있어요.</li>
</ul>
<blockquote>
<p>“10년 후에는, 우리가 쓰는 메모리 구조가 지금과 완전히 달라질지도 몰라요!”</p>
</blockquote>
<h2 id="🎉-자-이제-정리해볼까요">🎉 자, 이제 정리해볼까요?</h2>
<p>이렇게 리눅스가 메모리를 어떻게 똑똑하게 관리하고, 메모리가 부족할 때 어떤 행동을 하는지 알아봤어요. 실제로 컴퓨터를 쓰면서 가끔 <code>free</code> 명령어나 <code>sar</code> 명령어로 메모리를 관찰해보세요. 리눅스의 똑똑한 메모리 관리 시스템을 직접 느낄 수 있을 거예요~</p>