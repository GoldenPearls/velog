<h2 id="1-내장-톰켓을-가진다">1. 내장 톰켓을 가진다.</h2>
<h3 id="socket">socket</h3>
<ul>
<li>운영체제가 가지고 잇는 것으로 시스템 연계 방식의 간접적 연계방식 중 하나</li>
<li>서버는 통신을 위한 소켓을 생성하여 포트를 할당하고 클라이언트의 <strong>통신 요청 시 클라이언트와
연결하는 네트워크 기술</strong>, 송신 기술</li>
<li>소켓은 포트번호가 있어야 함</li>
</ul>
<p>ip주소와 포트번호를 넣고 연결한다. A와 사용자 B를 연결하며 통신한다. 그러다가 B가 5001 port와 통신하게 되면 <strong>A는 다른 사용자인 C와 통신이 불가능하게 된다.</strong></p>
<p>왜냐하면 <strong>CPU가 일을 하고 있기 때문이다.</strong> 그렇기 때문에 <code>스레드</code>를 만든다. 5000번은 main 스레드로 5001은 스레드 1로 만든다.  </p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/d1e07622-5984-4dfa-b952-10b6e911979f/image.png" /></p>
<p>그렇게 되면 C는 A와 연결이 가능하게 된다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/9e791c33-59d8-4898-8ea8-90edbaf033e4/image.png" /></p>
<p>그 후에는 또 랜덤으로 <strong>소켓의 포트번호가 생성</strong>되고 나서 <code>새로운 스레드</code>로 만들어지고 그리고 나서 <strong>5000번인 main 스레드</strong>와의 연결이 또 끊기게 된다. 왜냐하면 새로운 사용자의 <strong>요청을 받아야 하기 때문</strong>이다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/f7bd7ca0-1354-4566-bef1-265bc7ce9f15/image.png" /></p>
<p>C와 5002이 연결된다. 통신한다. 이런 방식이 바로 <code>소켓 통신</code>이다.</p>
<p>소켓의 장점은 <strong>연결이 끊어지지 않는다</strong>. 연결되고 나서 연결된 사람은 같은 사람으로 계속 인식하지만 이렇게 되면 단점은 <strong>부하가 많아지게 돼서 느려질 수 있다.</strong> </p>
<p>그래서 <strong>Http 통신 방식(문서를 전달하는 통신)</strong>은 계속 이어지는 소켓 통신 방식이 아닌 지속시키지 않고 연결을 <strong>끊어버리는 <code>Stateless</code> 방식을 사용</strong>한다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/9dde95a2-8da7-48a2-98a7-d1fb5bfd8623/image.png" /></p>
<p>문서를 요청 받으면 문서를 돌려주고 연결을 끊어버린다.</p>
<p>그렇기 때문에 <strong>장점은 부하가 적다.</strong> 그렇지만 <strong>단점으로는 항상 새로운 사람으로 인식</strong>한다. </p>
<p>이러한 단점들을 보완하면서 만들어진 것이 Web 서버다. </p>
<h3 id="웹-서버web-server란">웹 서버(Web Server)란?</h3>
<blockquote>
<p>🔗 전에 자세히 정리 한 것 : <a href="https://velog.io/@prettylee620/CS-%EC%A7%80%EC%8B%9D-%EC%84%9C%EB%B2%84%EA%B4%80%EB%A0%A8">https://velog.io/@prettylee620/CS-지식-서버관련</a></p>
</blockquote>
<p>웹 서버는 클라이언트로부터 요청을 받으면 해당 요청에 대한 처리를 수행하고, 클라이언트에게 응답을 전송하는 역할을 한다. 이때, <strong>각 클라이언트의 상태를 기억하지 않고, 각 요청에 대해 독립적으로 응답하는 특성을 갖는다.</strong> 이러한 특징은 <code>&quot;Stateless(상태 없음)&quot;</code>한 특성을 가진다고 표현된다.</p>
<p>웹 서버는 <code>HTTP 프로토콜</code>을 <strong>기반으로 동작</strong>하며, 클라이언트가 요청을 보내면 서버는 해당 요청에 대한 응답을 생성하여 반환한다. 서버는 각 요청에 대해 독립적으로 처리하므로, 클라이언트와의 연결을 지속적으로 유지하지 않는다. 이러한 특성은 간단하고 빠른 응답을 가능하게 하며, 많은 클라이언트에 대한 처리를 효율적으로 수행할 수 있다.</p>
<p>즉, 정리하자면 </p>
<ul>
<li>웹 서버는 클라이언트로부터 요청을 받아 해당 요청에 대한 처리를 수행하고, 클라이언트에게 응답을 전송하는 역할을 하는 소프트웨어 또는 하드웨어</li>
<li>웹 서버는 주로 정적인 콘텐츠(HTML 페이지, 이미지 파일 등)을 제공하며, 동적인 요청에 대한 처리는 웹 애플리케이션 서버(웹 애플리케이션을 실행하는 서버)에 위임할 수 있다.</li>
<li>Apache, Nginx, Microsoft IIS 등이 웹 서버의 예시</li>
</ul>
<h3 id="🤔-그렇다면-다른-간접-연계-방식인-웹-서비스랑은-다른거겠지">🤔 그렇다면 다른 간접 연계 방식인 웹 서비스랑은 다른거겠지?</h3>
<p>Yes</p>
<p><code>웹 서비스</code>는 웹 서버의 기능을 넘어서, <strong>네트워크를 통해 서로 다른 시스템 간에 상호작용하기 위한 표준화된 방법을 제공하는 서비스를 의미</strong>한다. 웹 서비스는 주로 XML 또는 JSON 형식의 데이터를 교환하며, 서로 다른 플랫폼 간에 통신을 가능하게 하는 기술적인 규격을 포함한다. RESTful API나 SOAP 등이 웹 서비스의 예시</p>
<p>간단하게 말하면, <code>웹 서비스</code>는 <strong>네트워크 상에서 서로 다른 시스템 간에 표준화된 방법으로 통신하기 위한 규격</strong>을 나타내는 것이며, <code>웹 서버</code>는 클라이언트의 요청을 받아 정적인 콘텐츠를 제공하거나 동적인 처리를 위해 <strong>애플리케이션 서버로 요청을 전달하는 역할을 하는 소프트웨어 또는 하드웨어</strong>를 나타낸다.</p>
<h3 id="http란">HTTP란?</h3>
<blockquote>
<p>예전에 수기 문서로 논문을 찾던 시절 자신의 논문을 업로드에서 다른 사람들이 논문 쓸 때 겹치지 않게 참고하라고 올린다. 그 올린 것을 받아오기만 하면 돼서 연결이 지속될 필요 x ⇒ HTTP</p>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/prettylee620/post/1811eaef-d383-46e3-92fa-6f6214ebe590/image.png" /></p>
<ul>
<li>웹 서비스를 위해 이용되는 프로토콜로 보안성이 안 좋음</li>
<li>암호화되지 않는 상태로 웹 볼 때 사용되는 프로토콜</li>
<li>인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약</li>
</ul>